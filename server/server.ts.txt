// server/server.ts
import express from 'express';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';
import { exec, spawn, ChildProcess } from 'child_process';
import type { LLMTool, NewToolPayload, AIToolCall } from '../types';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = 3001;
const TOOLS_DB_PATH = path.join(__dirname, 'tools.json');
const SCRIPTS_DIR = path.join(__dirname, 'scripts');
const ASSETS_DIR = path.join(__dirname, 'assets');

// --- In-memory state ---
let serverToolsCache: LLMTool[] = [];
let gemmaProcess: ChildProcess | null = null;
let kicadServiceProcess: ChildProcess | null = null;
const KICAD_SERVICE_PORT = 8000;
const KICAD_SERVICE_TIMEOUT = 600000; // 10 minutes for long-running tasks like autorouting
let gemmaLogs: string[] = [];
const MAX_LOGS = 100;

// --- Middleware ---
app.use(cors()); // Allow requests from the frontend
app.use(express.json()); // Parse JSON bodies
// Statically serve the scripts and assets directory to allow frontend access to generated files
app.use('/scripts', express.static(SCRIPTS_DIR));
app.use('/assets', express.static(ASSETS_DIR));

// --- Utility Functions ---
const readToolsAndLoadCache = async (): Promise<LLMTool[]> => {
    try {
        await fs.access(TOOLS_DB_PATH);
        const data = await fs.readFile(TOOLS_DB_PATH, 'utf-8');
        serverToolsCache = JSON.parse(data) as LLMTool[];
        console.log(`[INFO] Loaded ${serverToolsCache.length} tools into server cache.`);
        return serverToolsCache;
    } catch (error) {
        serverToolsCache = [];
        console.log('[INFO] tools.json not found or empty. Initializing with 0 server tools.');
        return [];
    }
};

const writeTools = async (tools: LLMTool[]): Promise<void> => {
    await fs.writeFile(TOOLS_DB_PATH, JSON.stringify(tools, null, 2));
};

const generateMachineReadableId = (name: string, existingTools: LLMTool[]): string => {
  let baseId = name.trim().toLowerCase().replace(/[^a-z0-9\s_]/g, '').replace(/\s+/g, '_').slice(0, 50);
  if (!baseId) baseId = 'unnamed_tool';
  let finalId = baseId;
  let counter = 1;
  const existingIds = new Set(existingTools.map(t => t.id));
  while (existingIds.has(finalId)) {
    finalId = `${baseId}_${counter}`;
    counter++;
  }
  return finalId;
};

const addLog = (log: string) => {
    gemmaLogs.push(log);
    if (gemmaLogs.length > MAX_LOGS) {
        gemmaLogs.shift();
    }
};

const isKicadServiceHealthy = async (): Promise<boolean> => {
    try {
        // Use native fetch's AbortSignal for timeouts
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1000); // 1-second timeout
        const response = await fetch(`http://127.0.0.1:${KICAD_SERVICE_PORT}/health`, {
            method: 'GET',
            signal: controller.signal,
        });
        clearTimeout(timeoutId);
        return response.ok;
    } catch (error) {
        return false;
    }
};

const startKicadService = async (): Promise<{ success: boolean; message: string; error?: string }> => {
    // 1. Check if service is already running and healthy
    if (await isKicadServiceHealthy()) {
        if (!kicadServiceProcess) {
            console.log('[INFO] KiCad Service is responsive but not managed by this server process (likely an orphan). Continuing without a process handle.');
        }
        return { success: true, message: 'KiCad Service is already running and responsive.' };
    }
    
    // 2. If not healthy, and we think we have a process handle, it might be stuck.
    if (kicadServiceProcess) {
        console.warn('[WARN] KiCad Service process handle exists but service is unresponsive. Killing old process...');
        kicadServiceProcess.kill('SIGKILL'); // Use SIGKILL for unresponsive processes
        kicadServiceProcess = null;
        await new Promise(resolve => setTimeout(resolve, 500)); // Give OS time to release port
    }

    try {
        // 3. Spawn a new process
        console.log('[INFO] Spawning new KiCad Service process...');
        const pythonExecutable = path.join(__dirname, '..', 'venv', 'bin', 'python');
        const scriptPath = path.join(SCRIPTS_DIR, 'kicad_service.py');
        
        const newProcess = spawn(pythonExecutable, [scriptPath], {
            env: { ...process.env, KICAD_SERVICE_PORT: KICAD_SERVICE_PORT.toString() }
        });
        kicadServiceProcess = newProcess; // Assign immediately
        
        newProcess.stdout?.on('data', (data) => console.log(`[KiCad Service]: ${data.toString().trim()}`));
        newProcess.stderr?.on('data', (data) => console.error(`[KiCad Service ERR]: ${data.toString().trim()}`));
        
        newProcess.on('close', (code) => {
            console.log(`KiCad Service process exited with code ${code}`);
            // Check if the current process is the one that closed
            if (kicadServiceProcess === newProcess) {
                kicadServiceProcess = null;
            }
        });
        newProcess.on('error', (err) => {
            console.error(`[FATAL] Failed to start KiCad Service process: ${err.message}`);
            if (kicadServiceProcess === newProcess) {
                kicadServiceProcess = null;
            }
        });

        // 4. Poll for healthiness
        const startTime = Date.now();
        const timeout = 15000; // 15 seconds
        while (Date.now() - startTime < timeout) {
            if (await isKicadServiceHealthy()) {
                console.log('[INFO] New KiCad Service is now healthy.');
                return { success: true, message: 'KiCad Service started successfully.' };
            }
            if (!kicadServiceProcess) { // Process crashed during startup
                 throw new Error("KiCad Service process exited prematurely during startup. Check service logs for errors.");
            }
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        throw new Error(`KiCad Service failed to become healthy within ${timeout / 1000} seconds.`);

    } catch (e) {
        const err = e as Error;
        if (kicadServiceProcess) {
            kicadServiceProcess.kill('SIGKILL');
            kicadServiceProcess = null;
        }
        return { success: false, message: `Failed to start KiCad Service: ${err.message}`, error: err.message };
    }
};

// --- API Endpoints ---

// Get all server-side tools from the cache
app.get('/api/tools', (req: express.Request, res: express.Response) => {
    res.json(serverToolsCache);
});

// Create a new server-side tool or update an existing one (upsert).
app.post('/api/tools/create', async (req: express.Request, res: express.Response) => {
    try {
        const payload: NewToolPayload = req.body;
        if (!payload.name || !payload.description || !payload.category || !payload.implementationCode) {
            return res.status(400).json({ error: 'Missing required tool properties.' });
        }
        if (payload.category !== 'Server') {
            return res.status(400).json({ error: "Tools created on the server must have the category 'Server'." });
        }
        
        const currentTools = [...serverToolsCache];
        const existingToolIndex = currentTools.findIndex(t => t.name === payload.name);

        if (existingToolIndex !== -1) {
            // --- UPDATE EXISTING TOOL ---
            const existingTool = currentTools[existingToolIndex];
            const updatedTool = {
                ...existingTool,
                ...payload, // Overwrite with new data from the payload
                version: existingTool.version + 1, // Increment version on update
                updatedAt: new Date().toISOString(),
            };
            currentTools[existingToolIndex] = updatedTool;
            await writeTools(currentTools);
            serverToolsCache = currentTools; // Update the live cache

            console.log(`[INFO] Tool '${payload.name}' updated to version ${updatedTool.version}.`);
            return res.status(200).json({ message: `Server tool '${payload.name}' updated successfully.`, tool: updatedTool });
        } else {
            // --- CREATE NEW TOOL ---
            const newTool: LLMTool = {
                ...payload,
                id: generateMachineReadableId(payload.name, currentTools),
                version: 1,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
            };
            currentTools.push(newTool);
            await writeTools(currentTools);
            serverToolsCache = currentTools; // Update the live cache
            
            console.log(`[INFO] New tool '${newTool.name}' created and loaded into memory.`);
            return res.status(201).json({ message: 'Server tool created successfully', tool: newTool });
        }
    } catch (error) {
        console.error('Error creating/updating tool:', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});


// --- Local AI Server Logic ---
const startLocalAiServer = async () => {
    if (gemmaProcess) {
        throw new Error('Local AI server is already running.');
    }
    const scriptPath = path.join(SCRIPTS_DIR, 'gemma_server.py');
    try {
        await fs.access(scriptPath);
    } catch (error) {
        const message = 'Cannot start server: gemma_server.py does not exist. It must be created by an agent first.';
        addLog(`[ERROR] ${message}`);
        console.error(`[STARTUP_FAIL] Attempted to start local AI, but script was not found at ${scriptPath}`);
        throw new Error(message);
    }
    
    const pythonExecutable = path.join(__dirname, '..', 'venv', 'bin', 'python');
    addLog('Starting local AI server...');
    gemmaProcess = spawn(pythonExecutable, [scriptPath]);
    
    gemmaProcess.stdout?.on('data', (data) => addLog(data.toString().trim()));
    gemmaProcess.stderr?.on('data', (data) => addLog(data.toString().trim()));
    gemmaProcess.on('close', (code) => {
        addLog(`Server process exited with code ${code}.`);
        gemmaProcess = null;
    });
    gemmaProcess.on('error', (err) => {
        addLog(`[FATAL] Failed to start server process: ${err.message}`);
        gemmaProcess = null;
    });
    return { message: 'Local AI server process started.' };
};

const stopLocalAiServer = () => {
     if (!gemmaProcess || !gemmaProcess.pid) {
        throw new Error('Local AI server is not running.');
    }
    addLog('Stopping local AI server...');
    gemmaProcess.kill('SIGTERM');
    gemmaProcess = null;
    return { message: 'Local AI server stop signal sent.' };
};

const getLocalAiServerStatus = () => {
    return {
        isRunning: gemmaProcess !== null && gemmaProcess.pid !== undefined,
        pid: gemmaProcess?.pid,
        logs: gemmaLogs,
    };
};


// Execute a server-side tool or a special command
app.post('/api/execute', async (req: express.Request, res: express.Response) => {
    const { name, arguments: args }: AIToolCall = req.body;
    if (!name) return res.status(400).json({ error: 'Tool name is required.' });

    // Handle special, built-in server commands
    if (name === 'System_Reload_Tools') {
        console.log('[COMMAND] Received System_Reload_Tools command. Re-reading tools.json...');
        await readToolsAndLoadCache();
        return res.json({ success: true, message: `Successfully reloaded ${serverToolsCache.length} tools from disk.` });
    }
    if (name === 'System_Reset_Server_Tools') {
        console.log('[COMMAND] Received System_Reset_Server_Tools command. Deleting all custom tools...');
        try {
            if (kicadServiceProcess) {
                console.log('[COMMAND] Stopping KiCad service as part of reset...');
                kicadServiceProcess.kill('SIGTERM');
                kicadServiceProcess = null;
            }
            await writeTools([]); // Write an empty array to the file
            serverToolsCache = []; // Clear the in-memory cache
            return res.json({ success: true, message: 'Successfully deleted all custom server-side tools and stopped services.' });
        } catch (error) {
            const err = error as Error;
            console.error('Error resetting server tools:', err.message);
            return res.status(500).json({ error: 'Failed to reset server tools on disk.' });
        }
    }
    
    // --- KiCad Service Management ---
    if (name === 'Start KiCad Service') {
        const result = await startKicadService();
        if (!result.success) {
            return res.status(500).json({ error: result.error });
        }
        return res.json({ success: true, message: result.message });
    }
    if (name === 'Stop KiCad Service') {
        if (!kicadServiceProcess) {
             // Check if it's running but unmanaged
            if (await isKicadServiceHealthy()) {
                return res.status(400).json({ error: 'KiCad Service is running but not managed by this server process. It cannot be stopped from here.' });
            }
            return res.status(400).json({ error: 'KiCad Service is not running.' });
        }
        kicadServiceProcess.kill('SIGTERM');
        kicadServiceProcess = null;
        return res.json({ success: true, message: 'KiCad Service stopped.' });
    }

    const toolToExecute = serverToolsCache.find(t => t.name === name);
    if (!toolToExecute) return res.status(404).json({ error: `Server-side tool '${name}' not found in the live registry.` });
    
    // --- KiCad Command Proxying ---
    const PROXY_PREFIX = 'kicad_service_proxy::';
    if (toolToExecute.implementationCode && String(toolToExecute.implementationCode).trim().startsWith(PROXY_PREFIX)) {
        if (!(await isKicadServiceHealthy())) {
            console.log('[INFO] KiCad service not responsive. Attempting to start it automatically...');
            const startResult = await startKicadService();
            if (!startResult.success) {
                console.error(`[ERROR] Failed to auto-start KiCad service: ${startResult.error}`);
                return res.status(500).json({ error: `Failed to automatically start the required KiCad Service: ${startResult.error}` });
            }
            console.log('[SUCCESS] KiCad service auto-started successfully.');
        }
        
        const commandName = toolToExecute.implementationCode.trim().substring(PROXY_PREFIX.length);
        if (!commandName) {
            return res.status(500).json({ error: `Could not parse command name from tool '${name}'.` });
        }

        try {
            const serviceResponse = await fetch(`http://127.0.0.1:${KICAD_SERVICE_PORT}/command/${commandName}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify(args),
                signal: AbortSignal.timeout(KICAD_SERVICE_TIMEOUT)
            });

            const result = await serviceResponse.json();

            if (!serviceResponse.ok) {
                const detail = result.detail || { error: 'Unknown error from KiCad service' };
                const errorMessage = typeof detail === 'string' ? detail : (detail.error || JSON.stringify(detail));
                return res.status(serviceResponse.status).json({ error: errorMessage });
            }
            
            // The result from the Python service is the definitive result.
            // We merge it with our standard success flag. The python result may already have a message.
            const responseToClient = { success: true, ...result };
            
            // Add a detailed log to show exactly what is being sent back to the client.
            console.log(`[PROXY SUCCESS] Sending response to client for '${commandName}':`, JSON.stringify(responseToClient));
            
            return res.json(responseToClient);

        } catch (fetchError) {
            const err = fetchError as Error;
            console.error(`Error proxying to KiCad Service:`, err);
            return res.status(502).json({ error: `Could not connect to the KiCad Service. Is it running? Details: ${err.message}` });
        }
    }

    // Handle built-in server functions identified by special implementation code
    try {
        switch (toolToExecute.implementationCode) {
            case 'start_local_ai':
                const startResult = await startLocalAiServer();
                return res.json({ success: true, ...startResult });
            case 'stop_local_ai':
                const stopResult = stopLocalAiServer();
                return res.json({ success: true, ...stopResult });
            case 'status_local_ai':
                const statusResult = getLocalAiServerStatus();
                return res.json({ success: true, message: "Status retrieved", ...statusResult });
        }
    } catch(e) {
        const errorMessage = e instanceof Error ? e.message : 'Unknown error during built-in command execution.';
        return res.status(500).json({ error: errorMessage });
    }
    
    // Handle user-defined shell commands
    let command = toolToExecute.implementationCode;
    if (args) {
        for (const key in args) {
            let value = args[key];
            // If the value is an object or array, stringify it as JSON.
            if (typeof value === 'object' && value !== null) {
                value = JSON.stringify(value);
            }
            // Escape single quotes for shell safety: ' -> '\''
            const escapedValue = String(value).replace(/'/g, "'\\''");
            command += ` --${key} '${escapedValue}'`;
        }
    }

    // Use the python from the virtual environment for reliability
    if (command.startsWith('python ')) {
        command = path.join('venv', 'bin', 'python') + command.substring('python'.length);
    }

    exec(command, { timeout: 300000, cwd: __dirname }, (error, stdout, stderr) => { // 5 minute timeout
        if (error) {
            console.error(`Exec error for tool '${name}':`, { command, error: error.message, stdout, stderr });

            // Prioritize the script's controlled JSON output from stdout as the error source.
            let detailedError = `Tool execution failed: ${error.message}`;
            if (stdout && stdout.trim()) {
                try {
                    const parsedStdout = JSON.parse(stdout);
                    if (parsedStdout.error) {
                        detailedError = parsedStdout.error; // Use the specific error from the script
                    } else {
                        detailedError = stdout.trim(); // Fallback to raw stdout
                    }
                } catch (e) {
                    // If stdout isn't valid JSON, use it as a raw string.
                    detailedError = stdout.trim();
                }
            } else if (stderr && stderr.trim()) {
                // Fallback to stderr if stdout is empty
                detailedError = stderr.trim();
            }
            
            return res.status(500).json({ error: detailedError, stdout, stderr });
        }
        res.json({ success: true, message: `Tool '${name}' executed successfully.`, stdout, stderr });
    });
});

// Create/write a file on the server
app.post('/api/files/write', async (req: express.Request, res: express.Response) => {
    try {
        const { filePath, content } = req.body;
        if (!filePath || typeof content !== 'string') {
            return res.status(400).json({ error: "Missing 'filePath' or 'content'." });
        }
        // Security: Ensure the path is clean and does not traverse up directories
        const safeFileName = path.normalize(filePath).replace(/^(\.\.(\/|\\|$))+/, '');
        if (safeFileName.includes('..')) {
           return res.status(400).json({ error: "Invalid file path (directory traversal detected)." });
        }
        const fullPath = path.join(SCRIPTS_DIR, safeFileName);
        
        // Security: double-check it's still within the intended directory
        if (!fullPath.startsWith(SCRIPTS_DIR)) {
            return res.status(400).json({ error: "Invalid file path (resolved outside scripts directory)." });
        }

        await fs.writeFile(fullPath, content);
        res.status(201).json({ success: true, message: `File '${safeFileName}' written successfully.` });
    } catch (error) {
        console.error('Error writing file:', error);
        res.status(500).json({ error: 'Internal Server Error while writing file.' });
    }
});

// --- Server Start ---
app.listen(PORT, async () => {
    console.log(`Singularity Agent Factory Backend Server listening on http://localhost:${PORT}`);
    console.log('This server allows the AI to execute local commands and write files.');
    
    // Ensure directories exist before any operations that might need them
    await fs.mkdir(SCRIPTS_DIR, { recursive: true });
    await fs.mkdir(ASSETS_DIR, { recursive: true });
    
    await readToolsAndLoadCache(); // Initial load of tools into memory
    console.warn('SECURITY WARNING: This server can execute arbitrary code. Do not expose it to the internet.');
});