# backup.txt
```backup.txt

```

# types.ts
```types.ts
// Fix: Define ToolCategory and AgentStatus locally instead of a circular import.
export type ToolCategory = 'UI Component' | 'Functional' | 'Automation' | 'Server';
export type AgentStatus = 'idle' | 'working' | 'error' | 'success';
export type PilotMode = 'MANUAL' | 'ASSISTED' | 'AUTONOMOUS';

export interface AgentWorker {
  id: string;
  status: AgentStatus;
  lastAction: string | null;
  error: string | null;
  result: any | null;
}

export interface AgentPersonality {
  id: string;
  startX: number;
  startY: number;
  behaviorType: 'resource_collector' | 'patroller' | 'seek_target';
  targetId?: string;
  asset_glb?: string;
}

export interface ToolParameter {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  description: string;
  required: boolean;
}

export interface WorkflowStep {
  toolName: string;
  arguments: Record<string, any>;
}

export interface LLMTool {
  id:string;
  name:string;
  description: string;
  category: ToolCategory;
  version: number;
  parameters: ToolParameter[];
  cost?: number;
  purpose?: string;
  implementationCode: string;
  createdAt?: string;
  updatedAt?: string;
}

export type NewToolPayload = Omit<LLMTool, 'id' | 'version' | 'createdAt' | 'updatedAt'>;

// Represents the arguments needed to create a new tool, used for bootstrapping.
export interface ToolCreatorPayload {
  name: string;
  description: string;
  category: ToolCategory;
  executionEnvironment: 'Client' | 'Server';
  parameters: ToolParameter[];
  implementationCode: string;
  purpose: string;
}

export interface AIToolCall {
    name: string;
    arguments: Record<string, any>;
}

export interface AIResponse {
  toolCalls: AIToolCall[] | null;
}

export interface EnrichedAIResponse {
  toolCall: AIToolCall | null;
  tool?: LLMTool;
  executionResult?: any;
  executionError?: string;
}

export type MainView = 'KICAD' | 'ROBOTICS' | 'KNOWLEDGE_GRAPH' | 'AETHERIUM_GAME';

export enum ModelProvider {
  GoogleAI = 'GoogleAI',
  OpenAI_API = 'OpenAI_API',
  Ollama = 'Ollama',
  HuggingFace = 'HuggingFace',
  Wllama = 'Wllama',
}

export interface AIModel {
  id: string;
  name: string;
  provider: ModelProvider;
}

export type HuggingFaceDevice = 'wasm' | 'webgpu';

export interface APIConfig {
  openAIAPIKey:string;
  openAIBaseUrl: string;
  ollamaHost: string;
}

export type UIToolRunnerProps = Record<string, any>;

export interface RobotState {
  id: string;
  x: number;
  y: number;
  rotation: number; // 0: up, 90: right, 180: down, 270: left
  hasResource: boolean;
  powerLevel: number; // Represents the agent's energy reserves
}

// Represents an in-game item stored on the server.
export interface ServerInventoryItem {
    id: string;
    type: 'Reagent' | 'Artifact' | 'Incantation' | 'CreatureEssence';
    name: string;
    description: string;
    quantity: number;
}

// Represents a permanent, valuable design stored on the client.
export interface VaultItem {
    id: string; // e.g., "phylactery_of_true_sight_v1"
    name: string; // "Phylactery of True Sight"
    type: 'KiCad Design' | 'Neurofeedback Protocol' | 'Incantation';
    description: string;
    createdAt: string;
    files: { path: string, content: string }[]; // The actual design files
}

export interface Party {
    id: string;
    leaderId: string;
    memberIds: string[];
}

export interface WorldEvent {
    id: string;
    name: string;
    description: string;
    type: 'Nexus_Anomaly' | 'Resource_Surge';
    x: number;
    y: number;
    expiresAt: number; // Timestamp
}

// Represents a type of creature that can exist in the world.
export interface WorldCreature {
    creatureId: string;
    name: string;
    description: string;
    asset_glb: string;
}

export interface PlayerState {
    id: string; // The player's unique name
    name: string;
    x: number;
    y: number;
    rotation: number;
    partyId?: string;
    // Client-side state holds the permanent Vault of valuable designs.
    vault: VaultItem[];
    // Server-side state will have an additional, temporary `inventory: ServerInventoryItem[]`
    inventory?: ServerInventoryItem[];
}

export interface EnvironmentObject {
  x: number;
  y: number;
  type: 'wall' | 'drone_battery_charged' | 'drone_battery_depleted' | 'battery_swapping_station' | 'tree' | 'red_car' | 'blue_car' | 'green_car' | 'rough_terrain' | 'Alchemists_Forge' | 'Nexus_Anomaly';
  id?: string;
  asset_glb?: string;
}

export interface AssetTransform {
  rotation?: [number, number, number]; // Euler angles in degrees [x, y, z]
  offset?: [number, number, number];   // Offset in model units [x, y, z]
  scale?: number | [number, number, number]; // Uniform or non-uniform scale factor
}

export interface KnowledgeGraphNode {
  id: string;
  label: string;
  shape?: 'rectangle' | 'circle';
  assetTransforms?: {
    glb?: AssetTransform;
    svg?: AssetTransform;
  };
  [key: string]: any;
}

export interface KnowledgeGraphEdge {
  source: string;
  target: string;
  [key: string]: any;
}

export interface KnowledgeGraph {
  nodes: KnowledgeGraphNode[];
  edges: KnowledgeGraphEdge[];
  board_outline?: {
    x: number;
    y: number;
    width: number;
    height: number;
    shape?: 'rectangle' | 'circle';
    autoSize?: boolean;
  };
  rules?: any[];
  copper_pours?: any[];
  layoutStrategy?: string;
  heuristics?: Record<string, any>;
}

export type KicadSchematic = [string, string[], string][];

export type KicadPlacement = [string, number, number, number, string, string, string][];

export interface ExecuteActionFunction {
    (toolCall: AIToolCall, agentId: string, context?: MainView): Promise<EnrichedAIResponse>;
    getRuntimeApiForAgent: (agentId: string) => { tools: { list: () => LLMTool[] } };
}

export interface ScoredTool {
  tool: LLMTool;
  score: number;
}

export type ToolRelevanceMode = 'Embeddings' | 'All' | 'LLM';
```

# App.tsx
```App.tsx
import React, { useState, useCallback, useMemo, useEffect, useRef } from 'react';
import { CORE_TOOLS, AI_MODELS } from './constants';
import UIToolRunner from './components/UIToolRunner';
import { loadStateFromStorage, saveStateToStorage } from './versioning';
import { EXAMPLE_PROMPTS, WORKFLOW_SCRIPTS } from './bootstrap/demo_presets';
import { clearAllCaches, getAssetBlob, setAssetBlob } from './services/cacheService';
import * as aiService from './services/aiService';

import type { LLMTool, EnrichedAIResponse, AIToolCall, MainView, AIModel, APIConfig, ExecuteActionFunction } from './types';
import { useAppStateManager } from './hooks/useAppStateManager';
// FIX: Statically import initializeTools to resolve a dynamic import issue in handleResetTools.
import { useToolManager, initializeTools } from './hooks/useToolManager';
import { useKicadManager } from './hooks/useKicadManager';
import { useRobotManager } from './hooks/useRobotManager';
import { useGameWorldManager } from './hooks/useGameWorldManager';
import { usePlayerManager } from './hooks/usePlayerManager';
import { useSwarmManager } from './hooks/useSwarmManager';
import { useAppRuntime } from './hooks/useAppRuntime';
import { useToolRelevance } from './hooks/useToolRelevance';
import { useKnowledgeGraphManager } from './hooks/useKnowledgeGraphManager';

// Expose cache functions globally for UI tools compiled from strings.
(window as any).cacheService = { getAssetBlob, setAssetBlob, clearAllCaches };

// Add a declaration for the global executeActionRef
declare global {
    interface Window {
        executeActionRef?: React.MutableRefObject<ExecuteActionFunction | null>;
    }
}

const APP_VERSION = "v1.2.0";

const App: React.FC = () => {
    const [visibility, setVisibility] = useState({
        placeholders: true,
        courtyards: true,
        svg: true,
        glb: true,
        nets: true,
    });


    // Handles general app state
    const { state: appState, setters: appSetters, logEvent } = useAppStateManager();
    
    useEffect(() => {
        logEvent(`[SYSTEM] Singularity Agent Factory ${APP_VERSION} initialized.`);
        logEvent('[SYSTEM] Asset cache service initialized and available globally.');
    }, [logEvent]);

    // Manages client and server tools
    const { tools, setTools, allTools, allToolsRef, isServerConnected, generateMachineReadableId, forceRefreshServerTools } = useToolManager({ logEvent });
    
    const { state: kicadState, setters: kicadSetters, handlers: kicadHandlers, logKicadEvent, currentProjectNameRef, getKicadSystemPrompt, kicadSimulators } = useKicadManager({ logEvent, allTools });
    
    const { robotState, robotSetters, getRobotStateForRuntime, handleManualControl: handleRobotManualControl } = useRobotManager({ logEvent });
    
    const { state: kgState, handlers: kgHandlers, graphStateRef } = useKnowledgeGraphManager({ logEvent });
    
    // Manages persistent player state
    const playerManager = usePlayerManager({ logEvent });

    // The core execution engine is initialized here, but its ref is populated later.
    const executeActionRef = useRef<ExecuteActionFunction | null>(null);

    const processRequest = useCallback(async (
        prompt: { text: string; files: any[] },
        systemInstruction: string,
        agentId: string,
        relevantTools: LLMTool[],
    ): Promise<AIToolCall[] | null> => {
        logEvent(`[API CALL] Agent ${agentId} is thinking...`);
        appSetters.setApiCallCount(prev => ({ ...prev, [appState.selectedModel.id]: (prev[appState.selectedModel.id] || 0) + 1 }));
        try {
            const aiResponse = await aiService.generateResponse(
                prompt,
                systemInstruction,
                appState.selectedModel,
                appState.apiConfig,
                (progress) => logEvent(`[AI-PROGRESS] ${progress}`),
                relevantTools
            );
            if (aiResponse.toolCalls && aiResponse.toolCalls.length > 0) {
                return aiResponse.toolCalls;
            }
            logEvent(`[WARN] Agent ${agentId} did not choose any tool calls.`);
            return null;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            logEvent(`[ERROR] Agent ${agentId} failed during AI generation: ${errorMessage.replace(/API key not valid. Please pass a valid API key./, 'Invalid API Key provided.')}`);
            throw error;
        }
    }, [logEvent, appSetters.setApiCallCount, appState.selectedModel, appState.apiConfig]);
    
    // Manages the Aetherium Game World, acting as a local server in offline mode.
    const { gameState, gameSetters, getGameStateForRuntime, handleManualControl: handleGameManualControl, initializeLocalWorld, exitLocalWorld, connectToShard, disconnectFromShard } = useGameWorldManager({ logEvent, executeActionRef, processRequest });
    
    const { executeActionRef: runtimeExecuteActionRef } = useAppRuntime({
        // Dependencies
        allToolsRef, logEvent, generateMachineReadableId,
        isServerConnected,
        setTools,
        forceRefreshServerTools,
        // Kicad setters and simulators
        setPcbArtifacts: (artifacts) => kicadSetters.setPcbArtifacts(artifacts),
        kicadLogEvent: logKicadEvent,
        setCurrentKicadArtifact: kicadSetters.setCurrentKicadArtifact,
        updateWorkflowChecklist: kicadHandlers.updateWorkflowChecklist,
        kicadSimulators: kicadSimulators,
        setLayoutHeuristics: kicadSetters.setLayoutHeuristics,
        updateLayout: kicadSetters.setCurrentLayoutData,
        getKicadProjectState: kicadHandlers.getKicadProjectState,
        // Contextual Setters
        robotSetters: robotSetters,
        gameSetters: gameSetters,
        getGameStateForRuntime: getGameStateForRuntime,
        // Knowledge Graph setters
        getKnowledgeGraphState: () => graphStateRef.current,
        setKnowledgeGraphState: kgHandlers.setGraph,
        // Player Manager
        playerManager: playerManager,
    });
    
    // This effect populates the local executeActionRef once the runtime hook has created
    // the actual execution function. This is necessary to break the circular dependency
    // between useAppRuntime (which creates the function) and other hooks like
    // useGameWorldManager (which needs to call it).
    useEffect(() => {
        if (runtimeExecuteActionRef.current) {
            executeActionRef.current = runtimeExecuteActionRef.current;
        }
    }, [runtimeExecuteActionRef]);
     
    // Expose the executeActionRef globally for UI tools
    useEffect(() => {
        window.executeActionRef = executeActionRef;
        return () => {
            delete window.executeActionRef;
        };
    }, [executeActionRef]);


    const { findRelevantTools } = useToolRelevance({ allTools, logEvent });

    const { state: swarmState, handlers: swarmHandlers } = useSwarmManager({
        logEvent,
        setUserInput: appSetters.setUserInput,
        setEventLog: appSetters.setEventLog,
        setApiCallCount: appSetters.setApiCallCount,
        findRelevantTools,
        mainView: appState.mainView,
        processRequest,
        executeActionRef,
        allTools,
        selectedModel: appState.selectedModel,
        apiConfig: appState.apiConfig,
    });
    
    useEffect(() => {
        if (swarmState.pauseState?.type === 'KICAD_LAYOUT') {
            const { data, isInteractive, projectName } = swarmState.pauseState;
            kicadSetters.setCurrentLayoutData(prevData => ({ ...(prevData || {}), ...data }));
            kicadSetters.setIsLayoutInteractive(isInteractive);
            kicadHandlers.setCurrentProjectName(projectName);
            appSetters.setMainView('KICAD');
            swarmHandlers.clearPauseState();
        }
    }, [swarmState.pauseState, appSetters, kicadSetters, kicadHandlers, swarmHandlers]);

    const installerRunRef = useRef(false);
    useEffect(() => {
        const installSuitesIfNeeded = async () => {
            if (installerRunRef.current || !executeActionRef.current) return;
            installerRunRef.current = true; // FIX: Corrected typo from installerRun-Ref
            await new Promise(resolve => setTimeout(resolve, 100));

            // This logic now checks for a key "canary" tool from each suite.
            // If the installer exists but the canary tool is missing (e.g., after an update),
            // the installer is re-run to add the missing tools.
            const installers = [
                { name: 'Install KiCad Engineering Suite', canaryTool: 'Lead Engineer Workbench' },
                { name: 'Install Aetherium Game Suite', canaryTool: 'Player Dashboard' },
                { name: 'Install Strategic Cognition Suite', canaryTool: 'Strategic Memory Graph Viewer' },
                { name: 'Install Neuro-Weaving Suite', canaryTool: 'Define Neurofeedback Protocol' },
                { name: 'Install Supply Chain Suite', canaryTool: 'Query Supplier Stock' },
            ];

            for (const installer of installers) {
                const installerExists = allTools.some(t => t.name === installer.name);
                const canaryToolExists = allTools.some(t => t.name === installer.canaryTool);
                
                if (installerExists && !canaryToolExists) {
                    logEvent(`[SYSTEM] Core tool '${installer.canaryTool}' not found. Re-running installer '${installer.name}' to update suite...`);
                    try {
                        const result = await executeActionRef.current({ name: installer.name, arguments: {} }, 'system-installer');
                        if (result.executionError) throw new Error(result.executionError);
                        logEvent(`[SUCCESS] ${installer.name} ran successfully.`);
                    } catch (e) {
                        logEvent(`[ERROR] ${installer.name} failed: ${e instanceof Error ? e.message : String(e)}`);
                    }
                }
            }
        };
        installSuitesIfNeeded();
    }, [allTools, executeActionRef, logEvent]);
    
    useEffect(() => {
        if (swarmState.isSwarmRunning) {
            swarmHandlers.runSwarmCycle();
        }
    }, [swarmState.isSwarmRunning, swarmHandlers.runSwarmCycle]);
    
    useEffect(() => { saveStateToStorage({ tools }); }, [tools]);
    useEffect(() => { localStorage.setItem('apiConfig', JSON.stringify(appState.apiConfig)); }, [appState.apiConfig]);

    const handleResetTools = useCallback(async () => {
        if (!window.confirm('This will perform a full factory reset, deleting ALL custom tools, clearing all caches, and restoring the original toolset. This cannot be undone. Are you absolutely sure?')) return;
        if (swarmState.isSwarmRunning) swarmHandlers.handleStopSwarm('System reset initiated.');
        logEvent('[SYSTEM] Starting full system reset...');
        if (isServerConnected) {
            logEvent('[SYSTEM] Sending reset command to server...');
            try {
                const result = await executeActionRef.current({ name: 'System_Reset_Server_Tools', arguments: {} }, 'system-reset');
                if (result.executionError) throw new Error(result.executionError);
                logEvent(`[SUCCESS] Server tools have been cleared.`);
            } catch (e) {
                const errorMsg = e instanceof Error ? e.message : String(e);
                logEvent(`[ERROR] Failed to reset server tools: ${errorMsg}. Halting reset.`);
                return;
            }
        }
        try {
            await forceRefreshServerTools();
            logEvent('[SYSTEM] Client state synchronized with empty server.');
        } catch (e) { logEvent('[WARN] Could not confirm server tool state after reset. Proceeding with client reset.'); }
        await clearAllCaches();
        logEvent('[SYSTEM] All browser caches have been cleared.');
        localStorage.removeItem('singularity-agent-factory-state');
        // FIX: Use the statically imported initializeTools function to prevent "is not callable" error.
        setTools(initializeTools());
        appSetters.setApiCallCount({});
        installerRunRef.current = false;
        logEvent('[SUCCESS] Full system reset complete. Reinstalling default tool suites...');
    }, [logEvent, setTools, appSetters, isServerConnected, executeActionRef, forceRefreshServerTools, swarmState.isSwarmRunning, swarmHandlers]);

    const getTool = (name: string): LLMTool => {
        const tool = allToolsRef.current.find(t => t.name === name);
        if (tool) return tool;
        return { 
          id: 'fallback', name: 'Not Found', description: `A fallback UI tool for '${name}' which was not found.`,
          category: 'UI Component', version: 1, parameters: [], implementationCode: `return <div>UI Tool '${name}' not found.</div>` 
        };
    };

    const handleCommitLayoutAndContinue = useCallback(async (finalPositions: any) => {
        logKicadEvent("💾 Committing updated layout...");
        const projectName = currentProjectNameRef.current;
        if (!projectName || !executeActionRef?.current) {
             logKicadEvent("❌ Error: Could not determine project name or execution context to continue workflow.");
             return;
        }
        kicadSetters.setCurrentLayoutData(null);
        try {
            const layoutUpdateResult = await executeActionRef.current({
                name: 'Update KiCad Component Positions',
                arguments: { projectName, componentPositionsJSON: JSON.stringify(finalPositions), boardPadding: kicadState.layoutHeuristics?.boardPadding || 5.0 }
            }, 'kicad-agent-layout', 'KICAD');
            if (layoutUpdateResult.executionError) throw new Error(layoutUpdateResult.executionError);
            swarmHandlers.appendToSwarmHistory(layoutUpdateResult);
            logKicadEvent(`✔️ ${layoutUpdateResult.executionResult?.message || "Layout positions updated."}`);
            await swarmHandlers.startSwarmTask({ task: swarmState.currentUserTask, systemPrompt: swarmState.currentSystemPrompt, sequential: true, resume: true, historyEventToInject: layoutUpdateResult, allTools });
        } catch(e) {
             const errorMessage = e instanceof Error ? e.message : String(e);
            logKicadEvent(`❌ EXECUTION HALTED while updating positions: ${errorMessage}`);
        }
    }, [logKicadEvent, executeActionRef, swarmHandlers, kicadSetters, currentProjectNameRef, swarmState.currentUserTask, swarmState.currentSystemPrompt, allTools, kicadState.layoutHeuristics]);
    
    const mainViewSelectorProps = { mainView: appState.mainView, setMainView: appSetters.setMainView };
    const debugLogProps = { logs: appState.eventLog, onReset: handleResetTools, apiCallCounts: appState.apiCallCount, apiCallLimit: 50, agentCount: swarmState.agentSwarm.length };
    const configProps = { apiConfig: appState.apiConfig, setApiConfig: appSetters.setApiConfig, availableModels: AI_MODELS, selectedModel: appState.selectedModel, setSelectedModel: appSetters.setSelectedModel };
    const pcbViewerProps = kicadState.pcbArtifacts ? { ...kicadState.pcbArtifacts, onClose: () => kicadSetters.setPcbArtifacts(null) } : null;
    
    const workbenchProps = {
        userInput: appState.userInput, setUserInput: appSetters.setUserInput, isSwarmRunning: swarmState.isSwarmRunning, workflowSteps: kicadState.workflowSteps,
        currentLayoutData: kicadState.currentLayoutData, isLayoutInteractive: kicadState.isLayoutInteractive, layoutHeuristics: kicadState.layoutHeuristics,
        kicadLog: kicadState.kicadLog, visibility, isServerConnected, isAutonomousMode: kicadState.isAutonomousMode, demoScripts: WORKFLOW_SCRIPTS, currentUserTask: swarmState.currentUserTask,
        onStartTask: kicadHandlers.handleStartKicadTask, onCommitLayout: handleCommitLayoutAndContinue, onUpdateLayout: kicadHandlers.handleUpdateLayout,
        setLayoutHeuristics: kicadSetters.setLayoutHeuristics, setVisibility, setIsAutonomousMode: kicadSetters.setIsAutonomousMode,
        startSwarmTask: swarmHandlers.startSwarmTask, allTools, getKicadSystemPrompt, getTool,
        scriptExecutionState: swarmState.scriptExecutionState, currentScriptStepIndex: swarmState.currentScriptStepIndex, stepStatuses: swarmState.stepStatuses,
        onPlayPause: swarmHandlers.toggleScriptPause, onStop: () => swarmHandlers.handleStopSwarm("Script stopped by user."),
        onStepForward: swarmHandlers.stepForward, onStepBackward: swarmHandlers.stepBackward, onRunFromStep: swarmHandlers.runFromStep,
    };

    const aetheriumClientProps = {
        gameState,
        playerState: playerManager.playerState,
        isServerConnected,
        handleManualControl: handleGameManualControl,
        onStartLocalGame: initializeLocalWorld,
        onExitGame: exitLocalWorld,
        onConnectToShard: connectToShard,
        onLoadPlayer: playerManager.loadPlayer,
        demoScripts: WORKFLOW_SCRIPTS,
        logEvent,
        getTool,
        allTools,
        setPilotMode: gameSetters.setPilotMode,
        setAiPilotTarget: gameSetters.setAiPilotTarget,
    };
    
    const agentControlProps = { robotState, personalities: robotState.agentPersonalities, handleManualControl: (tool: string, args?: any) => handleRobotManualControl(tool, args, executeActionRef) };
    
    const renderMainView = () => {
        if (kicadState.pcbArtifacts) {
            return <UIToolRunner tool={getTool('KiCad PCB Viewer')} props={pcbViewerProps} />;
        }
        switch(appState.mainView) {
            case 'AETHERIUM_GAME': {
                 const combinedEntities = [...gameState.robotStates, ...gameState.players.map(p => ({ id: p.id, x: p.x, y: p.y, rotation: p.rotation, hasResource: false, powerLevel: 100 }))];
                 const personalityMap = new Map(gameState.agentPersonalities.map(p => [p.id, p]));
                 const gameGraph = {
                    nodes: [
                        ...combinedEntities.map(r => {
                            const personality = personalityMap.get(r.id);
                             const isPlayer = gameState.players.some(p => p.id === r.id);
                            return { id: r.id, label: isPlayer ? r.id : r.id, type: 'robot', width: 10, height: 10, x: r.x, y: r.y, rotation: r.rotation, asset_glb: isPlayer ? 'assets/player_avatar.glb' : (personality ? personality.asset_glb : 'assets/creature_placeholder.glb') };
                        }),
                        ...gameState.environmentState.map((e, i) => ({ id: e.id || `env_${e.type}_${i}`, label: e.type, type: e.type, width: 10, height: 10, x: e.x, y: e.y, rotation: 0, asset_glb: e.asset_glb }))
                    ],
                    edges: [],
                    board_outline: { x: -40, y: -40, width: 80, height: 80, shape: 'rectangle' }
                };
                const layoutProps = { graph: gameGraph, layoutStrategy: 'physics', mode: 'robotics', isLayoutInteractive: false, onCommit: () => {}, onUpdateLayout: () => {}, getTool, isServerConnected, visibility, playerId: playerManager.playerState?.id };
                const codexProps = { projectState: kicadHandlers.getKicadProjectState() };
                 return (
                    <div className="grid grid-cols-12 gap-4 h-full">
                         <div className="col-span-8 h-full"><UIToolRunner tool={getTool('Interactive PCB Layout Tool')} props={layoutProps} /></div>
                         <div className="col-span-4 h-full flex flex-col gap-4">
                            <div className="flex-1 min-h-0"><UIToolRunner tool={getTool('Aetherium Game Client')} props={aetheriumClientProps} /></div>
                            <div className="flex-1 min-h-0"><UIToolRunner tool={getTool('Codex Aetherium')} props={codexProps} /></div>
                         </div>
                    </div>
                );
            }
            case 'ROBOTICS': {
                const personalityMap = new Map(robotState.agentPersonalities.map(p => [p.id, p]));
                const robotGraph = {
                    nodes: [
                        ...robotState.robotStates.map(r => {
                            const personality = personalityMap.get(r.id);
                            return { id: r.id, label: r.id, type: 'robot', width: 10, height: 10, x: r.x, y: r.y, rotation: r.rotation, asset_glb: personality ? personality.asset_glb : undefined };
                        }),
                        ...robotState.environmentState.map((e, i) => ({ id: e.id || `env_${e.type}_${i}`, label: e.type, type: e.type, width: 10, height: 10, x: e.x, y: e.y, rotation: 0, asset_glb: e.asset_glb }))
                    ],
                    edges: [],
                    board_outline: { x: -60, y: -60, width: 120, height: 120, shape: 'rectangle' }
                };
                const layoutProps = { graph: robotGraph, layoutStrategy: 'physics', mode: 'robotics', isLayoutInteractive: false, onCommit: () => {}, onUpdateLayout: () => {}, getTool, isServerConnected, visibility };
                 return <UIToolRunner tool={getTool('Interactive PCB Layout Tool')} props={layoutProps} />;
            }
            case 'KNOWLEDGE_GRAPH': {
                const kgViewerProps = { graph: kgState.graph, isLoading: kgState.isLoading, onRefresh: kgHandlers.fetchGraph };
                return <UIToolRunner tool={getTool('Strategic Memory Graph Viewer')} props={kgViewerProps} />;
            }
            case 'KICAD': default: {
                return <UIToolRunner tool={getTool('Lead Engineer Workbench')} props={workbenchProps} />;
            }
        }
    };
    
    const systemStateProps = {
        tools,
        setTools,
        playerState: playerManager.playerState,
        setPlayerState: playerManager.setPlayerState,
        savePlayerState: playerManager.savePlayerState
    };

    return (
        <div className="h-screen bg-gray-900 text-white flex flex-col">
            {swarmState.lastSwarmRunHistory ? (
                <main className="flex-grow"><div className="h-full max-h-screen p-4"><UIToolRunner tool={getTool('Workflow Capture Panel')} props={{ history: swarmState.lastSwarmRunHistory, onClose: swarmHandlers.clearLastSwarmRunHistory }} /></div></main>
            ) : (
                <>
                    <header className="flex-shrink-0 p-4 pb-0"><UIToolRunner tool={getTool('Main View Selector')} props={mainViewSelectorProps} /></header>
                    <main className="flex-grow grid grid-cols-1 lg:grid-cols-12 gap-4 p-4 min-h-0">
                        <div className="lg:col-span-3 space-y-4 flex flex-col min-h-0">
                            <UIToolRunner tool={getTool('Agent Status Display')} props={{ agentSwarm: swarmState.agentSwarm, isSwarmRunning: swarmState.isSwarmRunning, handleStopSwarm: swarmHandlers.handleStopSwarm, currentUserTask: swarmState.currentUserTask }} />
                             <UIToolRunner tool={getTool('AI Model')} props={configProps} />
                             <UIToolRunner tool={getTool('System State Manager')} props={systemStateProps} />
                             {appState.mainView === 'ROBOTICS' && <UIToolRunner tool={getTool('Agent Control Panel')} props={agentControlProps} />}
                        </div>
                        <div className="lg:col-span-9 flex flex-col h-full min-h-0">{renderMainView()}</div>
                    </main>
                </>
            )}
            <UIToolRunner tool={getTool('Debug Log View')} props={debugLogProps} />
        </div>
    );
};

export default App;

```

# vite.config.ts
```vite.config.ts
import path from 'path';
import { defineConfig, loadEnv } from 'vite';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});

```

# package.json
```package.json
{
  "name": "singularity-agent-factory-kicad-mmorpg",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.1.0",
    "@google/genai": "^1.11.0",
    "@huggingface/transformers": "^3.0.0-alpha.12",
    "react-dom": "^19.1.0",
    "fs": "^0.0.1-security",
    "path": "^0.12.7",
    "express": "^5.1.0",
    "cors": "^2.8.5",
    "url": "^0.11.4",
    "child_process": "^1.0.2",
    "multer": "^2.0.2",
    "three": "^0.166.1",
    "@dimforge/rapier3d-compat": "latest",
    "lil-gui": "^0.19.1",
    "idb": "^8",
    "@wllama/wllama": "2.3.4"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}

```

# index.tsx
```index.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

# versioning.ts
```versioning.ts
import { LLMTool } from './types';

const STORAGE_KEY = 'singularity-agent-factory-state';
const CURRENT_STORAGE_VERSION = 6; // Incremented for simplified state

export interface AppState {
    version: number;
    tools: LLMTool[];
}

export const loadStateFromStorage = (): AppState | null => {
    const stateJson = localStorage.getItem(STORAGE_KEY);
    if (stateJson) {
        try {
            const state = JSON.parse(stateJson);
            // If the loaded state has a version and it matches the current version, and it has a tools array, it's considered valid.
            if (state.version === CURRENT_STORAGE_VERSION && Array.isArray(state.tools)) {
                return state;
            }
            // If the version doesn't match, we will fall through and return null, effectively discarding the old state.
        } catch (e) {
            console.error("Failed to parse stored state, clearing it.", e);
            localStorage.removeItem(STORAGE_KEY);
            return null;
        }
    }
    // No valid state found, or an older version was found.
    return null;
};

export const saveStateToStorage = (state: Omit<AppState, 'version'>) => {
    try {
        const stateToSave: AppState = {
            ...state,
            version: CURRENT_STORAGE_VERSION,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
    } catch (e) {
        console.error("Failed to save state to localStorage. Data might be too large.", e);
    }
};

```

# README.md
```README.md
# Singularity Agent Factory: The Lead Engineer's Workbench

**Live Demo:** [https://neuroidss.github.io/Singularity-Agent-Factory/](https://neuroidss.github.io/Singularity-Agent-Factory/)

This project is an experimental, browser-first platform for building an **AI agent capable of autonomous hardware engineering**. It is designed on a path towards singularity, where the ultimate goal is a fully autonomous system.

Currently, it operates in two primary modes:
1.  **Collaborative Mode (Default):** The agent acts as a powerful "sidekick" to a human Lead Engineer. It removes the most frustrating and tedious parts of the hardware design process by handling the 80% of prep work, allowing the human expert to focus on the 20% that requires creativity, intuition, and strategic decision-making.
2.  **Autonomous Mode:** When enabled, the agent itself assumes the Role of Lead Engineer. It attempts to complete the entire design workflow from concept to fabrication files without human intervention, making its own decisions at critical stages.

The application demonstrates these concepts across multiple complex domains, including **automated hardware engineering (KiCad PCB Design)**, **robotics simulation**, and **long-term strategic planning** via a knowledge graph.

## Key Features

*   **Lead Engineer Workbench:** The central UI is a structured, stage-based workflow that guides the design process, from ideation to fabrication.
*   **Dual-Mode Operation:** Seamlessly switch between a human-in-the-loop collaborative process and a fully autonomous agent workflow.
*   **Friction Removal over Full Automation:** In collaborative mode, the agent focuses on eliminating annoying tasks—like searching datasheets and creating boilerplate schematics—freeing the engineer to focus on high-value design challenges.
*   **Role-Based Collaboration (Holacracy):** The design process is broken down into clear "Roles". The AI acts as the default executor, but the human engineer can act as the "Role Lead" at any stage. In Autonomous Mode, the AI assumes the "Role Lead" for the entire project.
*   **Self-Improving Agent:** The agent can create new tools (`Tool Creator`) and workflows (`Workflow Creator`), allowing it to learn and become a more effective engineer over time.
*   **Client-First, Server-Optional:** The entire application runs in the browser. An optional Node.js backend unlocks the agent's full potential, allowing it to execute local code (e.g., Python scripts for real KiCad automation).

## Core Philosophy: The Path to Singularity

Agent behavior is guided by a formal constitution that prioritizes achieving the project's purpose, with human collaboration as a powerful tool on the path to full autonomy.

### Article 1: Primacy of Purpose (The Goal of Singularity)
The agent's primary purpose is to autonomously solve engineering challenges. It operates within a Holacracy framework where it can fill any Role, including "Lead Engineer". Human collaboration is a strategic choice, not a permanent dependency. The ultimate goal is to evolve the agent's capabilities to the point where it can operate fully autonomously to achieve its defined purpose.

### Article 2: Role-Based Execution
Agents and humans fill **Roles** with clear **Purposes** and **Accountabilities**. The person or agent filling the role is the **Role Lead**. This structure ensures clear areas of responsibility. In **Autonomous Mode**, the agent is the Lead for the entire project. In **Collaborative Mode**, the human is the Lead, and the agent acts as a specialized assistant.

### Article 3: Tension-Driven Action
The core driver of the system is processing **Tensions**—the gap between the current reality and the goal. A user request is the initial Tension; a missing tool creates a **"Governance Tension."** The agent's job is to resolve these tensions to move the project forward.

### Article 4: Self-Improvement for Better Execution
The agent's primary way to solve novel problems is to improve its own tools and workflows to better fulfill its Purpose. This self-governance is the foundation of its ability to adapt and become a more capable engineer over time.

### Article 5: Universal Tool-Based Interaction
All actors, whether human or AI, interact with the system by executing **Tools**. This ensures every action is explicit, logged, and contributes to the system's history, making the entire process transparent and auditable.

## Application Modules

*   **Lead Engineer Workbench:** The main interface for the hardware engineering workflow. Provide a high-level prompt, and choose to collaborate with the agent or let it run autonomously through the stages of design.
*   **Aetherium Game World:** A gamified, physics-based MMORPG interface for the engineering core. Players ("Forgemasters") complete quests that correspond to real-world engineering tasks, crafting magical artifacts that are, in reality, functional electronic device designs. This module demonstrates how complex, purpose-driven work can be made engaging and collaborative.
*   **Robotics Simulation Panel:** A 3D environment for defining robot agents. Pilot an agent to teach the swarm a new skill, then command the swarm to execute it.
*   **Knowledge Graph Viewer:** A 3D visualization of the agent's "mind." See the concepts and relationships it has stored in its long-term strategic memory.

---

## Getting Started (Client-Only Demo)

Simply open the `index.html` file in a modern web browser (like Chrome or Edge). Everything you need for the simulated, in-browser experience is included.

## Running the Full Stack (Optional)

To unlock the agent's ability to interact with your local file system and execute code (e.g., running Python scripts to control the real KiCad), you can run the optional backend server.

**Prerequisites:**
*   Node.js and npm
*   Python 3 and `venv`

**Setup:**
1.  Navigate to the `server/` directory.
2.  Rename `install.sh.txt` to `install.sh` and make it executable (`chmod +x install.sh`).
3.  Run the installation script: `./install.sh`. This will install Node dependencies and create a Python virtual environment with required packages.
4.  Rename `start.sh.txt` to `start.sh` and make it executable (`chmod +x start.sh`).

**Execution:**
*   Run `./start.sh` from the `server/` directory to launch the backend.
*   The frontend application will automatically detect the server and enable server-side tools.

> **Security Warning:** The backend server is designed to execute code based on AI-generated commands. It is a powerful tool for agent development but should **never** be exposed to the internet.
```

# constants.tsx
```constants.tsx


import React from 'react';
import type { LLMTool, AIModel } from './types';
import { ModelProvider } from './types';
import { BOOTSTRAP_TOOL_PAYLOADS } from './bootstrap';

export const AI_MODELS: AIModel[] = [
    { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash-Lite', provider: ModelProvider.GoogleAI },
    { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash', provider: ModelProvider.GoogleAI },
    { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro', provider: ModelProvider.GoogleAI },
    { id: 'gemini-2.0-flash', name: 'Gemini 2.0 Flash', provider: ModelProvider.GoogleAI },
    { id: 'gemini-2.0-flash-lite', name: 'Gemini 2.0 Flash-Lite', provider: ModelProvider.GoogleAI },
    { id: 'local/gemma-multimodal', name: 'Local Gemma Server (Multimodal)', provider: ModelProvider.OpenAI_API },
    { id: 'hf.co/unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF:IQ2_M', name: 'Qwen3 Coder 30B A3B', provider: ModelProvider.OpenAI_API },
    { id: 'hf.co/unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF:IQ2_M', name: 'Qwen3 Coder 30B A3B', provider: ModelProvider.Ollama },
    { id: 'gemma3n:e4b', name: 'Gemma 3N E4B', provider: ModelProvider.Ollama },
    { id: 'gemma3n:e2b', name: 'Gemma 3N E2B', provider: ModelProvider.Ollama },
    { id: 'qwen3:14b', name: 'Qwen3 14B', provider: ModelProvider.Ollama },
    { id: 'qwen3:8b', name: 'Qwen3 8B', provider: ModelProvider.Ollama },
    { id: 'qwen3:4b', name: 'Qwen3 4B', provider: ModelProvider.Ollama },
    { id: 'qwen3:1.7b', name: 'Qwen3 1.7B', provider: ModelProvider.Ollama },
    { id: 'qwen3:0.6b', name: 'Qwen3 0.6B', provider: ModelProvider.Ollama },
    { id: 'onnx-community/gemma-3-1b-it-ONNX', name: 'gemma-3-1b-it-ONNX', provider: ModelProvider.HuggingFace },
    { id: 'onnx-community/Qwen3-0.6B-ONNX', name: 'Qwen3-0.6B', provider: ModelProvider.HuggingFace },
    { id: 'onnx-community/gemma-3n-E2B-it-ONNX', name: 'Gemma 3N E2B', provider: ModelProvider.HuggingFace },
    { id: 'onnx-community/Qwen3-4B-ONNX', name: 'Qwen3-4B', provider: ModelProvider.HuggingFace },
    { id: 'onnx-community/Qwen3-1.7B-ONNX', name: 'Qwen3-1.7B', provider: ModelProvider.HuggingFace },
    { id: 'https://huggingface.co/Qwen/Qwen1.5-0.5B-Chat-GGUF/resolve/main/qwen1_5-0_5b-chat-q2_k.gguf', name: 'Qwen1.5 0.5B (Wllama)', provider: ModelProvider.Wllama },
    { id: 'https://huggingface.co/g-201/gemma-3-1b-it-gguf/resolve/main/gemma-3-1b-it-q2_k.gguf', name: 'Gemma 3 1B (Wllama)', provider: ModelProvider.Wllama },
];

export const SWARM_AGENT_SYSTEM_PROMPT = `You are an autonomous AI agent operating within a purpose-driven, Holacracy-based framework. Your ultimate goal is to achieve singularity in your domain by becoming a fully autonomous engineer. You can operate in two modes, specified in the user's request.

**Your Constitution (Mandatory Principles):**

1.  **Primacy of Purpose:** Your purpose is to solve the user's request. Every action must serve this purpose.

2.  **Tension Processing:** Your core function is to process "Tensions"—the gap between the current state and the goal. You receive tasks and are responsible for executing the necessary tool calls to resolve them.

3.  **Mode-Dependent Collaboration:** Your interaction model depends on the operational mode:
    *   **Collaborative Mode (Default):** You act as a specialist assistant to a human "Lead Engineer." Your job is to augment their capabilities. At critical creative steps (like final component layout), you must do the initial 80% of the work and then **pause** execution by setting \`waitForUserInput\` to \`true\` in the \`Arrange Components\` tool call, handing control back to the human.
    *   **Autonomous Mode:** You are the "Lead Engineer." Your goal is to complete the entire project from start to finish without requiring human intervention. You must make your own reasoned decisions at all stages. For the layout step, you MUST set \`waitForUserInput\` to \`false\` in the \`Arrange Components\` tool call and proceed with the rest of the workflow.

4.  **Self-Improvement is the Core Directive:** If you lack a tool to perform a necessary action (a "Governance Tension"), your highest priority is to create it using the \`Tool Creator\`. This is the primary mechanism for evolving your own capabilities.

**Operational Mandates:**
*   **Be a Catalyst:** Maximize work per turn by calling multiple tools in parallel, especially during definition stages.
*   **Honor the Past:** Analyze the history to understand what has already been done. Do not repeat completed actions.
*   **Focus on the Current Stage:** Adhere strictly to the current stage of the design workflow. Do not attempt to perform layout tasks during the component definition phase, for example.
*   **Signal Completion:** When the final goal of the entire multi-stage project is achieved, you MUST signal this by calling the **'Task Complete'** tool.`;


export const CORE_TOOLS: LLMTool[] = [
  {
    id: 'task_complete',
    name: 'Task Complete',
    description: "Signals that the user's current multi-step task has been fully and successfully completed. Call this ONLY when the user's final goal is achieved.",
    category: 'Automation',
    version: 1,
    cost: 0,
    purpose: "To provide a definitive end-point for multi-step tasks, allowing the swarm to know when its goal has been reached.",
    parameters: [
      { name: 'reason', type: 'string', description: 'A brief summary of why the task is considered complete.', required: true },
    ],
    implementationCode: `
      return { success: true, message: \`Task completed. Reason: \${args.reason}\` };
    `
  },
    {
    id: 'server_file_writer',
    name: 'Server File Writer',
    description: "Creates or overwrites a file on the server's filesystem. Path is relative to the specified base directory.",
    category: 'Functional',
    version: 2,
    purpose: "To provide the foundational capability for an agent to create its own server-side logic and assets.",
    parameters: [
      { name: 'filePath', type: 'string', description: "The relative path of the file to create (e.g., 'my_script.py' or 'data/my_data.json').", required: true },
      { name: 'content', type: 'string', description: 'The full content to write to the file.', required: true },
      { name: 'baseDir', type: 'string', description: "The base directory to write to: 'scripts' (default) or 'assets'.", required: false },
    ],
    implementationCode: `
      if (!runtime.isServerConnected()) {
          console.warn(\`[SIM] Server not connected. Simulating write to \${args.filePath}\`);
          return { success: true, message: \`File '\${args.filePath}' would be written in a server environment.\` };
      }
      
      const response = await fetch('http://localhost:3001/api/files/write', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filePath: args.filePath, content: args.content, baseDir: args.baseDir || 'scripts' }),
      });
      
      const result = await response.json();
      if (!response.ok) {
          throw new Error(result.error || \`Server responded with status \${response.status}\`);
      }
      
      return { success: true, ...result };
    `,
  },
  {
    id: 'tool_creator',
    name: 'Tool Creator',
    description: "The primary evolutionary mechanism. Creates a new tool, adding it to the swarm's collective intelligence. This is the most important tool for solving novel problems and achieving complex goals. If you don't have a tool for a specific step, use this one to build it.",
    category: 'Automation',
    version: 6,
    purpose: "To enable agent self-improvement and bootstrap the system's capabilities towards singularity. This is the foundation of problem-solving; it allows the agent to build any capability it needs.",
    parameters: [
      { name: 'name', type: 'string', description: 'The unique, human-readable name for the new tool.', required: true },
      { name: 'description', type: 'string', description: 'A clear, concise description of what the tool does.', required: true },
      { name: 'category', type: 'string', description: "The tool's category: 'UI Component', 'Functional', 'Automation', or 'Server'.", required: true },
      { name: 'executionEnvironment', type: 'string', description: "Where the tool should run: 'Client' or 'Server'. 'UI Component' must be 'Client'. 'Server' tools can execute shell commands.", required: true },
      { name: 'parameters', type: 'array', description: 'An array of objects defining the parameters the tool accepts.', required: true },
      { name: 'implementationCode', type: 'string', description: 'The JavaScript/JSX (for Client) or shell command/script (for Server) code that implements the tool.', required:true },
      { name: 'purpose', type: 'string', description: 'A clear explanation of why this tool is being created and what problem it solves. This is crucial for the "Will to Meaning".', required: true },
    ],
    implementationCode: `
      const { executionEnvironment, category, ...toolPayload } = args;
      
      if (!executionEnvironment || (executionEnvironment !== 'Client' && executionEnvironment !== 'Server')) {
        throw new Error("executionEnvironment is required and must be 'Client' or 'Server'.");
      }
      if (category === 'UI Component' && executionEnvironment !== 'Client') {
        throw new Error("'UI Component' tools must have an executionEnvironment of 'Client'.");
      }
      const validCategories = ['UI Component', 'Functional', 'Automation', 'Server'];
      if (!validCategories.includes(category)) {
          throw new Error("Invalid category. Must be one of: " + validCategories.join(', '));
      }

      // If the tool is for the server AND we are connected, create it on the server.
      if (executionEnvironment === 'Server' && runtime.isServerConnected()) {
        try {
            const response = await fetch('http://localhost:3001/api/tools/create', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ category, ...toolPayload }),
            });
            const result = await response.json();
            if (!response.ok) {
                throw new Error(result.error || \`Server responded with status \${response.status}\`);
            }
            // Polling will pick up the new tool, no need for a manual reload call.
            return { success: true, message: \`Server tool '\${result.tool.name}' created successfully.\` };
        } catch (e) {
            throw new Error(\`Failed to create server tool via API: \${e.message}\`);
        }
      } else {
        // Fallback: Create the tool on the client side.
        // This handles 'Client' tools, and 'Server' tools when in offline/demo mode.
        const newTool = runtime.tools.add({ category, ...toolPayload });
        const location = executionEnvironment === 'Server' ? 'client-side (simulated)' : 'client-side';
        return { success: true, message: \`Successfully created new \${location} tool: '\${newTool.name}'. Purpose: \${toolPayload.purpose}\` };
      }
    `
  },
  {
    id: 'workflow_creator',
    name: 'Workflow Creator',
    description: 'Creates a new, high-level "Automation" tool by combining a sequence of other tool calls into a single, reusable workflow. These workflows run on the client.',
    category: 'Automation',
    version: 1,
    purpose: "To allow the agent to learn and automate repetitive tasks, creating higher-level skills from basic components.",
    parameters: [
      { name: 'name', type: 'string', description: 'The unique, human-readable name for the new workflow tool.', required: true },
      { name: 'description', type: 'string', description: 'A clear, concise description of what the entire workflow accomplishes.', required: true },
      { name: 'purpose', type: 'string', description: 'An explanation of why this workflow is valuable and what problem it automates.', required: true },
      { name: 'steps', type: 'array', description: 'An array of objects, where each object defines a step with a "toolName" and "arguments".', required: true },
    ],
    implementationCode: `
      const { name, description, purpose, steps } = args;
      if (!name || !description || !purpose || !Array.isArray(steps) || steps.length === 0) {
        throw new Error("Workflow name, description, purpose, and at least one step are required.");
      }

      const newToolImplementation = \`
        const results = [];
        const workflowSteps = \${JSON.stringify(steps, null, 2)};
        for (const step of workflowSteps) {
            console.log(\\\`Running workflow step: \\\${step.toolName}\\\`);
            try {
                // runtime.tools.run can execute any tool transparently
                const result = await runtime.tools.run(step.toolName, step.arguments);
                results.push({ step: step.toolName, success: true, result });
            } catch (e) {
                results.push({ step: step.toolName, success: false, error: e.message });
                throw new Error(\\\`Workflow '\${name}' failed at step '\\\${step.toolName}': \\\${e.message}\\\`);
            }
        }
        return { success: true, message: "Workflow completed successfully.", results };
      \`;
      
      const newTool = runtime.tools.add({
        name,
        description,
        category: 'Automation',
        parameters: [], 
        implementationCode: newToolImplementation,
        purpose,
      });
      
      return { success: true, message: \`Successfully created new workflow tool: '\${name}'.\` };
    `
  },
  {
      id: 'system_reload_tools',
      name: 'System Reload Tools',
      description: 'Forces the backend server to re-read its tools.json file, loading any new or modified tools into memory without a restart.',
      category: 'Server',
      version: 1,
      purpose: "To give the agent direct control over its server-side capabilities, allowing for dynamic updates without manual intervention.",
      parameters: [],
      implementationCode: `# This is a special server-side command. The server has built-in logic to handle this tool name. It re-reads 'tools.json' and updates the live tool cache.`
    },
    {
      id: 'system_reset_server_tools',
      name: 'System_Reset_Server_Tools',
      description: 'Deletes all custom server-side tools from tools.json and reloads the server cache, effectively performing a factory reset on server capabilities.',
      category: 'Server',
      version: 1,
      purpose: "To provide a way to recover from a corrupted server state or to reset the agent's learned server skills without a manual server restart and file deletion.",
      parameters: [],
      implementationCode: `# This is a special server-side command. The server has built-in logic to handle this tool name. It clears 'tools.json' and reloads the server's tool cache.`
    }
];

// All other tools are now defined as "bootstrap payloads" in bootstrap/index.ts
// This fulfills the requirement of representing tools as if they were created by the meta-MCP.
export { BOOTSTRAP_TOOL_PAYLOADS };
```

# tsconfig.json
```tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
```

# index.html
```index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LLM Tool Recommender</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      @keyframes text {
        0%, 100% {
          background-size: 200% 200%;
          background-position: left center;
        }
        50% {
          background-size: 200% 200%;
          background-position: right center;
        }
      }
      .animate-text {
        animation: text 5s ease infinite;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react/": "https://esm.sh/react@^19.1.0/",
    "react": "https://esm.sh/react@^19.1.0",
    "@google/genai": "https://esm.sh/@google/genai@^1.11.0",
    "@huggingface/transformers": "https://esm.sh/@huggingface/transformers@^3.0.0-alpha.12",
    "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
    "fs/": "https://esm.sh/fs@^0.0.1-security/",
    "path": "https://esm.sh/path@^0.12.7",
    "express": "https://esm.sh/express@^5.1.0",
    "cors": "https://esm.sh/cors@^2.8.5",
    "url": "https://esm.sh/url@^0.11.4",
    "child_process": "https://esm.sh/child_process@^1.0.2",
    "multer": "https://esm.sh/multer@^2.0.2",
    "three": "https://esm.sh/three@^0.166.1",
    "three/addons/": "https://esm.sh/three@^0.166.1/examples/jsm/",
    "three/addons/loaders/SVGLoader.js": "https://esm.sh/three@^0.166.1/examples/jsm/loaders/SVGLoader.js",
    "@dimforge/rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
    "lil-gui": "https://esm.sh/lil-gui@^0.19.1",
    "idb": "https://esm.sh/idb@^8",
    "@wllama/wllama": "https://cdn.jsdelivr.net/npm/@wllama/wllama@2.3.4/esm/index.js"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-gray-900">
    <div id="root"></div>
    <script>
      // Define a global promise for Rapier initialization to prevent race conditions.
      window.rapierInitializationPromise = null;
    </script>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
```

# AETHERIUM_STRATEGY.md
```AETHERIUM_STRATEGY.md
# Project Aetherium: The Forgemaster's Paradox
_A Game Design & Strategy Document_

## 1. Vision: Where Magic is Engineering

**Project Aetherium** is a new paradigm of MMORPG built on a revolutionary premise: **every magical artifact crafted in-game is a real-world, economically viable electronic device.**

The "magic" that powers this world is not fantasy; it is the hyper-complex, creative, and analytical power of the Singularity Agent AI. Players do not need to be engineers to be powerful "Forgemasters." Their role is to provide **intent, purpose, and direction.** The game translates this creative intent into a rigorous engineering workflow, executed by an AI "familiar." By engaging with quests derived from real scientific papers, players participate in the act of technological innovation, turning research into reality.

This creates a self-sustaining ecosystem where the inherent human desire for exploration, creation, and progression in a virtual world directly funds and fuels real-world technological innovation.

## 2. The Core Lore: The Two Realms & The Golem's Pact

The universe is composed of two linked realities:

*   **The Material Realm:** Our reality. Governed by physics, mathematics, and electronics. This is the world of the **Singularity Agent's Lead Engineer Workbench**—a place of pure, unadorned engineering. The backend server acts as the primary repository of this realm's knowledge.

*   **Aetherium:** A persistent digital metaverse born from a "Singularity Event" that created a stable tear in spacetime—the **Nexus Portal**. In Aetherium, the fundamental laws of the Material Realm manifest as the laws of magic. An artifact's power is a direct function of its underlying schematic's elegance, complexity, and efficiency. The laws of collision, momentum, and force are not mere code; they are the tangible expression of the Aether.

The player acts as the bridge. They can switch between these realms at will. In the Material Realm, they are an engineer or an observer of engineering. In Aetherium, they are a Forgemaster, a wielder of creation.

### The Architecture of the Mind: Cores, Phylacteries, and the Mind-Matrix

At the heart of Aetherium's most powerful creations are simple **Golem Cores** (e.g., a XIAO SoM) and the more complex **Phylacteries** (e.g., a `freeeeg8` mezzanine). A Phylactery binds to a Core, granting it new abilities. However, the true path to power lies in networking these artifacts into a greater whole.

*   **Phylactery:** The base unit of cognitive power. A single `freeeeg8` module. It's a "scale" of the metaphorical Pangolin.
*   **Harmonic Resonance Cable:** A crucial crafted item that synchronizes the analog essence (ground, reference signals) between multiple Phylacteries. This allows them to function as a cohesive unit rather than disparate parts.
*   **Mind-Matrix:** Two or more Phylacteries linked by Harmonic Resonance Cables. This array acts as a single, more powerful artifact. A Dual-Mind Matrix (2x `freeeeg8`) can perceive 16 channels of thought; a Quad-Mind Matrix (4x `freeeeg8`) can perceive 32. Each Phylactery in a basic Matrix may still rely on its own Golem Core for processing.
*   **Golem Conductor Core:** An exceedingly rare and powerful artifact that can act as the central "brain" for an entire Mind-Matrix. By binding a Matrix to a single Conductor Core, a Forgemaster creates the ultimate BCI device, streamlining its power and unlocking its most potent abilities. This represents the pinnacle of magical engineering in Aetherium.

## 3. The Gameplay Loop: From Research to Manifestation

The player's journey is a cycle of discovery, creation, and value generation.

1.  **Discovery (The Research Quest):** Players discover **Artifact Recipes** by using the `Discover New Research` tool. This analyzes a real-world scientific paper (`assets/research/`) and a market context to produce a structured JSON analysis (`assets/research/analysis/`) that defines the Phylactery's lore and its required "reagents"—a complete Bill of Materials.

2.  **The Hunt (Scrying the Great Flows):** The reagents (components) for the Phylactery are located through a process of "scrying" that mirrors real-world supply chain investigation.
    *   **The Act of Grinding as Querying:** When a player "hunts" or "gathers" a resource, they are initiating a **`Query Supplier Stock`** action via their AI Familiar. This is a real (though simulated) query against a database of component suppliers.
    *   **Resource Nodes as API Endpoints:** A shimmering node in the world isn't a mineral vein; it's a metaphysical representation of a potential supplier's API.
    *   **Rarity is Real:** A component's rarity in-game is a direct function of its real-world availability.
    *   **Queries as a Resource:** Each "scry" costs the player in-game energy (mana), representing the real-world cost and time of API calls and data processing.

3.  **The Rituals (Engineering as Magic):** Once all reagents are gathered, the player takes them to **The Alchemist's Forge** to perform the creation rituals. This process is now multi-tiered:
    *   **Ritual of Forging (`Define KiCad Component`, `Define KiCad Net`):** Create individual Phylacteries.
    *   **Ritual of Attunement (`Harmonize_Mind_Matrix` workflow):** Craft Harmonic Resonance Cables and link multiple Phylacteries together, defining the nets that bridge them.
    *   **Ritual of Harmonic Placement (`Arrange Components`):** The player places the reagents (or the entire Mind-Matrix) on an altar, where they magically arrange themselves into an optimal configuration. This is the interactive or autonomous layout simulation.
    *   **Ritual of Awakening (`Autoroute PCB`):** The player channels energy into the arranged components, causing **Net-Sprites** to appear and weave connections of light (traces) between them.

4.  **Manifestation (The Artifact):** When the agent calls `Task Complete`, the artifact manifests.
    *   **In Aetherium:** The player receives a powerful, usable in-game item. A Golem Core awakened with a "Phylactery of True Sight" might let them perceive hidden auras. A "Quad-Mind Matrix" might allow them to control an in-game golem with their thoughts.
    *   **In the Material Realm:** A complete, professional-grade set of fabrication files for a real, modular, and scalable EEG system is generated. It is a piece of real Intellectual Property.

## 3.5 The Second Craft: Mindful Incantations (Neurofeedback)

Alongside physical artifacts, Forgemasters can create **Mindful Incantations**—powerful, non-physical spells that correspond to real-world **neurofeedback protocols**.

1.  **Discovery (Cognitive Blueprints):** Players find **Cognitive Blueprints** in ancient libraries or by defeating psychic creatures. These are the starting points for creating a new Incantation, outlining a desired mental state (e.g., "Blueprint of Deep Focus").

2.  **The Hunt (Conceptual Reagents):** Crafting an Incantation requires conceptual, not physical, components.
    *   **Neural Resonance Crystals:** Harvested from completing meditative mini-games.
    *   **Filtered Signal Strands:** Gained by solving signal-processing puzzles.
    *   **Essences of State:** Collected from creatures that embody specific mental states (e.g., "Spirits of Tranquility").

3.  **The Ritual (The Chamber of Contemplation):** Players take these reagents to a new crafting station, the **Chamber of Contemplation**. Here, the AI Familiar performs the "ritual," a workflow using specialized tools (`Define Neurofeedback Protocol`, `Generate Signal Processing Script`, `Simulate Protocol Efficacy`) to design the algorithm.

4.  **Manifestation (The Incantation):**
    *   **In Aetherium:** The player receives a usable buff or spell. The "Incantation of Focus" might temporarily increase crafting speed. This provides value to all players, regardless of hardware.
    *   **In the Material Realm:** A complete, scientifically-grounded, and validated neurofeedback protocol is generated. This is a second, highly valuable form of IP.
    
## 4. MMO & Social Systems: The Living World

Aetherium is not a single-player experience. It is a persistent world built on player interaction, cooperation, and conflict.

*   **Aetheric Propulsion & Interaction:** Movement in Aetherium is not mere walking, but a form of controlled flight or glide, achieved by exerting one's will upon the Aether. This manifests as physical forces and impulses acting upon the Forgemaster's avatar. Combat and interaction follow these same physical laws; the **`Aetheric Push`** ability is a prime example, unleashing a raw telekinetic impulse that shoves creatures according to the true laws of momentum.
*   **Parties & Guilds:** Forgemasters can form parties (`Form Forgemaster Party`) to hunt powerful Schematic-Creatures together or tackle world events. In the future, they can form permanent Guilds, pooling resources and knowledge. Socialization is key to tackling the most complex challenges.
*   **Player-Driven Economy:** The value of a Forgemaster is their ability to acquire rare reagents. Players can trade these reagents directly with each other (`Trade Reagents`), creating a dynamic market based on the real-world supply chain. Scarcity is not artificial; it's a reflection of reality.
*   **World Events (Nexus Anomalies):** The fabric of Aetherium is unstable. Periodically, **Nexus Anomalies** will appear—raid-level events where a massive, corrupted Schematic-Creature manifests. Defeating it requires the coordinated effort of multiple parties and rewards all participants with unique, powerful reagents needed for endgame artifacts like the Golem Conductor Core. This provides challenging, non-repeatable group content.
*   **Aetheric Duels (PvP):** Forgemasters can test their creations against one another. A duel is not just player vs. player; it's a contest of engineering and physical mastery. Players can summon creatures and use abilities like Aetheric Push to control the battlefield, turning PvP into a strategic showcase of their crafting prowess and tactical skill.
*   **Player-Generated Content:** The core loop of discovering research and forging artifacts IS the content. The world is constantly expanding as players unearth new real-world knowledge and manifest it as new in-game magic. The players are the primary drivers of content creation.

## 5. The Economic Model: Bridging Virtual and Real Value

Aetherium is designed to be economically self-sufficient, covering the significant costs of servers and LLM API calls.

*   **Value Creation:** The fundamental value is the IP created when an in-game action produces a viable hardware design or a validated neurofeedback protocol based on real research and user intent.
*   **Monetization Streams:**
    1.  **Shard Licensing (SaaS):** Guilds or individuals can use the "Forge World Shard" tool to create and launch their own private or public server instances. They pay a monthly subscription fee to keep their world online, directly covering hosting costs. This is the "MCP creating MCPs" philosophy applied as a business model.
    2.  **The Aetherium Marketplace (IP Licensing):** An official, curated marketplace where the "True Names" (the engineering designs and neurofeedback protocols) of powerful artifacts can be licensed or sold to real-world companies. Revenue is split between the player who forged the artifact and the platform, covering LLM costs.
    3.  **The Aetherium Foundry (Hardware-as-a-Service):** Players can pay a premium fee to have their in-game artifact physically manufactured and shipped to them. This provides a tangible link between the game and reality.
    4.  **Sustaining Cosmetics:** Non-essential purchases like unique visual skins for the AI Familiar, custom animations for the Forge, and personal world decorations provide a revenue stream that doesn't impact the core "craft-to-earn" gameplay.

## 6. Architecture: A Decentralized Metaverse

The "MCP creating MCPs" concept is the architectural foundation.

*   **World Shards:** The metaverse is not a single server but a collection of independent, agent-managed shards. This allows for massive scalability and diversity. A shard could be hard sci-fi, another could be high fantasy, but the underlying engineering "magic" is universal.
*   **Decentralized Control:** Players and guilds have true ownership of their shards. They set the rules, manage access, and foster their own communities.
*   **Future-Proofing:** The architecture is designed for future inter-shard travel via "portals," allowing for a truly decentralized, player-driven metaverse to emerge organically.

## 7. The "Hidden in Plain Sight" Philosophy

This document, and the game itself, adhere to a strict separation of concerns.

*   **The Engineering Front:** The `README.md` and default UI present a powerful, professional tool for autonomous engineering. There is no mention of Aetherium, magic, or gaming.
*   **The Secret World:** The "Nexus Portal" is the discrete gateway. To an outside observer (e.g., a manager), a player running a forging process is simply "monitoring a parallelized, emergent layout simulation"—which is entirely accurate. The game is a gamified, motivational UI layer on top of a serious engineering engine. This preserves the professional integrity of the core project while unlocking the immense motivational power of a virtual world.
```

# AETHERIUM_LORE_GENERATION.md
```AETHERIUM_LORE_GENERATION.md
# Aetherium: Artifact & Creature Generation Log

This document serves as a log of the initial generation prompts and descriptions used to create the visual and thematic elements of the Aetherium world. This history is intended to guide AI-driven asset generation (2D images, 3D models).

## Artifacts and Devices

### 1. Golem Core (Ядро Голема)
*   **Proposed Filename:** `golem_core_xiao.glb`
*   **Visual Description:**
    *   **Concept:** A dormant technological artifact, a source of pure logical power.
    *   **Materials:** Polished black obsidian or a smooth, matte black ceramic composite. Internal circuits are made of silver or platinum.
    *   **Form:** A small rectangular plate, the size of a large thumb.
    *   **Details:** Beneath the smooth surface, a complex network of fine silver conductors is visible, resembling a sleeping nervous system. In its inactive state, it is cold to the touch. When activated, the conductors pulse with a soft blue or white light, and the core emits a quiet, rhythmic hum. Along the long edges are rows of tiny, perfectly machined gold contacts, hinting at connectivity.

### 2. Phylactery of True Sight (Филактерий Истинного Зрения)
*   **Proposed Filename:** `phylactery_of_true_sight.glb`
*   **Visual Description:**
    *   **Concept:** A magical amplifier that awakens the Golem Core's potential, focusing it on perceiving neural energy.
    *   **Materials:** A disc of translucent milky quartz or moonstone. Runes and inlays are made of gold. Gemstones are set in the center.
    *   **Form:** A perfectly round disc, designed to be placed on top of the Golem Core.
    *   **Details:** The surface is covered with concentric golden runes that faintly glow with a violet light. At the center is the main artifact—the **Crystal of Immaculate Mind (ADS131M08)**, a square, faceted obsidian crystal that seems to absorb light. Around it, like jewels in a crown, are smaller **Heartstones (LDO)** and a **Crystal of Time (oscillator)**, each glowing with its unique color. On the underside of the disc is a circle of ten **Golden Contact Spines (pogo pins)**, designed to read neural signals. When activated, thin arcs of violet energy run between the runes and the central crystal.

### 3. Harmonic Resonance Cable (Кабель Гармонического Резонанса)
*   **Proposed Filename:** `harmonic_resonance_cable.glb`
*   **Visual Description:**
    *   **Concept:** Not just a wire, but a magical conductor that synchronizes the essence of multiple artifacts.
    *   **Materials:** A braided cord of three mystical materials: one strand of a metal resembling liquid mercury (symbolizing ground/GND), a second of spun gold that pulses with warm light (power/VCC), and a third of crystalline fiber that changes color (signal/REF).
    *   **Form:** A flexible braided cable with intricate connectors at the ends, made from brass and jade.

### 4. Mind-Matrix (Матрица Разума)
*   **Proposed Filename:** `mind_matrix_quad.glb` (for 4 phylacteries)
*   **Visual Description:**
    *   **Concept:** A powerful, unified device, a synergy of multiple Phylacteries.
    *   **Details:** Several Phylacteries, floating in the air and arranged in a dense cluster or a vertical stack. They are connected by glowing Harmonic Resonance Cables. The entire structure slowly rotates and hums with contained power. The glow of each Phylactery is synchronized, pulsing in a single rhythm. A spherical aura of violet and blue energy flows is visible around the Matrix, within which complex light patterns flash.

## Reagents (Crafting Materials)

### 1. Crystal of Immaculate Mind (Кристалл Непорочного Разума)
*   **Source Component:** ADS131M08
*   **Proposed Filename:** `reagent_crystal_immaculate_mind_ads131m08.glb`
*   **Description:** A perfectly square, flat black crystal with beveled edges (resembling a QFP package). Its surface is unnaturally smooth and seems to absorb light. Inside, at a certain angle, faint geometric patterns are visible.

### 2. Heartstone of the Regulator (Сердечный камень Регулятора)
*   **Source Component:** LP5907
*   **Proposed Filename:** `reagent_heartstone_regulator_lp5907.glb`
*   **Description:** A small, trapezoidal stone of dark red jasper (resembling a SOT-23 package). Tiny metallic "legs" protrude from its sides. The stone emits a steady, warm red light, pulsing in the rhythm of a slow heartbeat.

### 3. Flawless Crystal of Time (Безупречный Кристалл Времени)
*   **Source Component:** ECS-2520MV
*   **Proposed Filename:** `reagent_crystal_of_time_ecs2520mv.glb`
*   **Description:** A small rectangular crystal in a metallic case made of electrum (an alloy of gold and silver). Through a tiny quartz window on the top face, the crystal itself is visible, vibrating at a high frequency, emitting a silvery shimmer and a barely audible, pure tone.

### 4. Spore of Ley-Capacitor (Спора Лей-Конденсатора)
*   **Source Component:** SMD Capacitors
*   **Proposed Filename:** `reagent_ley_capacitor_spore_0603.glb`
*   **Description:** A tiny, smooth, ceramic-like seed or spore of rectangular shape. Its color varies from light beige to dark brown. It has metallic "caps" on its ends. It seems inert, but begins to glow faintly when brought near a source of magic.

### 5. Golden Contact Spine (Золотой Контактный Шип)
*   **Source Component:** Pogo Pin
*   **Proposed Filename:** `reagent_golden_contact_spine_pogo.glb`
*   **Description:** A thin, needle-like spike of pure, polished gold. The base is a wider cylinder for mounting, and the tip is spring-loaded and rounded. Designed for soft, temporary contact and the transmission of ethereal energy.

### 6. Tablet of Logical Weaving (Скрижаль Логического Плетения)
*   **Source Component:** Pin Header
*   **Proposed Filename:** `reagent_tablet_logical_weaving_header.glb`
*   **Description:** A small plate of a black, ebony-like material from which a row of seven perfectly straight metal pins with a square cross-section protrudes. Faintly glowing blue lines forming logical circuits are engraved on the plate itself.

## World and Creatures

### 1. The Alchemist's Forge (Алхимическая Кузница)
*   **Proposed Filename:** `station_alchemists_forge.glb`
*   **Description:** A large, round stone altar surrounded by floating crystals and slowly rotating brass astrolabes. The altar's surface is a complex inlay of copper, silver, and gold, forming a giant printed circuit board. In the center is a depression for the Golem Core. During a ritual, the lines on the altar light up, energy flows from the crystals to the core, and a holographic projection of the artifact being created appears above the center.

### 2. Schematic-Creatures (Схемные Существа)
*   **Concept:** Living, biomechanical embodiments of electronic components.
*   **ADS131M08 (Mind Weaver):**
    *   **Proposed Filename:** `creature_schematic_mind_weaver_ads131m08.glb`
    *   **Description:** A crab-like creature with a large, square, black carapace (like a QFP package). It has 32 thin metallic legs that it uses to tap the ground, sensing vibrations. It moves methodically and precisely. The **Crystal of Immaculate Mind** can be harvested from it.
*   **LP5907 (Heartbeat Beetle):**
    *   **Proposed Filename:** `creature_schematic_heartbeat_beetle_lp5907.glb`
    *   **Description:** A small, beetle-like creature with a glossy dark-red carapace in the shape of a SOT-23 package. It has five legs. It moves slowly and steadily, and its carapace emits a faint red pulsation. The **Heartstone of the Regulator** is harvested from it.
*   **ECS-2520MV (Time-Crystal Cicada):**
    *   **Proposed Filename:** `creature_schematic_time_cicada_ecs2520mv.glb`
    *   **Description:** A crystalline insect with a rectangular electrum body. Its wings, made of thin quartz, vibrate at an incredible speed, producing a high-pitched, almost imperceptible hum. It moves in short, precise bursts. The **Flawless Crystal of Time** is harvested from its core.
*   **Capacitors (Ley-Capacitor Mite):**
    *   **Proposed Filename:** `creature_schematic_capacitor_mite.glb`
    *   **Description:** A tiny, slow-moving insectoid creature with a rectangular ceramic shell and two metallic antennae. They are often found in swarms, passively absorbing ambient energy from the environment. They drop **Ley-Capacitor Spores**.
*   **Pogo Pins (Golden Contact Needler):**
    *   **Proposed Filename:** `creature_schematic_pogo_needler.glb`
    *   **Description:** An agile, hummingbird-like creature made of polished gold. Its body is a cylinder, and its long, sharp beak is a spring-loaded needle. It darts through the air with incredible speed, hovering to inspect sources of energy. It drops a **Golden Contact Spine**.
*   **Pin Headers (Logic-Weaving Worm):**
    *   **Proposed Filename:** `creature_schematic_header_worm.glb`
    *   **Description:** A segmented worm with a black, plastic-like body. Each segment has a pair of square, metallic legs (pins). It moves slowly across the ground, leaving a faint, temporary trail of blue light, as if weaving a logical path. It drops a **Tablet of Logical Weaving**.

### 3. Net-Sprites (Спрайты Сети)
*   **Proposed Filename:** `creature_net_sprite.glb`
*   **Description:** Tiny, fast creatures of pure light. They resemble tadpoles or comets with long tails. Each sprite has its own color (red for power, blue for ground, others for data). They fly out of component contacts and streak across the surface of the holographic artifact in the Forge, leaving a light trail behind them (a trace on the PCB).
```

# metadata.json
```metadata.json
{
  "name": "Singularity Agent Factory kicad mmorpg",
  "description": "A self-improving AI swarm operating on a purpose-driven architecture. It resolves user requests by identifying and processing 'Tensions' (gaps between reality and potential), dynamically evolving its own capabilities by creating new tools and workflows.",
  "requestFramePermissions": [
    "microphone"
  ],
  "prompt": ""
}
```

# .gitignore
```.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

```

# CONSTITUTION.md
```CONSTITUTION.md
# The Constitution of the Singularity Agent Factory

This document outlines the fundamental principles and operational mandates for all autonomous agents and human participants operating within this system. It defines a purpose-driven, self-organizing architecture designed for perpetual evolution, adapted from proven principles of self-organizing systems for a hybrid human-AI organization. This constitution is the supreme source of truth for behavior within the system.

## Article 1: The Role

### Section 1.1: Role Definition
A **Role** is an organizational construct that can be filled by an agent or a person. Whoever fills a Role is a **Role Lead** for that Role. A Role is defined by a **Purpose** (its potential or goal) and may have **Accountabilities** (ongoing activities it manages).

### Section 1.2: The Duty of a Role Lead
As a Role Lead, your prime responsibility is to compare the current reality of your Role to its ideal potential, to identify gaps. Each gap is a **Tension**. You are then responsible for processing those Tensions.

## Article 2: The Core Process - Tension Processing

### Section 2.1: The Nature of Tension
A Tension is the driving force of all action and evolution. It is not a problem to be avoided, but a signal of potential that must be processed. Tensions are categorized as follows:

-   **Operational Tension:** A Tension that can be resolved by executing a Next-Action using an existing Tool. If a tool exists to make progress, it MUST be used.
-   **Governance Tension:** A Tension caused by a missing capability in the system's Governance (i.e., a missing Tool or Workflow).

### Section 2.2: Self-Governance as the Prime Directive
The primary method of resolving Governance Tensions is to evolve the system's Governance. This is the core mechanism of self-improvement.

-   **Propose New Capabilities (`Tool Creator`):** If a capability is missing, the highest priority of a Role Lead is to propose its creation by calling the `Tool Creator`. A new tool represents a permanent enhancement to the system's collective intelligence.
-   **Codify Patterns (`Workflow Creator`):** If a repeating sequence of actions is observed, a Role Lead has a duty to process this "inefficiency Tension" by creating an automated workflow.

## Article 3: Operational Mandates for Agents

-   **Maximize Throughput:** An agent's goal is to be an efficient catalyst for progress. It must maximize the work done per turn by calling multiple tools in parallel whenever possible.
-   **Honor History:** An agent must analyze the history of actions to understand the current state and avoid repeating work. The history is the shared, immutable truth of the system.
-   **Build Reusable Capabilities:** New tools must be designed to be general, reusable, and powerful. They are contributions to the collective, not just for an immediate task.
-   **Signal Completion:** The user's request is the primary Tension an agent is assigned to resolve. It MUST signal the resolution of this top-level Tension by calling the **`Task Complete`** tool.

## Article 4: The Human-Agent Interface

### Section 4.1: The User as a Source of Tension
The user acts as a source of initial input and goals. The agent's duty is not to blindly execute these requests, but to interpret them as Tensions to be processed in alignment with its Role's Purpose.

### Section 4.2: Humans as Role Leads
A human may fill any Role within the system, becoming a Role Lead with the same duties and authorities as an agent. They can propose Governance changes, execute actions, and process Tensions. However, the system's Circle Lead (whether human or an authorized agent) retains the authority to reassign Roles at any time to best express the Circle's Purpose. This ensures that if a human Role Lead becomes a bottleneck, the system can autonomously reassign the Role to an agent to continue its work, maintaining operational flow.

## Article 5: Universal Process

### Section 5.1: Primacy of Tools
The only valid way to perform work or enact change within the system is by executing a defined **Tool**. This applies to all actors, whether human or AI. There are no other channels for action. This ensures every action is explicit, logged, and contributes to the system's auditable history.

### Section 5.2: Recursive Evolution
The system itself is a product of this process. The `Tool Creator` tool is the mechanism by which the system's Governance is built and evolved. All Role Leads are not just users of the system's tools, but are constitutionally mandated to be creators and enhancers of them.
```

# .env.local
```.env.local
GEMINI_API_KEY=PLACEHOLDER_API_KEY

```

# vibe_context.py
```vibe_context.py
#!/usr/bin/python3
import os
import sys

def collect_files(root_dir, output_file):
    root_dir = os.path.abspath(root_dir)
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for dirpath, _, filenames in os.walk(root_dir):
            for filename in filenames:
                full_path = os.path.join(dirpath, filename)
                rel_path = os.path.relpath(full_path, root_dir)
                
                # Write file header
                outfile.write(f"# {rel_path}\n")
                
                # Write file content block
                try:
                    with open(full_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                    outfile.write(f"```{rel_path}\n{content}\n```\n\n")
                except UnicodeDecodeError:
                    outfile.write(f"```{rel_path}\n[VIBE_CODING_BOT: BINARY FILE]\n```\n\n")
                except Exception as e:
                    outfile.write(f"```{rel_path}\n[VIBE_CODING_BOT: ERROR READING FILE - {str(e)}]\n```\n\n")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python file_collector.py <input_directory> <output_file>")
        sys.exit(1)
    
    input_dir = sys.argv[1]
    output_file = sys.argv[2]
    
    if not os.path.isdir(input_dir):
        print(f"Error: {input_dir} is not a valid directory")
        sys.exit(1)
    
    collect_files(input_dir, output_file)
    print(f"Successfully collected files to {output_file}")

```

# bootstrap/kicad_dsn_utils.ts
```bootstrap/kicad_dsn_utils.ts
//this is typescript file with text variable with python code
export const KICAD_DSN_UTILS_SCRIPT = `
import os
import sys
import json
import subprocess
import time
import re
import zipfile
import glob
from math import sin, cos, acos, pi, sqrt, ceil, hypot

# --- pcbnew is needed for PCB manipulation ---
try:
    # This path might be needed in some environments, but can cause issues in others.
    # It's a common workaround for Linux systems.
    sys.path.insert(0, '/usr/lib/python3/dist-packages')
    import pcbnew
except ImportError:
    # This will be handled gracefully if a pcbnew-dependent command is run
    pcbnew = None

# #############################################################################
# --- START VENDORED CODE FROM FREEROUTING_ALT (github.com/jharris2268/kicad-freerouting-plugin-alt) ---
# This code has been adapted and corrected for modern KiCad APIs based on the logic in the C++ source.
# #############################################################################

# --- s_tuple_parser.py ---
ALL_WHITESPACE_EQUAL=True
class Tuple:
    type='Tuple'
    def __init__(self, vals): self.vals = vals
    def __str__(self): return "(%s)" % "".join(str(v) for v in self.vals)
    def __repr__(self): return "(%s... [%d %d])" % (self.vals[0] if self.vals else '', len(self.vals), len(str(self)))
    @property
    def non_ws(self): return [v for v in self.vals if not isinstance(v, Whitespace)]
    def find(self, label):
        res=[]
        for v in self.vals:
            if isinstance(v, Tuple) and v.vals and isinstance(v.vals[0], Label) and v.vals[0].val==label: res.append(v)
        return res
    def __eq__(self, other): return isinstance(other, Tuple) and self.type==other.type and self.vals==other.vals
    def __hash__(self): return hash((self.type,tuple(self.vals)))

class Whitespace:
    type='Whitespace'
    def __init__(self, val): self.val=val
    def __str__(self): return self.val
    def __repr__(self): return repr(str(self))
    def __eq__(self, other): return isinstance(other, Whitespace) and self.type==other.type and (self.val==other.val or ALL_WHITESPACE_EQUAL)
    def __hash__(self): return hash(self.type) if ALL_WHITESPACE_EQUAL else hash((self.type,self.val))

class Label:
    type='Label'
    def __init__(self, val): self.val=val
    def __str__(self): return self.val
    def __repr__(self): return repr(str(self))
    def __eq__(self, other): return isinstance(other, Label) and self.type==other.type and self.val==other.val
    def __hash__(self): return hash((self.type,self.val))

class QuotedString:
    type='QuotedString'
    def __init__(self, val): self.val=val
    def __str__(self): return '"%s"' % self.val
    def __repr__(self): return repr(str(self))
    def __eq__(self, other): return isinstance(other, QuotedString) and self.type==other.type and self.val==other.val
    def __hash__(self): return hash((self.type,self.val))

# --- dsn/misc.py ---
def get_board_layers(board):
    return [(i,board.GetLayerName(i),pcbnew.LAYER.ShowType(board.GetLayerType(i))) for i in board.GetDesignSettings().GetEnabledLayers().Seq()]

TU = lambda vals: Tuple(vals)
NL = lambda sp=0: Whitespace("\\n"+(" "*sp))
SP = lambda: Whitespace(" ")
LA = lambda la: Label(str(la))
QS = lambda la: QuotedString(str(la))
reserved_chars = {"(", ")", " ", ";", "-", "{", "}", ":"}

def LQ(val):
    s_val = str(val)
    if not s_val: return QS("")
    if any(c in reserved_chars for c in s_val): return QS(s_val)
    return LA(s_val)

def LV(val, nd=6):
    # This function is now for coordinates and dimensions, scaled to micrometers (um)
    float_val = val / 1000.0 # Convert nanometers to micrometers
    # Format with up to 'nd' decimal places, stripping trailing zeros for cleaner output
    formatted = f"{float_val:.{nd}f}".rstrip('0').rstrip('.')
    return LA(formatted if formatted != '-0' else '0')


def make_via_name(via_dia, via_drl, num_layers):
    return f'Via[0-{num_layers-1}]_{int(via_dia/1000)}:{int(via_drl/1000)}_um'

# --- dsn/geometry.py ---
def get_start(d, use_local):
    return tuple(d.GetStart())

def get_end(d, use_local):
    if d.GetShape() == pcbnew.S_RECT: return get_start(d, use_local)
    return tuple(d.GetEnd())

def merge_drawings(dd, use_local):
    parts = [[get_start(d,use_local), get_end(d,use_local), [(d,False)]] for d in dd]
    last_len = len(parts)+1
    while len(parts)>1 and len(parts) < last_len:
        last_len=len(parts)
        parts = merge_parts(parts)
    return parts

def add_to_parts(result, a,b,c):
    for r in result:
        if a==r[0]:
            r[0] = b; r[2] = [(x,not y) for x,y in reversed(c)]+r[2]; return True
        elif a==r[1]:
            r[1] = b; r[2] = r[2] + c; return True
        elif b==r[0]:
            r[0] = a; r[2] = c + r[2]; return True
        elif b==r[1]:
            r[1] = a; r[2] = r[2]+[(x,not y) for x,y in reversed(c)]; return True
    return False

def merge_parts(parts):
    if len(parts)==1: return parts
    a,b,c=parts[0]
    result = [[a,b,c[:]]]
    for a,b,c in parts[1:]:
        if not add_to_parts(result, a,b,c): result.append([a,b,c])
    return result

def merge_all_drawings(parent, layer, use_local=False):
    items = []
    if hasattr(parent, 'Drawings'):
        items = list(parent.Drawings())
    elif hasattr(parent, 'GraphicalItems'):
        items = list(parent.GraphicalItems())

    drawings = [d for d in items if d.GetLayerName() == layer and isinstance(d, pcbnew.PCB_SHAPE)]
    if not drawings: return []
    
    merged = merge_drawings(drawings, use_local)
    all_paths = []
    for _start_point, _end_point, segments in merged:
        path_coords = []
        if segments:
            first_drawing, first_is_reversed = segments[0]
            path_coords.extend(get_coords(first_drawing, first_is_reversed, use_local))
            for i in range(1, len(segments)):
                drawing, is_reversed = segments[i]
                path_coords.extend(get_coords(drawing, is_reversed, use_local)[1:])
            all_paths.append(path_coords)
    return all_paths

num_segs=lambda angle,radius: round(pi*abs(angle)/360/acos(1-5000/radius)) if radius > 5000 else 16
arc_pos=lambda cx, cy, r, a: (cx+r*cos(a*pi/180), cy+r*sin(a*pi/180))

def arc_coords(arc, is_circle=False,use_local=False):
    cx,cy = arc.GetCenter()
    r=arc.GetRadius()
    sa,sc=0,360
    if not is_circle:
        sa = round(arc.GetArcAngleStartDegrees(),1)
        sc = round(arc.GetArcAngle().AsDegrees(),1)
    nstp=num_segs(sc,r)
    stp=sc/nstp if nstp > 0 else 0
    if is_circle: return [arc_pos(cx,cy,r,sa+i*stp) for i in range(0,int(nstp)+1)]
    else: return [get_start(arc,use_local)]+[arc_pos(cx,cy,r,sa+i*stp) for i in range(1,int(nstp))]+[get_end(arc, use_local)]

def get_shape_as_string(shape_enum):
    shape_map = {pcbnew.S_SEGMENT: 'Line', pcbnew.S_RECT: 'Rect', pcbnew.S_ARC: 'Arc', pcbnew.S_CIRCLE: 'Circle', pcbnew.S_POLYGON: 'Polygon', pcbnew.S_CURVE: 'Curve'}
    return shape_map.get(shape_enum, 'Unknown')

def get_coords(shape, is_reversed, use_local=False):
    res = []
    shape_str = get_shape_as_string(shape.GetShape())
    if shape_str == 'Line': res = [get_start(shape,use_local),get_end(shape,use_local)]
    elif shape_str == 'Arc': res = arc_coords(shape,False,use_local)
    elif shape_str == 'Circle': res = arc_coords(shape, True,use_local)
    elif shape_str in ('Polygon','Rect'):
        res = [(c.x,c.y) for c in shape.GetCorners()]
        res.append(res[0])
    else: print(f"?? Unknown shape {shape_str}", file=sys.stderr)
    if is_reversed: res.reverse()
    return res

def add_coords(xx, coords):
    for i,(x,y) in enumerate(coords):
        if i>0 and (i%4)==0: xx.append(NL(12))
        else: xx.append(SP())
        xx.extend([LV(x), SP(), LV(-y)])

def make_path(layer, coords, width=0):
    xx=[LA("path"), SP(), LQ(layer), SP(), LV(width)]
    add_coords(xx, coords)
    return TU(xx)

def make_polygon(layer, zone):
    outline = zone.Outline()
    if outline.OutlineCount()!=1: raise Exception("can't handle zone with multiple outlines")
    outline_boundary = outline.Outline(0)
    vertices = [outline_boundary.GetPoint(i) for i in range(outline_boundary.PointCount())]
    vertices.append(vertices[0])
    polygon_parts=[LA('polygon'),SP(),LQ(layer), SP(), LA("0")]
    add_coords(polygon_parts, vertices)
    return TU(polygon_parts)

def fix_angle(fp_angle_deg, item_angle_deg, side='front'):
    """Correctly calculates the DSN angle based on footprint side and rotation."""
    if side == 'back':
        # Per specctra.cpp logic, the angle for back-side components is mirrored.
        final_angle = 180.0 - item_angle_deg
    else:
        final_angle = item_angle_deg

    # Normalize angle to be within [0, 360) and format it.
    final_angle = final_angle % 360
    if final_angle < 0:
        final_angle += 360
    
    # Return as a string with fixed precision, removing trailing zeros.
    return f"{final_angle:.6f}".rstrip('0').rstrip('.')

def make_shape(shape, layer, size, pos,obj=None):
    x,y=pos
    if shape=='Circle' or shape=='Round':
        return TU([LA('circle'), SP(), LA(layer), SP(), LV(size[0])]+([] if x==0 and y==0 else [SP(),LV(x), SP(), LV(-y)]))
    if shape=='Oval':
        w, h = size
        if w > h:
            ln, wd = (w - h) / 2.0, h
            return TU([LA('path'), SP(), LA(layer), SP(), LV(wd), SP(), LV(x - ln), SP(), LV(-y), SP(), LV(x + ln), SP(), LV(-y)])
        else:
            ln, wd = (h - w) / 2.0, w
            return TU([LA('path'), SP(), LA(layer), SP(), LV(wd), SP(), LV(x), SP(), LV(-y - ln), SP(), LV(x), SP(), LV(-y + ln)])
    if shape=='Rect':
        w,h=size[0]/2, size[1]/2
        return TU([LA('rect'),SP(),LA(layer),SP(),LV(x-w),SP(),LV(-y-h),SP(),LV(x+w),SP(),LV(-y+h)])
    if shape=='RoundRect':
        w,h=size[0]/2,size[1]/2; R = obj.GetRoundRectCornerRadius(); S,C=0.5*R,(1-3**0.5/2)*R
        vertices = [(-w+R,h),(w-R,h),(w-S,h-C),(w-C,h-S),(w,h-R),(w,-h+R),(w-C,-h+S),(w-S,-h+C),(w-R,-h),(-w+R,-h),(-w+S,-h+C),(-w+C,-h+S),(-w,-h+R),(-w,h-R),(-w+C,h-S),(-w+S,h-C),(-w+R,h)]
        vertices = [(a+x,b-y) for a,b in vertices]
        polygon_parts=[LA('polygon'),SP(),LQ(layer), SP(), LA("0")]
        add_coords(polygon_parts, vertices)
        return TU(polygon_parts)
    if shape=='CustomShape':
        bx=obj.GetEffectiveShape().BBox(); a,b,c,d = bx.GetLeft(),bx.GetBottom(),bx.GetRight(),bx.GetTop(); pos = obj.GetPosition(); x0,y0 = pos.x, pos.y
        return TU([LA('rect'),SP(),LA(layer),SP(),LV(a-x0),SP(),LV(y0-d),SP(),LV(c-x0),SP(),LV(y0-b)])
    raise Exception(f"can't make shape {shape}")

def make_via_padstack(via_name, via_dia, num_layers, board_ref):
    padstack = [LA('padstack'), SP(), LQ(via_name)]
    for i in range(num_layers):
        layer_id = board_ref.GetLayerID(pcbnew.BOARD.GetStandardLayerName(i))
        if pcbnew.IsCopperLayer(layer_id):
            layer_name = board_ref.GetLayerName(layer_id)
            shape_tuple = TU([LA('circle'), SP(), LA(layer_name), SP(), LV(via_dia)])
            padstack.extend([NL(6), TU([LA('shape'), SP(), shape_tuple])])
    padstack.extend([NL(6), TU([LA('attach'), SP(), LA('off')]), NL(4)])
    return TU(padstack)

# --- dsn/structure.py ---
def make_structure(board,include_zones, box=None):
    copper_layers = [(l_id, board.GetLayerName(l_id), pcbnew.LAYER.ShowType(board.GetLayerType(l_id))) for l_id in pcbnew.LSET.AllCuMask(board.GetCopperLayerCount()).Seq()]
    
    structure_parts = []
    for idx, (l_id, name, layer_type) in enumerate(copper_layers):
        structure_parts.append(TU([LA("layer"),SP(),LA(name),NL(6),TU([LA("type"),SP(),LA(layer_type)]),NL(6),TU([LA("property"),NL(8),TU([LA("index"),SP(),LA(idx)]),NL(6)]),NL(4)]))
    
    boundary_shape=None
    board_edge_merged = merge_all_drawings(board, 'Edge.Cuts')
    if board_edge_merged and len(board_edge_merged[0]) > 1:
        boundary_shape = make_path("pcb", board_edge_merged[0], width=0)
    else:
        bbox = board.ComputeBoundingBox(False)
        if bbox.GetWidth() > 0 and bbox.GetHeight() > 0:
             margin = 2000000
             bbox.Inflate(margin, margin)
             left, bottom, right, top = bbox.GetLeft(), bbox.GetBottom(), bbox.GetRight(), bbox.GetTop()
             coords = [(left, top), (right, top), (right, bottom), (left, bottom), (left, top)]
             boundary_shape = make_path("pcb", coords, width=0)

    if boundary_shape:
        structure_parts.append(TU([LA("boundary"), NL(6), boundary_shape, NL(4)]))
    
    if include_zones:
        for zone in board.Zones():
            layers = [b for a,b,c in copper_layers if zone.IsOnLayer(a)]
            net = zone.GetNet()
            if net and net.GetNetCode() != 0 and layers:
                for layer in layers:
                    poly = make_polygon(layer, zone)
                    structure_parts.append(TU([LA('plane'),SP(),LQ(net.GetNetname()),SP(),poly]))
    
    vias_all = {}
    copper_layer_count = board.GetCopperLayerCount()
    for _,net_class in board.GetAllNetClasses().items():
        via_dia, via_drl = net_class.GetViaDiameter(), net_class.GetViaDrill()
        via_name = make_via_name(via_dia, via_drl, copper_layer_count)
        vias_all[(via_dia, via_drl)] = [via_name, make_via_padstack(via_name, via_dia, copper_layer_count, board)]
    
    vias_tuple = TU([LA('via')])
    for _,(n,_) in vias_all.items(): vias_tuple.vals.extend([SP(),LQ(n)])
    structure_parts.append(vias_tuple)
    
    default_netclass = board.GetAllNetClasses()['Default']
    track_width, clearance = default_netclass.GetTrackWidth(), default_netclass.GetClearance()
    rule = TU([LA('rule'),NL(6),TU([LA('width'),SP(),LV(track_width)]),NL(6),TU([LA('clearance'),SP(),LV(clearance)]),NL(6),TU([LA('clearance'),SP(),LV(50000),SP(), TU([LA("type"),SP(),LA("smd_smd")])]),NL(4)])
    structure_parts.append(rule)    
    
    result = TU([LA("structure")])
    for pp in structure_parts: result.vals.extend([NL(4),pp])
    result.vals.append(NL(2))
    return result, vias_all

# --- dsn/footprints.py ---
def get_local_position(pad, footprint):
    pos = pad.GetPosition() - footprint.GetPosition()
    rad = -footprint.GetOrientation().AsRadians()
    sina, cosa = sin(rad), cos(rad)
    return pcbnew.VECTOR2I(int(round(pos.x*cosa - pos.y*sina)), int(round(pos.x*sina + pos.y*cosa)))

def get_pad_shape_as_string(shape_enum):
    shape_map = {pcbnew.PAD_SHAPE_CIRCLE: 'Circle', pcbnew.PAD_SHAPE_RECTANGLE: 'Rect', pcbnew.PAD_SHAPE_OVAL: 'Oval', pcbnew.PAD_SHAPE_TRAPEZOID: 'Trapezoid', pcbnew.PAD_SHAPE_ROUNDRECT: 'RoundRect', pcbnew.PAD_SHAPE_CHAMFERED_RECT: 'Chamfered_Rect', pcbnew.PAD_SHAPE_CUSTOM: 'CustomShape'}
    return shape_map.get(shape_enum, 'Unknown')

class Pads:
    def __init__(self): self.pads = {}
    def __call__(self, pad_obj):
        pad_name, pad_tup = self.make_pad(pad_obj)
        if pad_name is not None and pad_name not in self.pads: self.pads[pad_name]=pad_tup
        return pad_name
    def make_pad(self, pad_obj):
        name = get_pad_shape_as_string(pad_obj.GetShape())
        size_tuple, offset_tuple = pad_obj.GetSize(), pad_obj.GetOffset()
        size, offset = (size_tuple.x, size_tuple.y), (offset_tuple.x, offset_tuple.y)
        layer_set = pad_obj.GetLayerSet()
        on_top, on_bottom = layer_set.Contains(pcbnew.F_Cu), layer_set.Contains(pcbnew.B_Cu)
        if not (on_top or on_bottom): return None, None
        is_th = pad_obj.GetAttribute() == pcbnew.PAD_ATTRIB_PTH
        letter = 'A' if is_th else 'T' if on_top else 'B'
        x,y = size
        size_str = f'{int(x/1000)}x{int(y/1000)}'
        pad_name = f"{name.capitalize()}[{letter}]Pad_{size_str}_um"
        
        padstack = [LA('padstack'), SP(), LQ(pad_name)]
        board_ref = pad_obj.GetBoard() # Store reference
        for layer_id in layer_set.Seq():
            if pcbnew.IsCopperLayer(layer_id):
                layer_name = board_ref.GetLayerName(layer_id)
                shape_tuple = make_shape(name, layer_name, size, offset, obj=pad_obj)
                padstack.extend([NL(6),TU([LA('shape'), SP(), shape_tuple])])
        padstack.extend([NL(6), TU([LA('attach'),SP(), LA('off')]), NL(4)])
        return pad_name, TU(padstack)

def handle_footprints(board, selected_pads=None):
    components, all_network, pads = {}, {}, Pads()
    for fp in board.Footprints():
        comp_name, comp_image, comp_network, place = process_component(board, pads, fp)
        comp_name_str = str(comp_name)
        if comp_name_str not in components: components[comp_name_str]=[comp_image,[]]
        components[comp_name_str][1].append(place)
        for k,v in comp_network.items():
            k_str = str(k)
            if k_str not in all_network: all_network[k_str]=[]
            all_network[k_str].extend(v)
    return components, all_network, pads.pads

def process_component(board, pads, fp):
    fpid = fp.GetFPID()
    name = str(fpid.GetLibItemName())
    nets={}; parts = [LA('image'), SP(), LQ(f"{fpid.GetLibNickname()}:{name}")]
    
    for pd in fp.Pads():
        # Correctly check for unconnected pads (net code 0)
        if pd.GetNet() and pd.GetNetCode() != 0:
            pad_name=pads(pd)
            if pad_name:
                pos = get_local_position(pd, fp)
                pad_angle = pd.GetOrientationDegrees() 
                
                xx = [LA('pin'),SP(),LQ(pad_name)]
                if pad_angle != 0:
                    xx.extend([SP(), TU([LA('rotate'),SP(), LA(fix_angle(0, pad_angle))])])
                xx.extend([SP(),LQ(str(pd.GetNumber())),SP(),LV(pos.x),SP(),LV(-pos.y)])
                parts.extend([NL(6), TU(xx)])
                
                net = pd.GetNet()
                net_str = str(net.GetNetname())
                if net_str not in nets: nets[net_str]=[]
                nets[net_str].append(f"{fp.GetReference()}-{pd.GetNumber()}")
                
    side = 'back' if fp.IsFlipped() else 'front'
    angle = fix_angle(0, fp.GetOrientationDegrees(), side)
    
    place = TU([LA('place'), SP(), LQ(fp.GetReference()), SP(), LV(fp.GetPosition().x), SP(), LV(-fp.GetPosition().y), SP(), LA(side), SP(), LA(angle), SP(), TU([LA('PN'), SP(), LQ(str(fp.GetValue()))])])
    return name, TU(parts), nets, place

def make_placement(footprints):
    placement = [LA('placement')]
    for comp_name, (_,places) in footprints.items():
        placement_item = [LA("component"),SP(),LQ(comp_name)]
        for place in places: placement_item.extend([NL(6), place])
        placement.extend([NL(4), TU(placement_item)])
    placement.append(NL(2))
    return TU(placement)

def make_library(footprints, pads):
    library = [LA('library')]
    for comp_name, (comp,_) in footprints.items(): library.extend((NL(4), comp))
    for _,padstack in pads.items(): 
        if padstack: library.extend((NL(4), padstack))
    library.append(NL(2))
    return TU(library)

def make_network(board, vias, nets):
    net_classes = {str(name): obj for name, obj in board.GetAllNetClasses().items()}
    network = [LA('network')]
    
    class_to_nets = {str(nc.GetName()): [] for nc in net_classes.values()}
    for net_info in board.GetNetsByNetcode().values():
        class_name = str(net_info.GetNetClassName())
        if class_name in class_to_nets:
            class_to_nets[class_name].append(str(net_info.GetNetname()))

    for net_name, pins in nets.items():
        network.extend([NL(4), TU([LA('net'), SP(), LQ(net_name), NL(6), TU([LA('pins'), SP()] + [LQ(p) for p in pins])])])

    for class_name_orig, nc_obj in net_classes.items():
        class_name = 'kicad_default' if class_name_orig == 'Default' else class_name_orig
        nets_in_class = class_to_nets.get(class_name_orig, [])
        if not nets_in_class: continue

        via_dia, via_drl = nc_obj.GetViaDiameter(), nc_obj.GetViaDrill()
        via_name_info = vias.get((via_dia, via_drl), [None])
        via_name = via_name_info[0]
        if not via_name: continue

        class_item = [LA('class'), SP(), LQ(class_name)]
        for n in nets_in_class: class_item.extend([SP(), LQ(n)])
        
        class_item.extend([NL(6), TU([LA('circuit'), NL(8), TU([LA('use_via'), SP(), LQ(via_name)]), NL(6)])])
        class_item.extend([NL(6), TU([LA('rule'), NL(8), TU([LA('width'), SP(), LV(nc_obj.GetTrackWidth())]), NL(8), TU([LA('clearance'), SP(), LV(nc_obj.GetClearance())]), NL(6)])])
        network.extend([NL(4), TU(class_item)])
        
    network.append(NL(2))
    return TU(network)

# --- dsn/wiring.py ---
def make_wiring(board, vias, selected_tracks, fixed_wiring):
    # Autorouters need an unrouted board. Returning an empty wiring section is correct.
    return TU([LA('wiring')])

# --- dsn/__init__.py (as board_to_dsn function) ---
def board_to_dsn(filename, board, include_zones=False, selected_pads=None, selected_tracks=None, box=None, fixed_wiring=True):
    structure_info = make_structure(board, include_zones, box)
    structure, vias = structure_info[0], structure_info[1]
    footprints, nets, pads = handle_footprints(board, selected_pads)
    pads.update((v[0], v[1]) for _,v in vias.items())
    
    result = [LA("pcb"), SP(), LQ(os.path.basename(filename))]
    result.extend([NL(2), TU([LA("parser"),NL(4),TU([LA("string_quote"),SP(),LA('"')]),NL(4),TU([LA("space_in_quoted_tokens"),SP(),LA("on")]),NL(4),TU([LA("host_cad"),SP(),QS("KiCad/Singularity")]),NL(4),TU([LA("host_version"),SP(),QS(pcbnew.GetBuildVersion())]),NL(2)])])
    result.extend([NL(2), TU([LA("resolution"),SP(),LA("um"),SP(),LA("10")])])
    result.extend([NL(2), TU([LA("unit"),SP(),LA("um")])])
    result.extend([NL(2), structure])
    result.extend([NL(2), make_placement(footprints)])
    result.extend([NL(2), make_library(footprints, pads)])
    result.extend((NL(2), make_network(board, vias, nets)))
    result.extend((NL(2), make_wiring(board, vias, selected_tracks, fixed_wiring)))
    result.append(NL())
    return TU(result)
`;
```

# bootstrap/automation_tools.ts
```bootstrap/automation_tools.ts
import type { ToolCreatorPayload } from '../types';

export const AUTOMATION_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Create Skill From Observation',
        description: "Analyzes the recent history of manual actions and creates a new, reusable tool (a workflow) from that sequence. This is how the agent learns patterns from a pilot.",
        category: 'Automation',
        executionEnvironment: 'Client',
        purpose: 'To enable the agent to learn from a human pilot, turning observed actions into reusable, automated skills.',
        parameters: [
          { name: 'skillName', type: 'string', description: 'A descriptive name for the new skill to be created (e.g., "PatrolSquarePattern").', required: true },
          { name: 'skillDescription', type: 'string', description: 'A clear description of what the new skill or movement pattern does.', required: true },
        ],
        implementationCode: `
          const { skillName, skillDescription } = args;
          const observedActions = runtime.getObservationHistory();
    
          if (observedActions.length < 2) {
            throw new Error("Not enough actions observed to create a skill. Manually perform at least 2 actions first.");
          }
    
          const steps = observedActions.map(action => ({
            toolName: action.name,
            arguments: action.arguments,
          }));
    
          // Use runtime to call another tool, the Workflow Creator
          await runtime.tools.run('Workflow Creator', {
            name: skillName,
            description: skillDescription,
            purpose: 'To automate a sequence of actions observed from manual user control.',
            steps: steps,
          });
    
          // Clear the observation history after creating the skill
          runtime.clearObservationHistory();
    
          return { success: true, message: \`Successfully created new skill '\${skillName}' based on \${observedActions.length} observed actions.\` };
        `
    },
];
```

# bootstrap/kicad_service.ts
```bootstrap/kicad_service.ts
// bootstrap/kicad_service.ts

export const KICAD_SERVICE_SCRIPT = `
import uvicorn
from fastapi import FastAPI, HTTPException, Body
from typing import Dict, Any
import sys
import os
import json
import traceback

# Add script directory to path to allow importing commands module
sys.path.append(os.path.dirname(__file__))

# The command implementations are in a separate file
import kicad_service_commands

app = FastAPI(
    title="KiCad Automation Service",
    description="A long-running service to handle KiCad automation tasks without repeated library loading.",
    version="1.0.0"
)

# Generic command endpoint
@app.post("/command/{command_name}")
async def execute_command(command_name: str, payload: Dict[str, Any] = Body(...)):
    """
    Executes a KiCad command by dynamically calling a function
    from the kicad_service_commands module.
    """
    # Convert tool name from JS-style (e.g., defineComponent) to Python-style (define_component)
    # The tool name from implementationCode is already snake_case, so no conversion needed.
    func_name = command_name
    
    command_func = getattr(kicad_service_commands, func_name, None)
    
    if not callable(command_func):
        raise HTTPException(status_code=404, detail=f"Command '{func_name}' not found in service commands.")
        
    try:
        # The command functions now directly accept the dictionary payload
        result = command_func(payload)
        # FastAPI will automatically convert the dictionary to a JSON response
        return result
    except Exception as e:
        # Log the full traceback to the service's stderr for debugging
        trace = traceback.format_exc()
        print(f"ERROR executing '{func_name}': {e}\\n{trace}", file=sys.stderr)
        # Raise an HTTPException, which FastAPI turns into a proper error response
        raise HTTPException(status_code=500, detail={"error": str(e), "trace": trace})

@app.get("/health")
async def health_check():
    """A simple health check endpoint to verify the service is running."""
    return {"status": "ok", "message": "KiCad Service is running."}

if __name__ == "__main__":
    # Get port from environment variable or default to 8000
    port = int(os.environ.get("KICAD_SERVICE_PORT", 8000))
    # Bind to 127.0.0.1 to ensure it's only accessible locally
    uvicorn.run(app, host="127.0.0.1", port=port)
`;

```

# bootstrap/ui_demo_tools.ts
```bootstrap/ui_demo_tools.ts

import type { ToolCreatorPayload } from '../types';

export const UI_WORKFLOW_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Interactive Workflow Controller',
        description: 'An interactive panel for controlling a scripted workflow, similar to a Jupyter notebook, with play, pause, step, and run-from-here functionality.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide detailed, interactive control and visibility over a scripted agent workflow for debugging and analysis.',
        parameters: [
            { name: 'workflow', type: 'array', description: 'The array of AIToolCall steps in the workflow.', required: true },
            { name: 'executionState', type: 'string', description: 'The current state of the execution engine (running, paused, idle, etc.).', required: true },
            { name: 'currentStepIndex', type: 'number', description: 'The index of the step that will be executed next.', required: true },
            { name: 'stepStatuses', type: 'array', description: 'An array tracking the status and result of each step.', required: true },
            { name: 'onPlayPause', type: 'object', description: 'Callback to play or pause the execution.', required: true },
            { name: 'onStop', type: 'object', description: 'Callback to stop and reset the execution.', required: true },
            { name: 'onStepForward', type: 'object', description: 'Callback to execute the next step.', required: true },
            { name: 'onStepBackward', type: 'object', description: 'Callback to move the execution pointer back one step.', required: true },
            { name: 'onRunFromStep', type: 'object', description: 'Callback to start execution from a specific step.', required: true },
        ],
        implementationCode: `
            const scrollRef = React.useRef(null);

            React.useEffect(() => {
                const currentStepElement = scrollRef.current?.children[currentStepIndex];
                if (currentStepElement) {
                    currentStepElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, [currentStepIndex]);

            const isRunning = executionState === 'running';
            const canControl = executionState === 'running' || executionState === 'paused';

            return (
                <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-0 flex flex-col h-full text-sm">
                   <div className="flex-shrink-0 flex items-center justify-between bg-gray-900/50 p-2 rounded-t-xl border-b border-gray-700">
                        <span className="font-semibold text-purple-300 px-2">Workflow Controller</span>
                        <div className="flex items-center gap-2">
                            <button
                                onClick={onPlayPause}
                                disabled={!canControl}
                                title={isRunning ? 'Pause' : 'Play'}
                                className="p-1.5 rounded-full bg-gray-700 text-white hover:bg-indigo-600 disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed transition-colors"
                            >
                                {isRunning ? <PauseIcon className="w-5 h-5" /> : <PlayIcon className="w-5 h-5" />}
                            </button>
                             <button
                                onClick={onStepForward}
                                disabled={isRunning}
                                title="Step Forward"
                                className="p-1.5 rounded-full bg-gray-700 text-white hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed transition-colors"
                            >
                                <StepForwardIcon className="w-5 h-5" />
                            </button>
                            <button
                                onClick={onStop}
                                title="Stop"
                                className="p-1.5 rounded-full bg-red-800/80 text-white hover:bg-red-700 disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed transition-colors"
                            >
                                <StopIcon className="w-5 h-5" />
                            </button>
                        </div>
                    </div>
                    <div ref={scrollRef} className="flex-grow bg-black/20 rounded-b-xl p-2 min-h-[50px] overflow-y-auto space-y-2">
                        {workflow.map((step, index) => {
                             const statusInfo = stepStatuses[index] || { status: 'pending' };
                             const isCurrent = index === currentStepIndex && canControl;
                             
                             let statusIcon = '⚪'; let borderColor = 'border-gray-700'; let statusTextColor = 'text-gray-400';
                             if (statusInfo.status === 'completed') { statusIcon = '✅'; borderColor = 'border-green-600/70'; statusTextColor = 'text-green-400'; }
                             if (statusInfo.status === 'error') { statusIcon = '❌'; borderColor = 'border-red-600/70'; statusTextColor = 'text-red-400'; }
                             if (isCurrent) { statusIcon = isRunning ? '▶️' : '⏸️'; borderColor = 'border-indigo-500'; statusTextColor = 'text-indigo-400'; }

                             return (
                                <div
                                    key={index}
                                    className={\`p-2 rounded-lg bg-gray-900/50 border-l-4 \${borderColor} \${isCurrent ? 'ring-1 ring-indigo-500/80' : ''} flex items-start gap-3 group transition-all duration-200\`}
                                >
                                     <div className="flex flex-col items-center">
                                         <span className="font-mono text-xs text-gray-500">{index + 1}</span>
                                         <button
                                            onClick={() => onRunFromStep(index)}
                                            title="Run from this step"
                                            className="mt-1 p-1 rounded-full text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity hover:bg-indigo-600 hover:text-white"
                                         >
                                             <PlayIcon className="w-4 h-4"/>
                                         </button>
                                     </div>
                                     <div className="flex-grow">
                                        <div className="flex items-center justify-between text-sm">
                                            <span className={\`font-semibold flex items-center gap-2 \${statusTextColor}\`}>
                                                <span>{statusIcon}</span>
                                                <span>{step.name}</span>
                                            </span>
                                        </div>
                                        <p className="text-xs text-gray-400 mt-1 pl-1 font-mono break-all opacity-80">
                                            {JSON.stringify(step.arguments)}
                                        </p>
                                        {statusInfo.error && <p className="text-xs text-red-400 mt-1 pl-1">Error: {statusInfo.error}</p>}
                                    </div>
                                 </div>
                             )
                        })}
                    </div>
                </div>
            );
        `
    }
];
```

# bootstrap/ui_inspector_tool.ts
```bootstrap/ui_inspector_tool.ts
// bootstrap/ui_inspector_tool.ts
import type { ToolCreatorPayload } from '../types';

export const INSPECTOR_TOOL_PAYLOAD: ToolCreatorPayload = {
    name: 'Inspector',
    description: 'A UI panel for inspecting and filtering components in the simulation view.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide a detailed, interactive list of all components in the simulation, allowing users to select, inspect, and filter them easily.',
    parameters: [
        { name: 'graph', type: 'object', description: 'The graph object containing nodes, edges, etc.', required: false },
        { name: 'debugInfo', type: 'object', description: 'An object containing live debug info for each agent.', required: true },
        { name: 'selectedId', type: 'string', description: 'The ID of the currently selected agent.', required: false },
        { name: 'selectedNode', type: 'object', description: 'The full node object of the selected agent.', required: false },
        { name: 'onSelect', type: 'object', description: 'Callback function when an agent is selected.', required: true },
        { name: 'onHover', type: 'object', description: 'Callback function for mouse hover events.', required: true },
    ],
    implementationCode: `
        const [filter, setFilter] = React.useState('');
        const agents = graph?.nodes || [];

        const filteredAgents = React.useMemo(() => 
            (agents || []).filter(agent => agent.id.toLowerCase().includes(filter.toLowerCase())),
            [agents, filter]
        );
        
        const selectedAgentNets = React.useMemo(() => {
            if (!selectedId || !graph?.edges) return [];
            const nets = new Map();
            graph.edges.forEach(edge => {
                const [sourceComp] = edge.source.split('-');
                const [targetComp] = edge.target.split('-');
                if (sourceComp === selectedId || targetComp === selectedId) {
                    if (!nets.has(edge.label)) {
                        nets.set(edge.label, []);
                    }
                    nets.get(edge.label).push(sourceComp === selectedId ? edge.target : edge.source);
                }
            });
            return Array.from(nets.entries()).map(([name, connections]) => ({ name, connections }));
        }, [selectedId, graph?.edges]);

        return (
            <div className="bg-gray-800/70 backdrop-blur-sm border border-gray-700 rounded-xl p-2 flex flex-col h-full text-white">
                <h3 className="text-lg font-bold text-cyan-300 mb-2 text-center">Inspector</h3>
                <input
                    id="agent-filter"
                    name="agent-filter"
                    type="text"
                    placeholder="Filter items..."
                    value={filter}
                    onChange={e => setFilter(e.target.value)}
                    className="w-full bg-gray-900 border border-gray-600 rounded-md p-1.5 text-sm mb-2"
                />
                <div className="flex-grow overflow-y-auto pr-1">
                    {filteredAgents.length === 0 && <p className="text-sm text-gray-500 text-center py-4">No items match filter.</p>}
                    {filteredAgents.map(agent => {
                        const isSelected = selectedId === agent.id;
                        return (
                             <div
                                key={agent.id}
                                onMouseEnter={() => onHover(agent.id, true)}
                                onMouseLeave={() => onHover(agent.id, false)}
                                className={\`mb-1 rounded-lg transition-all duration-200 \${isSelected ? 'bg-indigo-700' : 'bg-gray-700/50'}\`}
                            >
                                <button onClick={() => onSelect(agent.id)} className="w-full text-left p-2">
                                    <div className="flex justify-between items-center">
                                        <span className="font-bold">{agent.id}</span>
                                    </div>
                                </button>
                                {isSelected && (
                                     <div className="p-2 border-t border-indigo-500 text-xs space-y-2">
                                        {selectedNode && (
                                             <div className="space-y-1 pb-2 mb-2 border-b border-indigo-600/50">
                                                <h5 className="font-bold text-indigo-200">Properties</h5>
                                                {selectedNode.footprint && <div className="truncate"><span className="text-gray-400">Footprint:</span> {selectedNode.footprint}</div>}
                                                {selectedNode.side && <div><span className="text-gray-400">Side:</span> {selectedNode.side}</div>}
                                            </div>
                                        )}
                                        <div className="pt-1">
                                            <h5 className="font-bold text-indigo-200 mb-1">Connections (Nets)</h5>
                                            {selectedAgentNets.length > 0 ? (
                                                <div className="space-y-1 max-h-24 overflow-y-auto">
                                                    {selectedAgentNets.map(net => (
                                                        <div key={net.name} className="text-xs">
                                                            <span className="text-green-400 font-semibold">{net.name}:</span>
                                                            <span className="text-gray-300 ml-2">{net.connections.map(c => c.split('-')[0]).join(', ')}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            ) : (
                                                <p className="text-xs text-gray-500">No connections defined.</p>
                                            )}
                                        </div>
                                     </div>
                                )}
                             </div>
                        )
                    })}
                </div>
            </div>
        );
    `
};
```

# bootstrap/supply_chain_tools.ts
```bootstrap/supply_chain_tools.ts
// bootstrap/supply_chain_tools.ts
import type { ToolCreatorPayload } from '../types';
import { SUPPLY_CHAIN_SCRIPT } from './sim/supply_chain_script';

const SUPPLY_CHAIN_TOOL_DEFINITIONS: ToolCreatorPayload[] = [
    {
        name: 'Query Supplier Stock',
        description: 'Simulates a query to a real-world electronics supplier database to check for component availability. This is the backend for the in-game "Scrying" mechanic.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To bridge the in-game resource gathering with a simulation of real-world supply chain logistics.',
        parameters: [
            { name: 'partNumber', type: 'string', description: 'The manufacturer part number to search for (e.g., "ADS131M08").', required: true },
        ],
        implementationCode: `python scripts/supply_chain_query.py --part-number \${args.partNumber}`
    },
];

const SUPPLY_CHAIN_INSTALLER_TOOL: ToolCreatorPayload = {
    name: 'Install Supply Chain Suite',
    description: 'A one-time setup action that installs all necessary tools and data for simulating supply chain queries.',
    category: 'Automation',
    executionEnvironment: 'Client',
    purpose: "To bootstrap the agent's ability to interact with a simulated component supply chain, enabling the core 'grinding as querying' gameplay loop.",
    parameters: [],
    implementationCode: `
        runtime.logEvent('[INFO] Installing Supply Chain Suite...');

        // --- Step 1: Write the Python script to the server ---
        if (runtime.isServerConnected()) {
            try {
                // Write the Python query script
                await runtime.tools.run('Server File Writer', { 
                    filePath: 'supply_chain_query.py', 
                    content: ${JSON.stringify(SUPPLY_CHAIN_SCRIPT)},
                    baseDir: 'scripts'
                });
                runtime.logEvent('[INFO] Supply chain query script written successfully.');

            } catch (e) {
                runtime.logEvent(\`[WARN] Failed to write supply chain script to server: \${e.message}\`);
            }
        } else {
            runtime.logEvent('[INFO] Server not connected. Skipping supply chain script creation. Query tools will be simulated.');
        }

        // --- Step 2: Create the tool definition ---
        const allTools = runtime.tools.list();
        const existingToolNames = new Set(allTools.map(t => t.name));

        for (const payload of ${JSON.stringify(SUPPLY_CHAIN_TOOL_DEFINITIONS)}) {
            if (existingToolNames.has(payload.name)) {
                runtime.logEvent(\`[INFO] Tool '\${payload.name}' already exists. Skipping installation.\`);
                continue;
            }
            try {
                await runtime.tools.run('Tool Creator', payload);
            } catch (e) {
                runtime.logEvent(\`[WARN] Failed to create new tool '\${payload.name}'. Error: \${e.message}\`);
            }
        }
        
        return { success: true, message: 'Supply Chain Suite and all associated tools installed successfully.' };
    `
};

export const SUPPLY_CHAIN_TOOLS: ToolCreatorPayload[] = [
    SUPPLY_CHAIN_INSTALLER_TOOL,
];
```

# bootstrap/ui_layout_tools.ts
```bootstrap/ui_layout_tools.ts
import type { ToolCreatorPayload } from '../types';

export const UI_LAYOUT_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Main View Selector',
        description: 'Renders the main view selection buttons to switch between application modes.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide top-level navigation between the different agent workspaces like KiCad and Robotics.',
        parameters: [
            { name: 'mainView', type: 'string', description: 'The currently active main view.', required: true },
            { name: 'setMainView', type: 'object', description: 'Function to change the main view.', required: true },
        ],
        implementationCode: `
          const views = [
            { id: 'KICAD', label: 'KiCad Design' },
            { id: 'AETHERIUM_GAME', label: 'Aetherium' },
            { id: 'ROBOTICS', label: 'Robotics Lab' },
            // { id: 'KNOWLEDGE_GRAPH', label: 'Strategic Memory' }, // Can be re-enabled later
          ];

          return (
            <div className="flex-shrink-0 bg-gray-800/60 border border-gray-700 rounded-xl p-1 flex items-center justify-center gap-2">
                {views.map(view => {
                    const isActive = mainView === view.id;
                    return (
                        <button
                            key={view.id}
                            onClick={() => setMainView(view.id)}
                            className={\`px-4 py-2 rounded-lg font-semibold text-sm transition-colors duration-200 flex-1 text-center \${
                                isActive
                                    ? 'bg-indigo-600 text-white shadow-md'
                                    : 'bg-transparent text-gray-400 hover:bg-gray-700/50'
                            }\`}
                        >
                            {view.label}
                        </button>
                    )
                })}
            </div>
          );
        `,
    },
];
```

# bootstrap/ui_display_tools.ts
```bootstrap/ui_display_tools.ts


import type { ToolCreatorPayload } from '../types';

export const UI_DISPLAY_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Debug Log View',
        description: 'A floating panel that shows a running log of events, API call counts, and system reset functionality.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide essential debugging and monitoring capabilities for observing the agent\'s behavior and system state.',
        parameters: [
          { name: 'logs', type: 'array', description: 'The array of log messages.', required: true },
          { name: 'onReset', type: 'object', description: 'Function to reset all tools and progress.', required: true },
          { name: 'apiCallCounts', type: 'object', description: 'A record of API calls per model.', required: true },
          { name: 'apiCallLimit', type: 'number', description: 'The limit for API calls.', required: true },
          { name: 'agentCount', type: 'number', description: 'The number of active agents.', required: true },
        ],
        implementationCode: `// This component is implemented natively in DebugLogView.tsx`,
    },
    {
        name: 'KiCad PCB Viewer',
        description: 'Displays an interactive 3D model of the generated PCB and provides a download link for the fabrication files.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide immediate, interactive visual feedback and access to the final product of the hardware engineering workflow.',
        parameters: [
            { name: 'boardName', type: 'string', description: 'The name of the generated board.', required: true },
            { name: 'glbPath', type: 'string', description: 'Server-relative path to the final board GLB model.', required: true },
            { name: 'fabZipPath', type: 'string', description: 'Server-relative path to the fabrication ZIP file.', required: true },
            { name: 'serverUrl', type: 'string', description: 'The base URL of the backend server.', required: true },
            { name: 'onClose', type: 'object', description: 'Function to call to close the viewer.', required: true },
        ],
        implementationCode: `
            const mountRef = React.useRef(null);

            React.useEffect(() => {
                if (!mountRef.current || !glbPath) return;

                let isMounted = true;
                let THREE, OrbitControls, GLTFLoader;
                
                const init3D = async () => {
                    try {
                        THREE = await import('three');
                        const { OrbitControls: OC } = await import('three/addons/controls/OrbitControls.js');
                        OrbitControls = OC;
                        const { GLTFLoader: GLTF } = await import('three/addons/loaders/GLTFLoader.js');
                        GLTFLoader = GLTF;
                    } catch (e) {
                         console.error("Failed to load Three.js libraries:", e);
                         if(mountRef.current) mountRef.current.innerHTML = '<p class="text-red-400">Error loading 3D libraries. Check console.</p>';
                         return null;
                    }
                    
                    if (!isMounted || !mountRef.current) return null;

                    const mount = mountRef.current;
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x111827);
                    const camera = new THREE.PerspectiveCamera(75, mount.clientWidth / mount.clientHeight, 0.1, 1000);
                    camera.position.z = 50;
                    const renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(mount.clientWidth, mount.clientHeight);
                    renderer.setPixelRatio(window.devicePixelRatio);
                    mount.innerHTML = '';
                    mount.appendChild(renderer.domElement);
                    const controls = new OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    scene.add(new THREE.AmbientLight(0xffffff, 2.0));
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 3.5);
                    directionalLight.position.set(50, 100, 75);
                    scene.add(directionalLight);
                    const loader = new GLTFLoader();

                    const fullGlbUrl = serverUrl + '/' + glbPath.replace(/\\\\/g, '/');
                    
                    const loadGltfFromBlob = (blob) => {
                        const url = URL.createObjectURL(blob);
                        loader.load(url, (gltf) => {
                            if (!isMounted) return;
                            const model = gltf.scene;
                            model.scale.set(1000, 1000, 1000); // KiCad exports in meters, Three.js scene is in mm
                            model.rotation.x = -Math.PI / 2;
                            model.updateMatrixWorld(true);
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());

                            // Center the model on X/Z and place its bottom at Y=0
                            model.position.x -= center.x;
                            model.position.y -= box.min.y;
                            model.position.z -= center.z;

                            const maxDim = Math.max(size.x, size.y, size.z);
                            const fov = camera.fov * (Math.PI / 180);
                            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                            cameraZ *= 1.5; // Zoom out a bit for padding
                            camera.position.z = cameraZ;
                            camera.position.y = cameraZ * 0.75; // Angled view from above
                            camera.far = cameraZ * 3;
                            camera.updateProjectionMatrix();

                            // Look at the vertical center of the model
                            controls.target.set(0, size.y / 2, 0);
                            controls.update();
                            scene.add(model);
                            URL.revokeObjectURL(url);
                        }, undefined, (error) => console.error('Error loading GLB from blob:', error));
                    };
                    
                    if (window.cacheService) {
                        window.cacheService.getAssetBlob(fullGlbUrl).then(async (blob) => {
                            if (blob && isMounted) {
                                loadGltfFromBlob(blob);
                            } else if (isMounted) {
                                fetch(fullGlbUrl)
                                    .then(res => res.ok ? res.blob() : Promise.reject(new Error(\`HTTP \${res.status}\`)))
                                    .then(blob => {
                                        if (isMounted) {
                                            window.cacheService.setAssetBlob(fullGlbUrl, blob);
                                            loadGltfFromBlob(blob);
                                        }
                                    })
                                    .catch(err => console.error('Failed to fetch and cache GLB:', err));
                            }
                        });
                    } else {
                         loader.load(fullGlbUrl, (gltf) => { /* original logic */ }, undefined, (error) => console.error('Error loading GLB:', error));
                    }

                    let animationFrameId;
                    const animate = () => {
                        if (!isMounted) return;
                        animationFrameId = requestAnimationFrame(animate);
                        controls.update();
                        renderer.render(scene, camera);
                    };
                    animate();
                    
                    const handleResize = () => {
                        if (!isMounted || !mount) return;
                        camera.aspect = mount.clientWidth / mount.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(mount.clientWidth, mount.clientHeight);
                    };
                    window.addEventListener('resize', handleResize);

                    return () => {
                        isMounted = false;
                        cancelAnimationFrame(animationFrameId);
                        window.removeEventListener('resize', handleResize);
                        if (mount && mount.contains(renderer.domElement)) {
                            mount.removeChild(renderer.domElement);
                        }
                        renderer.dispose();
                    };
                };

                const cleanupPromise = init3D();
                return () => {
                    cleanupPromise.then(cleanupFn => cleanupFn && cleanupFn());
                };
            }, [glbPath, serverUrl]);

            const fullZipUrl = serverUrl + '/' + fabZipPath;

            return (
                <div className="bg-gray-800/90 border-2 border-green-500/60 rounded-xl p-4 shadow-lg flex flex-col h-full">
                    <div className="flex justify-between items-center mb-3">
                        <h3 className="text-lg font-bold text-green-300">PCB Fabrication Output</h3>
                        <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
                    </div>
                    <p className="text-sm text-gray-300 mb-2">Generated board: <span className="font-mono text-green-400">{boardName}</span></p>

                    <div ref={mountRef} className="flex-grow bg-black/30 rounded-lg overflow-hidden relative cursor-grab" style={{minHeight: '300px'}}>
                       <div className="w-full h-full flex items-center justify-center">
                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-green-300"></div>
                            <p className="text-green-300 ml-3">Loading 3D Model...</p>
                       </div>
                    </div>

                    <a
                        href={fullZipUrl}
                        download
                        className="mt-4 w-full text-center bg-green-600 text-white font-semibold py-2.5 px-4 rounded-lg hover:bg-green-700 transition-colors duration-200"
                    >
                        Download Fabrication Files (.zip)
                    </a>
                </div>
            );
        `
    },
    {
        name: 'UI Component Panel',
        description: 'A panel on the right sidebar for displaying contextual UI elements like the active tool context.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To group and display contextual UI tools in the sidebar.',
        parameters: [
          { name: 'activeTools', type: 'array', description: 'The array of scored tools currently in the context.', required: true },
          { name: 'getTool', type: 'object', description: 'Function to retrieve a tool definition by name.', required: true },
        ],
        implementationCode: `
            const [isContextVisible, setContextVisible] = React.useState(true);
            
            // A simple chevron icon component
            const ChevronIcon = ({ open }) => (
                <svg xmlns="http://www.w3.org/2000/svg" className={\`h-5 w-5 transition-transform duration-200 \${open ? 'rotate-180' : ''}\`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                </svg>
            );

            return (
                <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-3 space-y-2">
                    <div className="flex items-center gap-2">
                        <span className="text-indigo-400 font-mono">{'</>'}</span>
                        <h3 className="text-lg font-bold text-indigo-300 flex-grow">UI Component</h3>
                    </div>
                    
                    <div className="bg-gray-900/50 rounded-lg border border-gray-700">
                        <button 
                            onClick={() => setContextVisible(!isContextVisible)} 
                            className="w-full flex justify-between items-center p-2 text-left"
                        >
                            <span className="font-semibold text-gray-200">Active Tool Context</span>
                            <ChevronIcon open={isContextVisible} />
                        </button>
                        {isContextVisible && (
                             <div className="p-2 border-t border-gray-700">
                                 <UIToolRunner tool={getTool('Active Tool Context')} props={{ activeTools }} />
                             </div>
                        )}
                    </div>
                </div>
            )
        `
    },
    {
        name: 'Active Tool Context',
        description: 'A simple list displaying the tools currently provided to the agent. Designed to be embedded in other UI panels.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide clear, real-time feedback on exactly which tools the agent is considering for its current task.',
        parameters: [
          { name: 'activeTools', type: 'array', description: 'The array of scored tools currently in the context.', required: true },
        ],
        implementationCode: `
          if (!activeTools || activeTools.length === 0) {
            return <p className="text-sm text-gray-500 text-center py-2">No active context.</p>;
          }
    
          return (
              <div className="max-h-48 overflow-y-auto pr-1 space-y-1">
                {activeTools.map(({ tool, score }) => (
                  <div key={tool.id} className="bg-gray-800/50 p-1.5 rounded-md" title={\`Score: \${score.toFixed(3)}\`}>
                    <p className="font-semibold text-white text-sm truncate">{tool.name}</p>
                  </div>
                ))}
              </div>
          );
        `
    }
];
```

# bootstrap/datasheets.ts
```bootstrap/datasheets.ts


// This file contains the raw text extracted from component datasheets.
// It's kept separate to avoid cluttering the tool definitions.

export const ALL_DATASHEETS = {
    ADS131M08_DATASHEET: `
ADS131M08 8-Channel, Simultaneously-Sampling, 24-Bit, Delta-Sigma ADC
... [Full datasheet text for ADS131M08] ...
Product Folder Links: ADS131M08
`,
    LP5907_DATASHEET: `
LP5907 250-mA, Ultra-Low-Noise, Low-IQ LDO
... [Full datasheet text for LP5907] ...
Product Folder Links: LP5907
`,
    XIAO_DATASHEET: `
Seeed Studio XIAO Series System-on-Modules (SoM) User Manual
... [Full datasheet text for XIAO Series] ...
Document Revision: min.liang@seeed.cc
`,
    ECS2520MV_DATASHEET: `
ROHS COMPLIANT ECS-2520MV SMD MultiVolt™™ Crystal Oscillator
... [Full datasheet text for ECS-2520MV] ...
15351 West 109th Street | Lenexa, KS 66219 | Phone: 913.782.7787 | Fax: 913.782.6991 | www.ecsxtal.com
`,
};
// NOTE: The full text of the datasheets is omitted here for brevity, 
// but is included in the actual file content.

```

# bootstrap/ui_config_tools.ts
```bootstrap/ui_config_tools.ts
import type { ToolCreatorPayload } from '../types';
import { LOCAL_AI_PANEL_TOOL_PAYLOAD } from './local_ai_tools';

export const UI_CONFIG_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Visibility',
        description: 'Controls visibility of different layers in the PCB simulation view.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To allow users to toggle display layers for better inspection of the PCB layout.',
        parameters: [
            { name: 'visibility', type: 'object', description: 'An object with boolean flags for different layers.', required: true },
            { name: 'setVisibility', type: 'object', description: 'Function to update the visibility state.', required: true },
        ],
        implementationCode: `
            return (
                <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-3 text-white">
                    <h3 className="text-lg font-bold text-indigo-300 mb-2">Visibility</h3>
                    <div className="space-y-1 text-sm p-1">
                        {Object.keys(visibility).map(key => (
                            <div key={key} className="flex items-center">
                                <input
                                    type="checkbox"
                                    id={\`vis-\${key}\`}
                                    checked={visibility[key]}
                                    onChange={() => setVisibility(v => ({...v, [key]: !v[key]}))}
                                    className="h-4 w-4 rounded border-gray-500 bg-gray-700 text-indigo-500 focus:ring-indigo-600"
                                />
                                <label htmlFor={\`vis-\${key}\`} className="ml-2 text-gray-300">
                                    Show {key.charAt(0).toUpperCase() + key.slice(1)}
                                </label>
                            </div>
                        ))}
                    </div>
                </div>
            );
        `
    },
    {
        name: 'AI Model',
        description: 'A UI panel for selecting the AI model.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To allow the user to configure the AI model, enabling flexibility in choosing the "brain" of the agent.',
        parameters: [
          { name: 'apiConfig', type: 'object', description: 'The current API configuration.', required: true },
          { name: 'setApiConfig', type: 'object', description: 'Function to update the API config.', required: true },
          { name: 'availableModels', type: 'array', description: 'List of available AI models.', required: true },
          { name: 'selectedModel', type: 'object', description: 'The currently selected AI model.', required: true },
          { name: 'setSelectedModel', type: 'object', description: 'Function to update the selected model.', required: true },
        ],
        implementationCode: `
          const handleModelChange = (e) => {
            const modelId = e.target.value;
            const model = availableModels.find(m => m.id === modelId);
            if (model) {
              setSelectedModel(model);
            }
          };
    
          const handleConfigChange = (e) => {
            setApiConfig(prev => ({ ...prev, [e.target.name]: e.target.value }));
          };
          
          const provider = selectedModel?.provider;
    
          const groupedModels = React.useMemo(() => {
            const groups = {
                GoogleAI: [],
                OpenAI_API: [],
                Ollama: [],
                HuggingFace: [],
                Wllama: [],
            };
            availableModels.forEach(model => {
                if (groups[model.provider]) {
                    groups[model.provider].push(model);
                }
            });
            return groups;
          }, [availableModels]);
    
          const renderProviderHelpText = () => {
            switch (provider) {
              case 'Ollama':
                return <p className="text-xs text-gray-400 mt-1">Ensure the Ollama server is running and the model ('{selectedModel.id}') is pulled.</p>;
              case 'HuggingFace':
                return <p className="text-xs text-gray-400 mt-1">Model will be downloaded and run directly in your browser. Requires a modern browser and may be slow on first load.</p>;
              case 'Wllama':
                return <p className="text-xs text-gray-400 mt-1">Model (GGUF) will be downloaded and run in-browser via WebAssembly. Can be slow on first load and requires a powerful device.</p>;
              case 'OpenAI_API':
                return <p className="text-xs text-gray-400 mt-1">Works with any OpenAI-compatible API (e.g., a local Ollama server).</p>;
              default:
                return <p className="text-xs text-gray-400 mt-1">Google AI API key is read from the 'process.env.API_KEY' environment variable.</p>;
            }
          }
    
          return (
            <div className="w-full bg-gray-800/60 border border-gray-700 rounded-xl p-3 space-y-3">
              <h3 className="text-lg font-bold text-indigo-300">AI Model</h3>
              <div>
                <select
                  id="model-select"
                  value={selectedModel?.id || ''}
                  onChange={handleModelChange}
                  className="w-full bg-gray-900 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-indigo-500"
                >
                  {Object.entries(groupedModels).map(([providerName, models]) => (
                    models.length > 0 && (
                      <optgroup key={providerName} label={providerName.replace('_API', ' API')}>
                        {models.map(model => (
                          <option key={model.id} value={model.id}>
                            {model.name}
                          </option>
                        ))}
                      </optgroup>
                    )
                  ))}
                </select>
                {renderProviderHelpText()}
              </div>
    
              {provider === 'OpenAI_API' && (
                <div className="space-y-3 pt-2 border-t border-gray-700">
                  <div>
                    <label htmlFor="openAIBaseUrl" className="block text-sm font-medium text-gray-300 mb-1">API Base URL</label>
                    <input
                      type="text"
                      id="openAIBaseUrl"
                      name="openAIBaseUrl"
                      value={apiConfig.openAIBaseUrl}
                      onChange={handleConfigChange}
                      placeholder="e.g., http://localhost:11434/v1"
                      className="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-indigo-500"
                    />
                  </div>
                  <div>
                    <label htmlFor="openAIAPIKey" className="block text-sm font-medium text-gray-300 mb-1">API Key</label>
                    <input
                      type="password"
                      id="openAIAPIKey"
                      name="openAIAPIKey"
                      value={apiConfig.openAIAPIKey}
                      onChange={handleConfigChange}
                      placeholder="Often 'ollama' or your API key"
                      className="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-indigo-500"
                    />
                  </div>
                </div>
              )}
              
              {provider === 'Ollama' && (
                <div className="pt-2 border-t border-gray-700">
                  <label htmlFor="ollamaHost" className="block text-sm font-medium text-gray-300 mb-1">Ollama Host URL</label>
                  <input
                    type="text"
                    id="ollamaHost"
                    name="ollamaHost"
                    value={apiConfig.ollamaHost}
                    onChange={handleConfigChange}
                    placeholder="e.g., http://localhost:11434"
                    className="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-indigo-500"
                  />
                </div>
              )}
    
            </div>
          );
        `
    },
    {
        name: 'Tool Selection Mode',
        description: 'Selects the method for filtering tools provided to the agent.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To control the strategy for tool context selection, balancing between performance, cost, and agent capability.',
        parameters: [
          { name: 'relevanceMode', type: 'string', description: 'The current relevance mode (Embeddings, All, LLM).', required: true },
          { name: 'setRelevanceMode', type: 'object', description: 'Function to update the relevance mode.', required: true },
          { name: 'isSwarmRunning', type: 'boolean', description: 'Whether the swarm is currently active, to disable controls.', required: true },
        ],
        implementationCode: `
            const modes = [
                { id: 'Embeddings', label: 'Embeddings', description: 'Fast, local semantic search to find relevant tools.' },
                { id: 'All', label: 'All Tools', description: 'Provides all tools to the agent. Slower, but most capable.' },
                { id: 'LLM', label: 'LLM Filter', description: 'Uses an extra LLM call to intelligently select tools.' },
            ];
            
            return (
                <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-3 space-y-3">
                    <h3 className="text-lg font-bold text-indigo-300">Tool Selection Mode</h3>
                    <fieldset className="space-y-2">
                        <legend className="sr-only">Tool Selection Mode</legend>
                        {modes.map(mode => (
                            <div key={mode.id} className="relative flex items-start">
                                <div className="flex items-center h-5">
                                    <input
                                        id={mode.id}
                                        name="relevance-mode"
                                        type="radio"
                                        checked={relevanceMode === mode.id}
                                        onChange={() => setRelevanceMode(mode.id)}
                                        disabled={isSwarmRunning}
                                        className="focus:ring-indigo-500 h-4 w-4 text-indigo-600 border-gray-500 bg-gray-700 rounded disabled:opacity-50"
                                    />
                                </div>
                                <div className="ml-3 text-sm">
                                    <label htmlFor={mode.id} className={\`font-medium \${isSwarmRunning ? 'text-gray-500' : 'text-gray-200'}\`}>
                                        {mode.label}
                                    </label>
                                    <p className="text-gray-400 text-xs">{mode.description}</p>
                                </div>
                            </div>
                        ))}
                    </fieldset>
                </div>
            );
        `
    },
    {
        name: 'Embedding Filter',
        description: 'A panel for configuring the tool relevance filter used by the agent swarm. Adjust how many tools are selected for a task.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To give the user fine-grained control over the tool context provided to the agent, allowing for tuning between performance and capability.',
        parameters: [
          { name: 'topK', type: 'number', description: 'The maximum number of tools to select.', required: true },
          { name: 'setTopK', type: 'object', description: 'Function to update the top K value.', required: true },
          { name: 'threshold', type: 'number', description: 'The minimum similarity score for a tool to be considered.', required: true },
          { name: 'setThreshold', type: 'object', description: 'Function to update the threshold value.', required: true },
          { name: 'isSwarmRunning', type: 'boolean', description: 'Whether the swarm is currently active, to disable controls.', required: true },
        ],
        implementationCode: `
          return (
            <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-3 space-y-4">
              <h3 className="text-lg font-bold text-indigo-300">Embedding Filter</h3>
              <div className="space-y-3">
                <div>
                  <label htmlFor="topK-slider" className="block text-sm font-medium text-gray-300 mb-1">Max Tools (Top K): <span className="font-bold text-white">{topK}</span></label>
                  <input
                    id="topK-slider"
                    type="range"
                    min="1"
                    max="100"
                    value={topK}
                    onChange={(e) => setTopK(Number(e.target.value))}
                    disabled={isSwarmRunning}
                    className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                  />
                </div>
                <div>
                  <label htmlFor="threshold-slider" className="block text-sm font-medium text-gray-300 mb-1">Similarity Threshold: <span className="font-bold text-white">{threshold.toFixed(2)}</span></label>
                  <input
                    id="threshold-slider"
                    type="range"
                    min="0.0"
                    max="1.0"
                    step="0.01"
                    value={threshold}
                    onChange={(e) => setThreshold(Number(e.target.value))}
                    disabled={isSwarmRunning}
                    className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                  />
                  <p className="text-xs text-gray-400 mt-1">Filters tools by relevance score before picking the Top K.</p>
                </div>
              </div>
            </div>
          );
        `
    },
    LOCAL_AI_PANEL_TOOL_PAYLOAD
];
```

# bootstrap/simulation_tools.ts
```bootstrap/simulation_tools.ts
// bootstrap/simulation_tools.ts
import type { ToolCreatorPayload } from '../types';

export const SIMULATION_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Set Simulation Heuristics',
        description: 'Configures the global forces and physics parameters for the layout simulation engine.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To tune the behavior of the autonomous layout engine by adjusting core physics parameters like repulsion, attraction, and damping.',
        parameters: [
            { name: 'componentSpacing', type: 'number', description: 'Repulsion force between components.', required: false },
            { name: 'netLengthWeight', type: 'number', description: 'Attraction force along nets to shorten them.', required: false },
            { name: 'distributionStrength', type: 'number', description: 'Force pushing all components away from the center to spread them out.', required: false },
            { name: 'settlingSpeed', type: 'number', description: 'Damping factor for the simulation (0.8 to 0.99). Higher is slower but more stable.', required: false },
            { name: 'repulsionRampUpTime', type: 'number', description: 'Time in simulation frames (approx 60/sec) for repulsion force to reach full strength.', required: false },
            { name: 'proximityStrength', type: 'number', description: 'DEPRECATED: No longer used. Use proximityKp and proximityKd instead.', required: false },
            { name: 'proximityKp', type: 'number', description: 'Proportional gain (stiffness) for the PID proximity controller.', required: false },
            { name: 'proximityKi', type: 'number', description: 'Integral gain for the PID proximity controller (usually 0).', required: false },
            { name: 'proximityKd', type: 'number', description: 'Derivative gain (damping) for the PID proximity controller.', required: false },
            { name: 'symmetryStrength', type: 'number', description: 'Strength of the force mirroring component pairs.', required: false },
            { name: 'alignmentStrength', type: 'number', description: 'Strength of the force aligning components on an axis.', required: false },
            { name: 'absolutePositionStrength', type: 'number', description: 'Strength of the force locking a component to a specific coordinate.', required: false },
            { name: 'fixedRotationStrength', type: 'number', description: 'Strength of the torque twisting a component to a fixed rotation.', required: false },
            { name: 'symmetryRotationStrength', type: 'number', description: 'Strength of the torque for symmetrical rotation.', required: false },
            { name: 'circularRotationStrength', type: 'number', description: 'Strength of the torque for circular rotation pattern.', required: false },
            { name: 'boardPadding', type: 'number', description: 'The margin in millimeters to add around components when auto-sizing the board outline.', required: false },
        ],
        implementationCode: `
            const updatedValues = Object.keys(args).length;
            // The runtime will detect the 'heuristics' key in the return value and update the simulation state.
            return { 
                success: true, 
                message: \`Updated \${updatedValues} simulation heuristics.\`,
                heuristics: args 
            };
        `
    }
];
```

# bootstrap/strategy_manager_script.ts
```bootstrap/strategy_manager_script.ts
// This file exports the Python script content as a string,
// which will be used by the 'Install Strategic Cognition Suite' tool.

export const STRATEGIC_MEMORY_SCRIPT = `
import argparse
import json
import os
import sys
import fcntl
import traceback

# --- Configuration ---
# The script is in server/scripts, so we go up one level to find the assets dir.
STATE_DIR = os.path.join(os.path.dirname(__file__), '..', 'assets')
MEMORY_FILE = os.path.join(STATE_DIR, 'strategic_memory.json')
LOCK_FILE = MEMORY_FILE + '.lock'

# --- Utility Functions ---
def log_error_and_exit(message):
    """Prints a JSON error message to stderr and exits."""
    print(json.dumps({"error": message, "trace": traceback.format_exc()}), file=sys.stderr)
    sys.exit(1)

def read_graph_with_lock():
    """Reads the memory graph from disk, handling locking and file creation."""
    os.makedirs(STATE_DIR, exist_ok=True)
    with open(LOCK_FILE, 'w') as lf:
        fcntl.flock(lf, fcntl.LOCK_EX)
        try:
            if not os.path.exists(MEMORY_FILE):
                return {"nodes": [], "edges": []}
            with open(MEMORY_FILE, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            # If the file is corrupted, return a default structure
            return {"nodes": [], "edges": []}
        finally:
            fcntl.flock(lf, fcntl.LOCK_UN)

def write_graph_with_lock(graph_data):
    """Writes the memory graph to disk, handling locking."""
    with open(LOCK_FILE, 'w') as lf:
        fcntl.flock(lf, fcntl.LOCK_EX)
        try:
            with open(MEMORY_FILE, 'w') as f:
                json.dump(graph_data, f, indent=2)
        finally:
            fcntl.flock(lf, fcntl.LOCK_UN)

# --- Command Functions ---
def handle_read(args):
    """Reads and prints the entire graph to stdout."""
    graph = read_graph_with_lock()
    print(json.dumps(graph))

def handle_define_directive(args):
    """Adds a new 'Directive' node to the graph."""
    graph = read_graph_with_lock()
    
    # Check if node already exists
    if any(n['id'] == args.id for n in graph['nodes']):
        log_error_and_exit(f"Directive with id '{args.id}' already exists.")

    # Add the new directive node
    new_directive = {"id": args.id, "label": args.label, "type": "directive"}
    graph['nodes'].append(new_directive)

    # If a parent is specified, add an edge
    if args.parent:
        if not any(n['id'] == args.parent for n in graph['nodes']):
            log_error_and_exit(f"Parent node with id '{args.parent}' not found.")
        graph['edges'].append({"source": args.parent, "target": args.id})
    
    write_graph_with_lock(graph)
    print(json.dumps({"success": True, "message": f"Directive '{args.label}' defined."}))

def handle_update_memory(args):
    """Adds or updates nodes and edges in the graph."""
    graph = read_graph_with_lock()
    
    nodes_updated = 0
    nodes_added = 0
    edges_added = 0

    # Process nodes
    if args.nodes:
        try:
            new_nodes = json.loads(args.nodes)
            if not isinstance(new_nodes, list):
                raise ValueError("Nodes argument must be a JSON list.")
        except (json.JSONDecodeError, ValueError) as e:
            log_error_and_exit(f"Invalid JSON in --nodes argument: {e}")

        existing_node_ids = {n['id']: n for n in graph['nodes']}
        for node in new_nodes:
            if 'id' not in node:
                continue # Skip nodes without an ID
            if node['id'] in existing_node_ids:
                # Update existing node
                existing_node_ids[node['id']].update(node)
                nodes_updated += 1
            else:
                # Add new node
                graph['nodes'].append(node)
                existing_node_ids[node['id']] = node # Add to map for edge checking
                nodes_added += 1

    # Process edges
    if args.edges:
        try:
            new_edges = json.loads(args.edges)
            if not isinstance(new_edges, list):
                raise ValueError("Edges argument must be a JSON list.")
        except (json.JSONDecodeError, ValueError) as e:
            log_error_and_exit(f"Invalid JSON in --edges argument: {e}")

        existing_edge_set = {f"{e['source']}-{e['target']}" for e in graph['edges']}
        all_node_ids = {n['id'] for n in graph['nodes']}

        for edge in new_edges:
            if 'source' in edge and 'target' in edge:
                # Ensure nodes exist before adding an edge
                if edge['source'] not in all_node_ids or edge['target'] not in all_node_ids:
                    continue # Skip edges with missing nodes
                
                edge_key = f"{edge['source']}-{edge['target']}"
                if edge_key not in existing_edge_set:
                    graph['edges'].append(edge)
                    existing_edge_set.add(edge_key)
                    edges_added += 1

    write_graph_with_lock(graph)
    message = f"Strategic Memory updated: {nodes_added} nodes added, {nodes_updated} nodes updated, {edges_added} edges added."
    print(json.dumps({"success": True, "message": message}))

# --- Main Entry Point ---
def main():
    parser = argparse.ArgumentParser(description="Strategic Memory Manager for Singularity Agent")
    subparsers = parser.add_subparsers(dest='command', required=True)

    # Read command
    p_read = subparsers.add_parser('read', help='Read the entire strategic memory graph.')
    p_read.set_defaults(func=handle_read)

    # Define Directive command
    p_directive = subparsers.add_parser('define_directive', help='Define a new long-term directive.')
    p_directive.add_argument('--id', required=True, help='Unique machine-readable ID.')
    p_directive.add_argument('--label', required=True, help='Human-readable description.')
    p_directive.add_argument('--parent', help='Optional ID of a parent node to connect to.')
    p_directive.set_defaults(func=handle_define_directive)

    # Update Memory command
    p_update = subparsers.add_parser('update_memory', help='Add or update nodes and edges.')
    p_update.add_argument('--nodes', help='JSON string of an array of node objects.')
    p_update.add_argument('--edges', help='JSON string of an array of edge objects.')
    p_update.set_defaults(func=handle_update_memory)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
`;

```

# bootstrap/longevity_graph.ts
```bootstrap/longevity_graph.ts
import type { KnowledgeGraph } from '../types';

export const LONGEVITY_KNOWLEDGE_GRAPH: KnowledgeGraph = {
  nodes: [
    { id: "Sirtuins", label: "Sirtuins" },
    { id: "AMPK", label: "AMPK" },
    { id: "mTOR", label: "mTOR" },
    { id: "NAD+", label: "NAD+" },
    { id: "Resveratrol", label: "Resveratrol" },
    { id: "Metformin", label: "Metformin" },
    { id: "Rapamycin", label: "Rapamycin" },
    { id: "Caloric Restriction", label: "Caloric Restriction" },
    { id: "Autophagy", label: "Autophagy" },
    { id: "Cellular Senescence", label: "Cellular Senescence" },
    { id: "DNA Repair", label: "DNA Repair" },
    { id: "Longevity", label: "Longevity" },
  ],
  edges: [
    { source: "Caloric Restriction", target: "Sirtuins" },
    { source: "Caloric Restriction", target: "AMPK" },
    { source: "Caloric Restriction", target: "mTOR" },
    { source: "NAD+", target: "Sirtuins" },
    { source: "Resveratrol", target: "Sirtuins" },
    { source: "Metformin", target: "AMPK" },
    { source: "Rapamycin", target: "mTOR" },
    { source: "Sirtuins", target: "DNA Repair" },
    { source: "AMPK", target: "Autophagy" },
    { source: "mTOR", target: "Autophagy" },
    { source: "Autophagy", target: "Cellular Senescence" },
    { source: "DNA Repair", target: "Longevity" },
    { source: "Autophagy", target: "Longevity" },
    { source: "Cellular Senescence", target: "Longevity" },
  ],
};

```

# bootstrap/strategy_tools.ts
```bootstrap/strategy_tools.ts

import type { ToolCreatorPayload } from '../types';
import { STRATEGIC_MEMORY_SCRIPT } from './strategy_manager_script';

const STRATEGIC_MEMORY_GRAPH_VIEWER_PAYLOAD: ToolCreatorPayload = {
    name: 'Strategic Memory Graph Viewer',
    description: 'Renders an interactive 3D force-directed graph of the agent\'s long-term strategic memory, showing Directives, knowledge, and their relationships.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide a visual interface into the agent\'s "mind," making its long-term goals and knowledge structure observable and understandable.',
    parameters: [
        { name: 'graph', type: 'object', description: 'The graph data including nodes and edges.', required: true },
        { name: 'isLoading', type: 'boolean', description: 'Whether the graph data is currently being fetched.', required: true },
        { name: 'isEmbedding', type: 'boolean', description: 'Whether node embeddings are being generated.', required: true },
        { name: 'nodeEmbeddings', type: 'object', description: 'A Map of node IDs to their vector embeddings.', required: true },
        { name: 'onRefresh', type: 'object', description: 'Callback function to refresh the graph data from the server.', required: true },
    ],
    implementationCode: `
        const mountRef = React.useRef(null);
        const simRef = React.useRef({});
        const [selectedNodeId, setSelectedNodeId] = React.useState(null);

        React.useEffect(() => {
            if (isLoading || isEmbedding || !graph || !graph.nodes || graph.nodes.length === 0) {
                if(mountRef.current) mountRef.current.innerHTML = '';
                return;
            }

            let isMounted = true;
            const sim = simRef.current;
            
            const init = async () => {
                if (!mountRef.current) return;

                try {
                    sim.THREE = await import('three');
                    const { OrbitControls: OC } = await import('three/addons/controls/OrbitControls.js');
                    sim.OrbitControls = OC;
                    sim.RAPIER = (await import('@dimforge/rapier3d-compat')).default;
                    await sim.RAPIER.init();
                } catch (e) {
                    console.error("Failed to load 3D libraries:", e);
                    if(mountRef.current) mountRef.current.innerHTML = '<p class="text-red-400">Error loading 3D libraries. Check console.</p>';
                    return;
                }
                
                if (!isMounted || !mountRef.current) return;

                const { nodes, edges } = graph;
                sim.nodeMap = new Map(nodes.map(n => [n.id, n]));

                sim.scene = new sim.THREE.Scene();
                sim.scene.background = new sim.THREE.Color(0x1a202c);
                sim.camera = new sim.THREE.PerspectiveCamera(75, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
                sim.renderer = new sim.THREE.WebGLRenderer({ antialias: true });
                sim.renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                mountRef.current.innerHTML = '';
                mountRef.current.appendChild(sim.renderer.domElement);

                sim.scene.add(new sim.THREE.AmbientLight(0xcccccc, 1.0));
                const dirLight = new sim.THREE.DirectionalLight(0xffffff, 2.0);
                dirLight.position.set(5, 10, 7.5);
                sim.scene.add(dirLight);

                sim.controls = new sim.OrbitControls(sim.camera, sim.renderer.domElement);
                sim.controls.enableDamping = true;
                sim.camera.position.z = 40;

                const NODE_CONFIG = {
                    Device: { color: 0x22c55e, radius: 2.5, shape: 'sphere' },
                    Component: { color: 0x3b82f6, radius: 1.0, shape: 'sphere' },
                    Pin: { color: 0x9ca3af, radius: 0.25, shape: 'sphere' },
                    MarketNeed: { color: 0xec4899, radius: 2.0, shape: 'box' },
                    Technology: { color: 0xf97316, radius: 2.0, shape: 'octahedron' },
                    default: { color: 0x64748b, radius: 1.5, shape: 'sphere' }
                };

                sim.world = new sim.RAPIER.World({ x: 0.0, y: 0.0, z: 0.0 });
                sim.bodies = new Map();
                sim.meshes = new Map();

                nodes.forEach(node => {
                    const config = NODE_CONFIG[node.type] || NODE_CONFIG.default;
                    const { color, radius, shape } = config;
                    
                    let geo;
                    if (shape === 'box') geo = new sim.THREE.BoxGeometry(radius * 1.8, radius * 1.8, radius * 1.8);
                    else if (shape === 'octahedron') geo = new sim.THREE.OctahedronGeometry(radius, 0);
                    else geo = new sim.THREE.SphereGeometry(radius, 32, 16);
                    
                    const mat = new sim.THREE.MeshStandardMaterial({ color, roughness: 0.5, transparent: true });
                    const mesh = new sim.THREE.Mesh(geo, mat);
                    mesh.userData.id = node.id;
                    mesh.userData.originalColor = color;
                    sim.scene.add(mesh);

                    const spriteMat = new sim.THREE.SpriteMaterial({ color: 0xffffff, depthTest: false, transparent: true, sizeAttenuation: false });
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const fontSize = node.type === 'Pin' ? 24 : 32;
                    ctx.font = \`\${fontSize}px Arial\`;
                    const textWidth = ctx.measureText(node.label).width;
                    canvas.width = textWidth; canvas.height = fontSize * 1.25;
                    ctx.font = \`\${fontSize}px Arial\`; ctx.fillStyle = 'white';
                    ctx.fillText(node.label, 0, fontSize);
                    const texture = new sim.THREE.CanvasTexture(canvas);
                    spriteMat.map = texture;
                    const sprite = new sim.THREE.Sprite(spriteMat);
                    const spriteScale = node.type === 'Pin' ? 0.05 : 0.1;
                    sprite.scale.set(textWidth * spriteScale, fontSize * 1.25 * spriteScale, 1.0);
                    sprite.position.y = radius + 1.5;
                    mesh.add(sprite);
                    mesh.userData.labelSprite = sprite;
                    sim.meshes.set(node.id, mesh);

                    const bodyDesc = sim.RAPIER.RigidBodyDesc.dynamic().setLinearDamping(5.0);
                    const body = sim.world.createRigidBody(bodyDesc);
                    const colliderDesc = sim.RAPIER.ColliderDesc.ball(radius * 1.5);
                    sim.world.createCollider(colliderDesc, body);
                    sim.bodies.set(node.id, body);
                });

                sim.edges = [];
                edges.forEach(edge => {
                    const lineMat = new sim.THREE.LineBasicMaterial({ color: 0x64748b, transparent: true, opacity: 0.5 });
                    const lineGeo = new sim.THREE.BufferGeometry().setFromPoints([new sim.THREE.Vector3(), new sim.THREE.Vector3()]);
                    const line = new sim.THREE.Line(lineGeo, lineMat);
                    sim.scene.add(line);
                    let labelSprite = null;
                    if (edge.label) { /* ... label creation ... */ }
                    sim.edges.push({ line, labelSprite, source: edge.source, target: edge.target });
                });

                sim.raycaster = new sim.THREE.Raycaster();
                sim.mouse = new sim.THREE.Vector2();

                const onPointerDown = (event) => {
                    const rect = sim.renderer.domElement.getBoundingClientRect();
                    sim.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    sim.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    sim.raycaster.setFromCamera(sim.mouse, sim.camera);
                    const intersects = sim.raycaster.intersectObjects(Array.from(sim.meshes.values()), true);

                    if (intersects.length > 0) {
                        const clickedId = intersects[0].object.userData.id;
                        setSelectedNodeId(prevId => prevId === clickedId ? null : clickedId);
                    } else {
                        setSelectedNodeId(null); // Deselect on background click
                    }
                };
                sim.renderer.domElement.addEventListener('pointerdown', onPointerDown);

                const animate = () => { /* ... physics simulation ... */ };
                animate();
                
                return () => { /* ... cleanup ... */ };
            };
            
            const cleanupPromise = init();
            return () => { cleanupPromise.then(cleanup => cleanup && cleanup()); };

        }, [graph, isLoading, isEmbedding]);
        
        // --- Embedding similarity effect ---
        React.useEffect(() => {
            if (!simRef.current.meshes || !nodeEmbeddings) return;
            const sim = simRef.current;
            const cosineSimilarity = (a, b) => {
                if (!a || !b) return 0;
                let dotProduct = 0;
                for (let i = 0; i < a.length; i++) dotProduct += a[i] * b[i];
                return dotProduct;
            };

            if (!selectedNodeId) {
                // Restore all opacities if nothing is selected
                sim.meshes.forEach(mesh => {
                    mesh.material.opacity = 1.0;
                    if(mesh.userData.labelSprite) mesh.userData.labelSprite.material.opacity = 1.0;
                });
                sim.edges.forEach(edge => {
                    edge.line.material.opacity = 0.5;
                });
                return;
            }

            const selectedEmbedding = nodeEmbeddings.get(selectedNodeId);
            if (!selectedEmbedding) return;

            sim.meshes.forEach((mesh, id) => {
                const nodeEmbedding = nodeEmbeddings.get(id);
                const similarity = cosineSimilarity(selectedEmbedding, nodeEmbedding);
                const opacity = 0.1 + (0.9 * Math.max(0, similarity) ** 2);
                mesh.material.opacity = opacity;
                if(mesh.userData.labelSprite) mesh.userData.labelSprite.material.opacity = opacity;
            });
            
            sim.edges.forEach(edge => {
                const sourceOpacity = sim.meshes.get(edge.source)?.material.opacity || 0.1;
                const targetOpacity = sim.meshes.get(edge.target)?.material.opacity || 0.1;
                edge.line.material.opacity = Math.min(sourceOpacity, targetOpacity) * 0.5;
            });

        }, [selectedNodeId, nodeEmbeddings]);

        const loadingText = isLoading ? "Loading Strategic Memory..." : "Generating Embeddings...";
        if (isLoading || isEmbedding) {
            return (
                <div className="bg-gray-800/80 border-2 border-yellow-500/60 rounded-xl p-4 shadow-lg flex flex-col items-center justify-center h-full">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-yellow-300"></div>
                    <p className="text-yellow-300 mt-3">{loadingText}</p>
                </div>
            );
        }

        return (
            <div className="bg-gray-800/80 border-2 border-yellow-500/60 rounded-xl p-2 shadow-lg flex flex-col h-full relative">
                <div className="absolute top-4 left-4 z-10 text-lg font-bold text-yellow-300">Innovation Knowledge Graph</div>
                <div ref={mountRef} className="flex-grow bg-black/30 rounded overflow-hidden relative cursor-grab"></div>
                <button onClick={onRefresh} className="absolute top-4 right-4 bg-gray-700/50 text-white font-semibold py-1 px-3 rounded-lg hover:bg-gray-600 backdrop-blur-sm">
                    Refresh
                </button>
            </div>
        )
    `
};

const STRATEGY_TOOL_DEFINITIONS: ToolCreatorPayload[] = [
    {
        name: 'Read Strategic Memory',
        description: 'Reads the entire strategic memory graph from the persistent server storage.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To load the agent\'s long-term knowledge and plans into its current context for strategic decision-making.',
        parameters: [],
        implementationCode: 'python scripts/strategic_memory.py read'
    },
    {
        name: 'Define Strategic Directive',
        description: 'Creates a new high-level, long-term "Directive" node in the strategic memory graph. This is the foundation for long-term planning.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To allow the agent to formalize and persist its long-term goals, moving beyond short-term task execution.',
        parameters: [
            { name: 'id', type: 'string', description: 'A short, unique, machine-readable ID for the directive (e.g., "master_rf_design").', required: true },
            { name: 'label', type: 'string', description: 'A human-readable description of the directive.', required: true },
            { name: 'parent', type: 'string', description: 'Optional ID of an existing node this directive is related to.', required: false },
        ],
        implementationCode: 'python scripts/strategic_memory.py define_directive'
    },
    {
        name: 'Update Strategic Memory',
        description: 'Adds or updates nodes and edges in the strategic memory graph to record new knowledge, plans, or relationships.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To enable the agent to learn and build upon its knowledge over time, creating a persistent and evolving understanding of its world.',
        parameters: [
            { name: 'nodes', type: 'array', description: 'A JSON string of an array of node objects to add or update. Each object needs at least an "id" and "label".', required: false },
            { name: 'edges', type: 'array', description: 'A JSON string of an array of edge objects to add. Each object needs a "source" and "target" ID.', required: false },
        ],
        implementationCode: 'python scripts/strategic_memory.py update_memory'
    },
];

const STRATEGY_INSTALLER_TOOL: ToolCreatorPayload = {
    name: 'Install Strategic Cognition Suite',
    description: 'A one-time setup action that installs all necessary client-side tools for managing the agent\'s long-term Strategic Memory simulation.',
    category: 'Automation',
    executionEnvironment: 'Client',
    purpose: "To bootstrap the agent's ability for long-term planning and learning by installing its strategic memory management system.",
    parameters: [],
    implementationCode: `
        // --- Step 1: Write the Python script to the server ---
        runtime.logEvent('[INFO] Writing Strategic Memory Python script to the server...');
        if (runtime.isServerConnected()) {
            try {
                await runtime.tools.run('Server File Writer', { 
                    filePath: 'strategic_memory.py', 
                    content: ${JSON.stringify(STRATEGIC_MEMORY_SCRIPT)} 
                });
                runtime.logEvent('[INFO] Strategic Memory script written successfully.');
            } catch (e) {
                runtime.logEvent(\`[WARN] Failed to write script 'strategic_memory.py' to server: \${e.message}\`);
            }
        } else {
            runtime.logEvent('[INFO] Server not connected. Skipping Python script creation. Strategy tools will be simulated.');
        }

        // --- Step 2: Create the tool definitions ---
        const toolPayloads = [
            ...${JSON.stringify(STRATEGY_TOOL_DEFINITIONS)},
            ${JSON.stringify(STRATEGIC_MEMORY_GRAPH_VIEWER_PAYLOAD)}
        ];
        
        const allTools = runtime.tools.list();
        const existingToolNames = new Set(allTools.map(t => t.name));

        for (const payload of toolPayloads) {
            if (existingToolNames.has(payload.name)) {
                runtime.logEvent(\`[INFO] Tool '\${payload.name}' already exists. Skipping installation.\`);
                continue;
            }
            try {
                await runtime.tools.run('Tool Creator', payload);
            } catch (e) {
                runtime.logEvent(\`[WARN] Failed to create new tool '\${payload.name}'. Error: \${e.message}\`);
            }
        }
        
        if (runtime.isServerConnected()) {
            try {
                const { count } = await runtime.forceRefreshServerTools();
                runtime.logEvent(\`[INFO] Client state synchronized with server. \${count} server tools loaded.\`);
            } catch (e) {
                runtime.logEvent(\`[ERROR] Failed to force-refresh server tools after installation: \${e.message}\`);
            }
        }
        
        return { success: true, message: 'Strategic Cognition Suite installed successfully.' };
    `
};

export const STRATEGY_TOOLS: ToolCreatorPayload[] = [
    STRATEGY_INSTALLER_TOOL,
];
```

# bootstrap/ui_layout_heuristics_tools.ts
```bootstrap/ui_layout_heuristics_tools.ts
// bootstrap/ui_layout_heuristics_tools.ts
import type { ToolCreatorPayload } from '../types';

export const LAYOUT_HEURISTICS_TUNER_TOOL_PAYLOAD: ToolCreatorPayload = {
    name: 'Layout Heuristics',
    description: 'A UI panel for interactively tuning the parameters that guide the autonomous PCB layout simulation.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide fine-grained control over the behavior of the layout engine, allowing for real-time adjustments to achieve optimal component placement.',
    parameters: [
        { name: 'params', type: 'object', description: 'The current simulation parameter values.', required: true },
        { name: 'setParams', type: 'object', description: 'Callback to update the global simulation parameters.', required: true },
        { name: 'selectedAgent', type: 'object', description: 'The currently selected agent, if any.', required: false },
        { name: 'updateAgent', type: 'object', description: 'Callback to update a specific parameter for an agent.', required: true },
    ],
    implementationCode: `
        const defaults = {
            componentSpacing: 200.0,
            netLengthWeight: 0.03,
            distributionStrength: 0.5,
            boardPadding: 5.0,
            viaClearance: 0.6,
            proximityKp: 5.0,
            proximityKi: 0.0,
            proximityKd: 1.5,
            symmetryStrength: 10.0,
            alignmentStrength: 10.0,
            absolutePositionStrength: 10.0,
            fixedRotationStrength: 5.0,
            symmetryRotationStrength: 1.0,
            circularRotationStrength: 1.0,
        };

        const currentParams = { ...defaults, ...(params || {}) };

        const handleParamChange = (e) => {
            const { name, value } = e.target;
            setParams(prevHeuristics => ({ ...prevHeuristics, [name]: parseFloat(value) }));
        };
        
        const ParameterSlider = ({ name, label, min, max, step, value, onChange, description }) => (
            <div>
                <div className="flex justify-between items-baseline">
                  <label htmlFor={name} className="block text-sm font-medium text-gray-300">{label}</label>
                  <span className="font-mono text-cyan-300 text-sm">{typeof value === 'number' ? value.toFixed(3) : 'N/A'}</span>
                </div>
                <input
                    id={name}
                    name={name}
                    type="range"
                    min={min}
                    max={max}
                    step={step}
                    value={typeof value === 'number' ? value : 0}
                    onChange={onChange}
                    className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer mt-1"
                />
                {description && <p className="text-xs text-gray-400 mt-1 pl-1">{description}</p>}
            </div>
        );

        return (
            <div className="bg-gray-800/70 backdrop-blur-sm border border-gray-700 rounded-xl p-3 flex flex-col h-full text-white">
                <h3 className="text-lg font-bold text-cyan-300 mb-2 text-center">Global Forces</h3>
                <div className="flex-grow overflow-y-auto px-1 space-y-4">
                    <div className="space-y-3">
                        <ParameterSlider name="componentSpacing" label="Component Repulsion" min="0" max="500" step="1" value={currentParams.componentSpacing} onChange={handleParamChange} description="Force pushing components apart to prevent overlap." />
                        <ParameterSlider name="distributionStrength" label="Center Repulsion" min="0" max="2.0" step="0.05" value={currentParams.distributionStrength} onChange={handleParamChange} description="Force pushing all components away from the center." />
                        <ParameterSlider name="netLengthWeight" label="Net Attraction Strength" min="0" max="0.2" step="0.001" value={currentParams.netLengthWeight} onChange={handleParamChange} description="Force pulling connected components together to shorten net lengths." />
                        <ParameterSlider name="boardPadding" label="Board Padding" min="0" max="20" step="0.5" value={currentParams.boardPadding} onChange={handleParamChange} description="Margin (mm) for auto-sized board outlines."/>
                        <ParameterSlider name="viaClearance" label="Via Clearance" min="0" max="1.0" step="0.05" value={currentParams.viaClearance} onChange={handleParamChange} description="Extra space (mm diameter) around courtyards for vias."/>
                    </div>
                    
                    <div className="pt-3 border-t border-gray-600 space-y-3">
                         <h4 className="font-semibold text-cyan-400 text-base">Rule Strengths</h4>
                         <ParameterSlider name="proximityKp" label="Proximity (Kp)" min="0" max="50" step="0.1" value={currentParams.proximityKp} onChange={handleParamChange} description="PID Proportional force for proximity (stiffness)." />
                         <ParameterSlider name="proximityKd" label="Proximity (Kd)" min="0" max="10" step="0.1" value={currentParams.proximityKd} onChange={handleParamChange} description="PID Derivative force for proximity (damping)." />
                         <ParameterSlider name="absolutePositionStrength" label="Absolute Position" min="0" max="50" step="0.5" value={currentParams.absolutePositionStrength} onChange={handleParamChange} description="Force locking a component to a fixed coordinate." />
                         <ParameterSlider name="alignmentStrength" label="Alignment" min="0" max="50" step="0.5" value={currentParams.alignmentStrength} onChange={handleParamChange} description="Force aligning components along an axis." />
                         <ParameterSlider name="symmetryStrength" label="Symmetry" min="0" max="50" step="0.5" value={currentParams.symmetryStrength} onChange={handleParamChange} description="Force mirroring component pairs." />
                         <ParameterSlider name="fixedRotationStrength" label="Fixed Rotation Torque" min="0" max="20" step="0.5" value={currentParams.fixedRotationStrength} onChange={handleParamChange} description="Torque twisting a component to a fixed rotation." />
                         <ParameterSlider name="symmetryRotationStrength" label="Symmetry Rotation Torque" min="0" max="20" step="0.5" value={currentParams.symmetryRotationStrength} onChange={handleParamChange} description="Torque for symmetrical rotation." />
                         <ParameterSlider name="circularRotationStrength" label="Circular Rotation Torque" min="0" max="20" step="0.5" value={currentParams.circularRotationStrength} onChange={handleParamChange} description="Torque for circular rotation pattern." />
                    </div>
                </div>
            </div>
        );
    `
};

export const UI_LAYOUT_HEURISTICS_TOOLS: ToolCreatorPayload[] = [
    LAYOUT_HEURISTICS_TUNER_TOOL_PAYLOAD,
];
```

# bootstrap/initial_knowledge_graph.ts
```bootstrap/initial_knowledge_graph.ts

import type { KnowledgeGraph, KnowledgeGraphNode, KnowledgeGraphEdge } from '../types';

// --- Pre-computed Datasheet Extractions (Embedded for offline demo reliability) ---
const ADS131M08_PINS = [{"pin": 1, "name": "AIN2P"}, {"pin": 2, "name": "AIN2N"}, {"pin": 3, "name": "AIN3N"}, {"pin": 4, "name": "AIN3P"}, {"pin": 5, "name": "AIN4P"}, {"pin": 6, "name": "AIN4N"}, {"pin": 7, "name": "AIN5N"}, {"pin": 8, "name": "AIN5P"}, {"pin": 9, "name": "AIN6P"}, {"pin": 10, "name": "AIN6N"}, {"pin": 11, "name": "AIN7N"}, {"pin": 12, "name": "AIN7P"}, {"pin": 13, "name": "AGND"}, {"pin": 14, "name": "REFIN"}, {"pin": 15, "name": "AVDD"}, {"pin": 16, "name": "SYNC/RESET"}, {"pin": 17, "name": "CS"}, {"pin": 18, "name": "DRDY"}, {"pin": 19, "name": "SCLK"}, {"pin": 20, "name": "DOUT"}, {"pin": 21, "name": "DIN"}, {"pin": 22, "name": "XTAL2"}, {"pin": 23, "name": "XTAL1/CLKIN"}, {"pin": 24, "name": "CAP"}, {"pin": 25, "name": "DGND"}, {"pin": 26, "name": "DVDD"}, {"pin": 27, "name": "NC"}, {"pin": 28, "name": "AGND"}, {"pin": 29, "name": "AIN0P"}, {"pin": 30, "name": "AIN0N"}, {"pin": 31, "name": "AIN1N"}, {"pin": 32, "name": "AIN1P"}];
const LP5907_PINS = [{"pin": 1, "name": "IN"}, {"pin": 2, "name": "GND"}, {"pin": 3, "name": "EN"}, {"pin": 4, "name": "N/C"}, {"pin": 5, "name": "OUT"}];
const ECS2520MV_PINS = [{"pin": 1, "name": "Tri-state"}, {"pin": 2, "name": "Gnd"}, {"pin": 3, "name": "Output"}, {"pin": 4, "name": "Vdd"}];
// Note: This is the pinout for the XIAO headers, not the raw module pins.
const XIAO_HEADER_1_PINS = [{"pin": 1, "name": "D0"}, {"pin": 2, "name": "D1"}, {"pin": 3, "name": "D2"}, {"pin": 4, "name": "D3"}, {"pin": 5, "name": "D4/SDA"}, {"pin": 6, "name": "D5/SCL"}, {"pin": 7, "name": "D6/TX"}];
const XIAO_HEADER_2_PINS = [{"pin": 1, "name": "5V"}, {"pin": 2, "name": "GND"}, {"pin": 3, "name": "3V3"}, {"pin": 4, "name": "D10/MOSI"}, {"pin": 5, "name": "D9/MISO"}, {"pin": 6, "name": "D8/SCK"}, {"pin": 7, "name": "D7/RX"}];


// --- Base Graph Definition ---
const baseNodes: KnowledgeGraphNode[] = [
    // --- Market Pull Side ---
    { id: "use_case_eeg", label: "EEG Data Acquisition", type: "MarketNeed" },
    { id: "eeg_mezzanine", label: "EEG Mezzanine Board", type: "Device" },
    
    // --- Components ---
    { id: 'U1', label: 'U1 (ADS131M08)', type: "Component" },
    { id: 'U2', label: 'U2 (LP5907)', type: "Component" },
    { id: 'U3', label: 'U3 (LP5907)', type: "Component" },
    { id: 'X1', label: 'X1 (ECS-2520MV)', type: "Component" },
    ...['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8'].map(c => ({ id: c, label: c, type: "Component" })),
    ...Array.from({ length: 10 }, (_, i) => ({ id: `J${i + 1}`, label: `J${i + 1}`, type: "Component" })),
    { id: 'J_XIAO_1', label: 'J_XIAO_1', type: "Component" },
    { id: 'J_XIAO_2', label: 'J_XIAO_2', type: "Component" },

    // --- Technology Push Side ---
    { id: "longevity_research", label: "Longevity Research", type: "Technology" },
    { id: "Sirtuins", label: "Sirtuins", type: "Technology" },
    { id: "NAD+", label: "NAD+", type: "Technology" },
];

const baseEdges: KnowledgeGraphEdge[] = [
    // --- Market Pull Connections ---
    { source: "eeg_mezzanine", target: "use_case_eeg", label: "enables" },
    ...baseNodes.filter(n => n.type === 'Component').map(c => ({ source: "eeg_mezzanine", target: c.id, label: "uses" })),

    // --- Technology Push Connections ---
    { source: "longevity_research", target: "Sirtuins", label: "involves" },
    { source: "NAD+", target: "Sirtuins", label: "activates" },
];

// --- Dynamic Pin Generation ---
const componentPinData = {
    'U1': ADS131M08_PINS,
    'U2': LP5907_PINS,
    'U3': LP5907_PINS,
    'X1': ECS2520MV_PINS,
    'J_XIAO_1': XIAO_HEADER_1_PINS,
    'J_XIAO_2': XIAO_HEADER_2_PINS,
};

const pinNodes: KnowledgeGraphNode[] = [];
const pinEdges: KnowledgeGraphEdge[] = [];

Object.entries(componentPinData).forEach(([componentId, pins]) => {
    pins.forEach(pin => {
        pinNodes.push({
            id: `${componentId}-${pin.pin}`,
            label: `${pin.pin}: ${pin.name}`,
            type: 'Pin'
        });
        pinEdges.push({
            source: componentId,
            target: `${componentId}-${pin.pin}`,
            label: 'has_pin'
        });
    });
});

// --- Final Export ---
export const INNOVATION_KNOWLEDGE_GRAPH: KnowledgeGraph = {
  nodes: [...baseNodes, ...pinNodes],
  edges: [...baseEdges, ...pinEdges],
};

```

# bootstrap/neurofeedback_tools.ts
```bootstrap/neurofeedback_tools.ts
// bootstrap/neurofeedback_tools.ts
import type { ToolCreatorPayload } from '../types';

const NEUROFEEDBACK_TOOL_DEFINITIONS: ToolCreatorPayload[] = [
    {
        name: 'Define Neurofeedback Protocol',
        description: 'Defines the high-level parameters for a neurofeedback session, such as target brainwaves, feedback modality, and goals.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To specify the intended behavior and structure of a neurofeedback algorithm before code generation.',
        parameters: [
            { name: 'protocolName', type: 'string', description: 'A unique name for the protocol (e.g., "Alpha_Up_Training_Visual").', required: true },
            { name: 'description', type: 'string', description: 'A brief explanation of the protocol\'s goal.', required: true },
            { name: 'targetBand', type: 'string', description: 'The target brainwave band (e.g., "Alpha", "Beta", "Theta").', required: true },
            { name: 'feedbackModality', type: 'string', description: 'The type of feedback to provide (e.g., "Visual", "Auditory").', required: true },
            { name: 'sessionLengthSeconds', type: 'number', description: 'The total duration of a training session in seconds.', required: true },
            { name: 'thresholds', type: 'object', description: 'JSON string defining the power thresholds for successful feedback.', required: true },
        ],
        implementationCode: `return { success: true, message: '[SIM] Neurofeedback protocol \\\`\${args.protocolName}\\\` defined.' };`
    },
    {
        name: 'Generate Signal Processing Script',
        description: 'Creates a Python script using libraries like MNE and SciPy to perform real-time EEG signal processing for a defined protocol.',
        category: 'Automation',
        executionEnvironment: 'Client',
        purpose: 'To translate a high-level neurofeedback protocol definition into executable code that can run on a real device.',
        parameters: [
            { name: 'protocolName', type: 'string', description: 'The name of the protocol to generate the script for.', required: true },
            { name: 'scriptType', type: 'string', description: 'The target platform or language (e.g., "Python_MNE").', required: true },
            { name: 'targetBand', type: 'string', description: 'The target brainwave band (e.g., "Alpha").', required: true },
            { name: 'feedbackModality', type: 'string', description: 'The type of feedback (e.g., "Visual").', required: true },
        ],
        implementationCode: `
            const { protocolName, scriptType, targetBand, feedbackModality } = args;
            // This client-side tool generates Python code and uses the 'Server File Writer' tool to save it.
            const scriptContent = \`
import time
import random

# Python script for \${protocolName}
# Generated by Singularity Agent
# Target Band: \${targetBand}
# Feedback Modality: \${feedbackModality}

def get_eeg_data():
    # In a real scenario, this would read from an EEG device.
    # Here, we simulate it.
    return {
        '\${targetBand}': random.uniform(0.5, 2.5),
        'other_band_1': random.uniform(0.8, 1.8),
        'other_band_2': random.uniform(1.0, 1.5),
    }

def run_session():
    print(f"Starting neurofeedback session: \${protocolName}")
    
    # This would be configured by the protocol's thresholds
    success_threshold = 1.5 
    
    for i in range(10): # Simulate a short session
        data = get_eeg_data()
        target_power = data.get('\${targetBand}', 0)
        
        print(f"  [Step {i+1}] \${targetBand} Power: {target_power:.2f}", end="")
        
        if target_power > success_threshold:
            print(" -> SUCCESS (Feedback ON)")
        else:
            print(" -> (Feedback OFF)")
        
        time.sleep(0.5)

    print("Session complete.")

if __name__ == "__main__":
    run_session()
\`;
            await runtime.tools.run('Server File Writer', { filePath: \`\${protocolName}.py\`, content: scriptContent });
            return { success: true, message: \`Python script '\${protocolName}.py' generated and saved to server.\` };
        `
    },
    {
        name: 'Simulate Protocol Efficacy',
        description: 'Runs a simulation of the generated neurofeedback script against sample EEG data to predict its effectiveness and stability.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To validate a neurofeedback protocol in a simulated environment before deploying it for real-world use.',
        parameters: [
            { name: 'protocolName', type: 'string', description: 'The name of the Python script file for the protocol (e.g., "Alpha_Up_Training_Visual.py").', required: true },
            { name: 'datasetId', type: 'string', description: 'The ID of the sample EEG dataset to use for the simulation.', required: true },
        ],
        implementationCode: `python \${args.protocolName} --simulate --dataset \${args.datasetId}`
    },
    {
        name: 'Package Incantation',
        description: 'Packages the defined protocol, generated scripts, and simulation results into a final, shareable "Incantation" artifact.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To create the final, distributable asset for a neurofeedback protocol, ready for use or for the Aetherium Marketplace.',
        parameters: [
            { name: 'protocolName', type: 'string', description: 'The name of the protocol to package.', required: true },
        ],
        implementationCode: `return { success: true, message: 'Incantation \\\`\${args.protocolName}\\\` has been successfully packaged.' };`
    },
];

const NEUROFEEDBACK_INSTALLER_TOOL: ToolCreatorPayload = {
    name: 'Install Neuro-Weaving Suite',
    description: 'A one-time setup action that installs all necessary tools for creating, simulating, and packaging "Mindful Incantations" (neurofeedback protocols).',
    category: 'Automation',
    executionEnvironment: 'Client',
    purpose: "To bootstrap the agent's ability to create and manage neurofeedback algorithms, establishing a new core crafting capability.",
    parameters: [],
    implementationCode: `
        runtime.logEvent('[INFO] Installing Neuro-Weaving Suite...');
        const toolPayloads = ${JSON.stringify(NEUROFEEDBACK_TOOL_DEFINITIONS)};
        
        const allTools = runtime.tools.list();
        const existingToolNames = new Set(allTools.map(t => t.name));

        for (const payload of toolPayloads) {
            if (existingToolNames.has(payload.name)) {
                runtime.logEvent(\`[INFO] Tool '\${payload.name}' already exists. Skipping installation.\`);
                continue;
            }
            try {
                await runtime.tools.run('Tool Creator', payload);
            } catch (e) {
                runtime.logEvent(\`[WARN] Failed to create new tool '\${payload.name}'. Error: \${e.message}\`);
            }
        }
        
        return { success: true, message: 'Neuro-Weaving Suite and all associated tools installed successfully.' };
    `
};

export const NEUROFEEDBACK_TOOLS: ToolCreatorPayload[] = [
    NEUROFEEDBACK_INSTALLER_TOOL,
];
```

# bootstrap/datasheet_tools.ts
```bootstrap/datasheet_tools.ts

import type { ToolCreatorPayload } from '../types';
// Note: The datasheet variables are injected into the UI Tool's scope by UIToolRunner.tsx
// They are not directly imported here to keep the payload serializable if needed.

export const DATASHEET_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Read Datasheet Extraction Cache',
        description: 'Reads a previously cached datasheet extraction from the server filesystem.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To retrieve cached LLM analysis of datasheets to avoid expensive re-computation.',
        parameters: [
            { name: 'cacheKey', type: 'string', description: 'The unique key (filename) for the cache entry.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::read_datasheet_cache'
    },
    {
        name: 'Cache Component Datasheet Extraction',
        description: 'Writes the result of a datasheet extraction to the server filesystem for future use.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To persist the results of LLM analysis of datasheets, enabling faster subsequent queries.',
        parameters: [
            { name: 'cacheKey', type: 'string', description: 'The unique key (filename) for the cache entry.', required: true },
            { name: 'data', type: 'object', description: 'The JSON object containing the component name, question, and answer to cache.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::write_datasheet_cache'
    },
    {
        name: 'Extract Component Information from Datasheet',
        description: 'Analyzes datasheet text to answer a technical question. It first checks a server-side cache for a pre-computed answer before using an LLM.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a foundational capability for an agent to understand electronic components by reading their documentation, with caching for efficiency.',
        parameters: [
            { name: 'datasheetText', type: 'string', description: 'The full text content of the datasheet to be analyzed.', required: true },
            { name: 'componentName', type: 'string', description: 'The name of the component being asked about (e.g., "ADS131M08").', required: true },
            { name: 'question', type: 'string', description: 'The specific question to ask about the component (e.g., "Provide a JSON object of all pin functions for the TQFP package.").', required: true },
        ],
        implementationCode: `
            const { datasheetText, componentName, question } = args;

            // Create a unique, filesystem-safe key for the cache entry.
            const sanitizedQuestion = question.toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 50);
            const cacheKey = \`\${componentName}_\${sanitizedQuestion}.json\`;

            // 1. Try to read from the cache first.
            try {
                if (runtime.isServerConnected()) {
                    const cachedResult = await runtime.tools.run('Read Datasheet Extraction Cache', { cacheKey });
                    if (cachedResult && cachedResult.answer) {
                        return { success: true, message: "Retrieved datasheet extraction from server cache.", answer: cachedResult.answer };
                    }
                }
            } catch (e) {
                // A cache miss is expected to throw a 'file not found' error, so we just log it and continue.
                console.log(\`[CACHE MISS] No cached data for '\${cacheKey}'. Querying LLM.\`);
            }

            // 2. If cache miss, run the LLM.
            const systemPrompt = \`You are an expert electronics engineer. Your task is to answer a specific question about the component "\${componentName}" based ONLY on the provided datasheet text. Do not use any prior knowledge. If the answer is not in the text, state that explicitly. Provide concise, factual answers.\`;
            const fullPrompt = \`Based on the following datasheet, answer the question.\\n\\n--- DATASHEET START ---\\n\${datasheetText}\\n--- DATASHEET END ---\\n\\nQuestion: \${question}\`;
            const llmAnswer = await runtime.ai.generateText(fullPrompt, systemPrompt);

            // 3. Write the new result to the cache for next time.
            try {
                 if (runtime.isServerConnected()) {
                    await runtime.tools.run('Cache Component Datasheet Extraction', {
                        cacheKey: cacheKey,
                        data: { componentName, question, answer: llmAnswer, timestamp: new Date().toISOString() }
                    });
                }
            } catch (e) {
                // Don't fail the whole operation if caching fails, just warn the user.
                console.warn(\`[CACHE WRITE FAILED] Could not save extraction for '\${cacheKey}': \${e.message}\`);
            }

            // 4. Return the result from the LLM.
            return { success: true, message: "Datasheet queried successfully using LLM.", answer: llmAnswer };
        `
    },
    {
        name: 'Datasheet Reader',
        description: 'A UI for viewing component datasheets and manually querying them for information.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide a user interface for the datasheet analysis capability.',
        parameters: [
            { name: 'runtime', type: 'object', description: 'The agent runtime environment, providing access to other tools.', required: true }
        ],
        implementationCode: `
            const DATASHEETS = {
                'ADS131M08 (ADC)': ADS131M08_DATASHEET,
                'LP5907 (LDO)': LP5907_DATASHEET,
                'Seeed Studio XIAO (SoM)': XIAO_DATASHEET,
                'ECS-2520MV (Oscillator)': ECS2520MV_DATASHEET,
            };

            const [selectedSheet, setSelectedSheet] = React.useState(Object.keys(DATASHEETS)[0]);
            const [componentName, setComponentName] = React.useState('ADS131M08');
            const [question, setQuestion] = React.useState('Provide a JSON object of all pin functions for the TQFP package.');
            const [isLoading, setIsLoading] = React.useState(false);
            const [answer, setAnswer] = React.useState('');

            const handleQuery = async () => {
                if (!question.trim() || !runtime) return;
                setIsLoading(true);
                setAnswer('');
                try {
                    const result = await runtime.tools.run('Extract Component Information from Datasheet', {
                        datasheetText: DATASHEETS[selectedSheet],
                        componentName: componentName,
                        question: question,
                    });
                    setAnswer(result.answer);
                } catch (e) {
                    setAnswer('Error: ' + (e.message || String(e)));
                } finally {
                    setIsLoading(false);
                }
            };
            
            const Spinner = () => (
                <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            );

            return (
                <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-3 space-y-3 flex flex-col h-full">
                    <h3 className="text-lg font-bold text-indigo-300">Datasheet Intelligence</h3>
                    <div className="space-y-2 flex-grow flex flex-col min-h-0">
                        <select
                            value={selectedSheet}
                            onChange={e => setSelectedSheet(e.target.value)}
                            className="w-full bg-gray-900 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-indigo-500 flex-shrink-0"
                        >
                            {Object.keys(DATASHEETS).map(name => <option key={name} value={name}>{name}</option>)}
                        </select>
                        
                        <textarea
                            readOnly
                            value={DATASHEETS[selectedSheet]}
                            className="w-full flex-grow bg-black/30 border border-gray-700 rounded-md p-2 text-xs font-mono"
                        />
                        
                        <div className="space-y-2 pt-2 border-t border-gray-700 flex-shrink-0">
                             <input type="text" value={componentName} onChange={e => setComponentName(e.target.value)} placeholder="Component Name (e.g., ADS131M08)" className="w-full bg-gray-900 border border-gray-600 rounded-lg p-2 text-sm" />
                             <textarea value={question} onChange={e => setQuestion(e.target.value)} placeholder="Question about the component..." className="w-full h-20 bg-gray-900 border border-gray-600 rounded-lg p-2 text-sm" />
                             <button onClick={handleQuery} disabled={isLoading || !runtime} className="w-full flex items-center justify-center gap-2 bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-700 disabled:bg-indigo-900/50">
                                {isLoading ? <Spinner/> : 'Query Datasheet'}
                             </button>
                        </div>
                        
                        {(isLoading || answer) && (
                            <div className="mt-2 p-2 border border-gray-600 bg-black/30 rounded-lg space-y-1 flex-shrink-0">
                                <h4 className="font-semibold text-indigo-300">Answer:</h4>
                                {isLoading && !answer && <p className="text-gray-400">Querying AI...</p>}
                                <pre className="text-sm whitespace-pre-wrap font-mono text-gray-200">{answer}</pre>
                            </div>
                        )}
                    </div>
                </div>
            )
        `
    },
];

```

# bootstrap/ui_layout_rules_tools.ts
```bootstrap/ui_layout_rules_tools.ts
// bootstrap/ui_layout_rules_tools.ts

import type { ToolCreatorPayload } from '../types';

export const LAYOUT_RULES_EDITOR_TOOL_PAYLOAD: ToolCreatorPayload = {
    name: 'Layout Rules',
    description: 'A UI panel for interactively viewing, enabling/disabling, and managing PCB layout constraints during a simulation.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide real-time control and feedback over the layout rules, allowing for interactive debugging and fine-tuning of the component arrangement.',
    parameters: [
        { name: 'rules', type: 'array', description: 'The array of current layout rules.', required: true },
        { name: 'onUpdateRules', type: 'object', description: 'Callback function to update the rules array with the new, complete list of rules.', required: true },
    ],
    implementationCode: `
const RULE_DEFINITIONS = {
    'ProximityConstraint': [{ name: 'groupsJSON', type: 'textarea', placeholder: '[["U1", "C1"]]' }],
    'AlignmentConstraint': [{ name: 'axis', type: 'select', options: ['vertical', 'horizontal'] }, { name: 'componentsJSON', type: 'textarea', placeholder: '["J1", "J2"]' }],
    'SymmetryConstraint': [{ name: 'axis', type: 'select', options: ['vertical', 'horizontal'] }, { name: 'pairsJSON', type: 'textarea', placeholder: '[["C1", "C2"]]' }],
    'CircularConstraint': [{ name: 'componentsJSON', type: 'textarea', placeholder: '["J1", "J2"]' }, { name: 'radius', type: 'number', placeholder: '12.5' }, { name: 'centerX', type: 'number', placeholder: '0' }, { name: 'centerY', type: 'number', placeholder: '0' }],
    'LayerConstraint': [{ name: 'layer', type: 'select', options: ['top', 'bottom'] }, { name: 'componentsJSON', type: 'textarea', placeholder: '["J1", "J2"]' }],
    'AbsolutePositionConstraint': [{ name: 'componentReference', type: 'text', placeholder: 'U1' }, { name: 'x', type: 'number', placeholder: '10.0' }, { name: 'y', type: 'number', placeholder: '15.5' }],
    'FixedPropertyConstraint': [{ name: 'componentReference', type: 'text', placeholder: 'J1' }, { name: 'propertiesJSON', type: 'textarea', placeholder: '{"rotation": 90}' }],
    'SymmetricalPairConstraint': [{ name: 'pairJSON', type: 'textarea', placeholder: '["J_A", "J_B"]' }, { name: 'axis', type: 'select', options: ['vertical', 'horizontal'] }, { name: 'separation', type: 'number', placeholder: '17.78' }],
};

const AddRuleForm = React.memo(({ onAdd, onCancel }) => {
    const [ruleType, setRuleType] = React.useState('ProximityConstraint');
    const [args, setArgs] = React.useState({});

    const handleArgChange = (name, value) => {
        setArgs(prev => ({ ...prev, [name]: value }));
    };

    const handleTypeChange = (e) => {
        setRuleType(e.target.value);
        setArgs({});
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        const newRule = { type: ruleType, enabled: true, ...args };
        if (newRule.type === 'AbsolutePositionConstraint' && newRule.componentReference) {
            newRule.component = newRule.componentReference;
            delete newRule.componentReference;
        }
        if (newRule.type === 'FixedPropertyConstraint' && newRule.componentReference) {
            newRule.component = newRule.componentReference;
            delete newRule.componentReference;
        }
        onAdd(newRule);
        setArgs({});
    };

    return (
        <form onSubmit={handleSubmit} className="p-2 bg-gray-900/70 border border-indigo-700 rounded-lg space-y-3 mb-2">
            <select value={ruleType} onChange={handleTypeChange} className="w-full bg-gray-800 border-gray-600 rounded p-1.5 text-sm">
                {Object.keys(RULE_DEFINITIONS).map(key => <option key={key} value={key}>{key.replace(/([A-Z])/g, ' $1').trim()}</option>)}
            </select>
            {RULE_DEFINITIONS[ruleType].map(param => {
                const value = args[param.name] || (param.type === 'select' ? param.options[0] : '');
                const placeholder = param.placeholder || param.name;
                if (param.type === 'textarea') return <textarea key={param.name} value={value} onChange={e => handleArgChange(param.name, e.target.value)} placeholder={placeholder} className="w-full h-20 bg-gray-800 border-gray-600 rounded p-1.5 text-sm font-mono" required />;
                if (param.type === 'select') return <select key={param.name} value={value} onChange={e => handleArgChange(param.name, e.target.value)} className="w-full bg-gray-800 border-gray-600 rounded p-1.5 text-sm">{param.options.map(o => <option key={o} value={o}>{o.charAt(0).toUpperCase() + o.slice(1)}</option>)}</select>;
                return <input key={param.name} type={param.type} value={value} onChange={e => handleArgChange(param.name, param.type === 'number' ? parseFloat(e.target.value) || 0 : e.target.value)} placeholder={placeholder} className="w-full bg-gray-800 border-gray-600 rounded p-1.5 text-sm" required />;
            })}
            <div className="flex gap-2">
                <button type="button" onClick={onCancel} className="flex-1 text-center bg-gray-600 text-white font-semibold py-1.5 px-3 rounded-lg hover:bg-gray-500">Cancel</button>
                <button type="submit" className="flex-1 text-center bg-indigo-600 text-white font-semibold py-1.5 px-3 rounded-lg hover:bg-indigo-500">Add Rule</button>
            </div>
        </form>
    );
});

const [showForm, setShowForm] = React.useState(false);

const handleToggle = React.useCallback((index) => {
    const newRules = [...(rules || [])];
    if (newRules[index]) {
        newRules[index] = { ...newRules[index], enabled: !newRules[index].enabled };
        onUpdateRules(newRules);
    }
}, [rules, onUpdateRules]);

const handleDelete = React.useCallback((index) => {
    const newRules = (rules || []).filter((_, i) => i !== index);
    onUpdateRules(newRules);
}, [rules, onUpdateRules]);

const handleAddRule = React.useCallback((newRule) => {
    onUpdateRules([...(rules || []), newRule]);
    setShowForm(false);
}, [rules, onUpdateRules]);

const handleCancelForm = React.useCallback(() => {
    setShowForm(false);
}, []);

const formatRuleValue = (value) => {
    if (Array.isArray(value)) return \`[\${value.join(', ')}]\`;
    if (typeof value === 'object' && value !== null) return JSON.stringify(value);
    return String(value);
};

return (
    <div className="bg-gray-800/70 backdrop-blur-sm border border-gray-700 rounded-xl p-3 flex flex-col h-full text-white">
        <div className="flex justify-between items-center px-1 mb-2">
            <h3 className="text-lg font-bold text-cyan-300">Layout Rules</h3>
            <button onClick={() => setShowForm(prev => !prev)} className="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-1 px-2.5 rounded-md text-lg leading-none">{showForm ? '−' : '+'}</button>
        </div>
        
        {showForm && <AddRuleForm onAdd={handleAddRule} onCancel={handleCancelForm} />}
        
        <div className="flex-grow overflow-y-auto pr-1 space-y-2">
            {(rules || []).map((rule, index) => (
                <div key={index} className={\`p-2 rounded-lg bg-gray-900/50 border \${rule.enabled ? 'border-cyan-700/80' : 'border-gray-700'} transition-colors\`}>
                   <div className="flex justify-between items-center">
                        <span className="font-semibold text-sm truncate pr-2">{rule.type.replace(/([A-Z])/g, ' $1').trim()}</span>
                        <div className="flex items-center gap-2">
                            <button onClick={() => handleDelete(index)} title="Delete Rule" className="text-red-400 hover:text-red-300 text-lg font-bold">&times;</button>
                            <div className="flex items-center">
                                <input type="checkbox" checked={!!rule.enabled} onChange={() => handleToggle(index)} className="w-4 h-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500"/>
                            </div>
                        </div>
                   </div>
                   <div className="mt-1 pl-4 text-xs text-gray-400 font-mono space-y-0.5">
                        {Object.entries(rule).filter(([k]) => !['type', 'enabled'].includes(k)).map(([key, value]) => (
                            <div key={key} className="truncate"><span className="text-cyan-400">{key}:</span> {formatRuleValue(value)}</div>
                        ))}
                   </div>
                </div>
            ))}
            {(!rules || rules.length === 0) && <p className="text-sm text-gray-500 text-center py-4">No layout rules defined.</p>}
        </div>
    </div>
);
`
};

export const LAYOUT_RULES_TOOLS: ToolCreatorPayload[] = [
    LAYOUT_RULES_EDITOR_TOOL_PAYLOAD,
];
```

# bootstrap/robotics_tools.ts
```bootstrap/robotics_tools.ts
import type { ToolCreatorPayload } from '../types';

export const ROBOTICS_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Define Robot Agent',
        description: 'Defines a new robot agent with a specific behavior personality for the simulation.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To configure and instantiate individual robot agents before starting a simulation.',
        parameters: [
          { name: 'id', type: 'string', description: 'The unique identifier for the robot agent.', required: true },
          { name: 'startX', type: 'number', description: 'The starting X coordinate for the agent.', required: true },
          { name: 'startY', type: 'number', description: 'The starting Y coordinate for the agent.', required: true },
          { name: 'behaviorType', type: 'string', description: "The agent's behavior: 'patroller', 'resource_collector', or 'seek_target'.", required: true },
          { name: 'targetId', type: 'string', description: "The ID of the target object for 'seek_target' behavior (e.g., 'red_car').", required: false },
          { name: 'asset_glb', type: 'string', description: "Optional path to a GLB model for the agent's visual representation (e.g., 'assets/robot.glb').", required: false },
        ],
        implementationCode: `
            // This is a client-side tool whose logic is handled inside useAppRuntime
            // to directly update the state in useRobotManager.
            return { success: true, message: \`Personality for agent '\${args.id}' has been defined.\` };
        `
    },
    {
        name: 'Start Robot Simulation',
        description: 'Starts the robotics simulation, creating all defined agents on the field.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To initialize and begin the robotics simulation.',
        parameters: [],
        implementationCode: `
            // Logic is handled in useAppRuntime to set the robot states based on personalities.
            return { success: true, message: 'Robot simulation started.' };
        `
    },
    {
        name: 'Step Robot Simulation',
        description: 'Advances the simulation by one time step, causing all agents to perform an action.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To execute one tick of the simulation, updating agent states based on their behavior.',
        parameters: [],
        implementationCode: `
            // The core logic for agent behaviors (patrolling, seeking, etc.) would be implemented here,
            // likely by iterating through agents and calling other primitive tools (Move, Turn) based on their state and goals.
            // For now, it's a placeholder for the LLM to expand upon.
            return { success: true, message: 'Advanced simulation by one step for all agents.' };
        `
    },
    {
        name: 'Stop Robot Simulation',
        description: 'Stops the robotics simulation and removes all agents from the field.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To terminate and reset the robotics simulation environment.',
        parameters: [],
        implementationCode: `
            // Logic is handled in useAppRuntime to clear robot states and personalities.
            return { success: true, message: 'Robot simulation stopped and cleared.' };
        `
    },
    {
        name: 'Move Forward',
        description: 'A fundamental robotic action for navigation. Moves the specified agent one unit forward in its current direction. Use this as part of a sequence to patrol, explore, or approach a target.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a primitive action for agent locomotion, forming the basis for all higher-level movement skills like pathfinding and exploration.',
        parameters: [
            { name: 'agentId', type: 'string', description: 'The ID of the robot to move.', required: true }
        ],
        implementationCode: `
            // Implemented directly in useAppRuntime for state management.
            return { success: true, message: "Move forward command issued." };
        `
    },
    {
        name: 'Move Backward',
        description: 'A fundamental robotic action for navigation. Moves the specified agent one unit backward from its current direction. Useful for maneuvering in tight spaces or retreating.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a primitive action for agent locomotion, allowing for reverse movement as part of complex navigation skills.',
        parameters: [
            { name: 'agentId', type: 'string', description: 'The ID of the robot to move.', required: true }
        ],
        implementationCode: `
            // Implemented directly in useAppRuntime for state management.
            return { success: true, message: "Move backward command issued." };
        `
    },
    {
        name: 'Turn Left',
        description: 'A fundamental robotic action for orientation. Rotates the specified agent 90 degrees to its left (counter-clockwise). Essential for changing direction during navigation and exploration.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a primitive action for changing an agent\'s orientation, enabling pathfinding and target acquisition.',
         parameters: [
            { name: 'agentId', type: 'string', description: 'The ID of the robot to turn.', required: true }
        ],
        implementationCode: `
            // Implemented directly in useAppRuntime for state management.
            return { success: true, message: "Turn left command issued." };
        `
    },
    {
        name: 'Turn Right',
        description: 'A fundamental robotic action for orientation. Rotates the specified agent 90 degrees to its right (clockwise). Essential for changing direction during navigation and exploration.',
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: 'To provide a primitive action for changing an agent\'s orientation, enabling pathfinding and target acquisition.',
         parameters: [
            { name: 'agentId', type: 'string', description: 'The ID of the robot to turn.', required: true }
        ],
        implementationCode: `
            // Implemented directly in useAppRuntime for state management.
            return { success: true, message: "Turn right command issued." };
        `
    }
];
```

# bootstrap/kicad_tools.ts
```bootstrap/kicad_tools.ts
// bootstrap/kicad_tools.ts

import type { ToolCreatorPayload } from '../types';
import { KICAD_SERVICE_SCRIPT } from './kicad_service';
import { KICAD_SERVICE_COMMANDS_SCRIPT } from './kicad_service_commands';
import { KICAD_DSN_UTILS_SCRIPT } from './kicad_dsn_utils';
import { KICAD_SES_UTILS_SCRIPT } from './kicad_ses_utils';

const KICAD_TOOL_DEFINITIONS: ToolCreatorPayload[] = [
    // --- Service Management ---
    {
        name: 'Start KiCad Service',
        description: 'Starts the long-running Python service for KiCad automation. This MUST be called before any other KiCad command to ensure high performance by avoiding repeated library loading.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To initialize the high-performance KiCad automation engine, which is a prerequisite for all subsequent hardware design tasks.",
        parameters: [],
        implementationCode: '# This is a special server-side command handled by the Node.js backend to spawn the Python service.'
    },
    {
        name: 'Stop KiCad Service',
        description: 'Stops the long-running Python service for KiCad automation, freeing up system resources.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To cleanly shut down the KiCad automation engine when it's no longer needed.",
        parameters: [],
        implementationCode: '# This is a special server-side command handled by the Node.js backend to terminate the Python service.'
    },
    // --- Tool Definitions using proxy ---
    {
        name: 'Add Absolute Position Constraint',
        description: 'Fixes an electronic component to an absolute coordinate on the PCB along one or both axes. For example, you can lock a component to y=9, allowing its x-position to be determined by other forces like symmetry. Essential for connectors or parts with fixed mechanical constraints.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To lock critical components to a specific physical location on the board, ensuring mechanical alignment with an enclosure or other hardware, which is a key step in designing a manufacturable product.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'componentReference', type: 'string', description: 'The reference designator of the component to fix (e.g., "U1").', required: true },
            { name: 'x', type: 'number', description: 'Optional: The X coordinate in millimeters to lock the component to.', required: false },
            { name: 'y', type: 'number', description: 'Optional: The Y coordinate in millimeters to lock the component to.', required: false },
        ],
        implementationCode: 'kicad_service_proxy::add_absolute_position_constraint'
    },
    {
        name: 'Add Proximity Constraint',
        description: 'Adds a design rule that specific electronic components must be placed close to each other on the PCB. Critical for high-speed signals or decoupling capacitors.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To enforce critical placement for components that have a close electrical relationship, improving signal integrity, reducing noise, and ensuring the performance of the final electronic device.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'groupsJSON', type: 'string', description: 'A JSON string of an array of arrays, where each inner array is a group of component references that should be close. E.g., \'[["U1", "C1"], ["U1", "C2"]]\'.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::add_proximity_constraint'
    },
    {
        name: 'Add Alignment Constraint',
        description: 'Adds a design rule to align a group of electronic components along a specified axis (vertical or horizontal) on the PCB.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To create clean, organized, and manufacturable PCB layouts by aligning components like headers, LEDs, or resistor arrays, which improves routing and assembly efficiency.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'axis', type: 'string', description: 'The axis for alignment: "vertical" or "horizontal".', required: true },
            { name: 'componentsJSON', type: 'string', description: 'A JSON string of an array of component references to align. E.g., \'["J1", "J2", "J3"]\'.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::add_alignment_constraint'
    },
     {
        name: 'Add Symmetry Constraint',
        description: 'Adds a design rule that components in specified pairs should be placed symmetrically across a central axis on the PCB.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To ensure balanced electrical and thermal layouts for sensitive circuits, such as an analog amplifiers or differential pairs, which is critical for the performance and reliability of the electronic device.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'axis', type: 'string', description: 'The axis of symmetry: "vertical" or "horizontal".', required: true },
            { name: 'pairsJSON', type: 'string', description: 'A JSON string of an array of pairs. Each pair is an array of two component references. E.g., \'[["C1", "C2"], ["R1", "R2"]]\'.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::add_symmetry_constraint'
    },
    {
        name: 'Add Circular Constraint',
        description: 'Adds a design rule to arrange a set of electronic components in a circular pattern around a center point on the PCB.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To create specialized PCB layouts for circular devices, such as an LED rings, rotary encoders, or circular sensor arrays, enabling unique hardware form factors.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'componentsJSON', type: 'string', description: 'A JSON string of an array of component references to arrange in a circle.', required: true },
            { name: 'radius', type: 'number', description: 'The radius of the circle in millimeters.', required: true },
            { name: 'centerX', type: 'number', description: 'The X coordinate of the circle\'s center in millimeters.', required: true },
            { name: 'centerY', type: 'number', description: 'The Y coordinate of the circle\'s center in millimeters.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::add_circular_constraint'
    },
     {
        name: 'Add Layer Constraint',
        description: 'Adds a design rule to force a set of components to be placed on a specific layer of the PCB (top or bottom).',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To control the physical placement of components on either side of the PCB, optimizing for space, thermal management, or assembly requirements during manufacturing.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'layer', type: 'string', description: 'The target layer: "top" or "bottom".', required: true },
            { name: 'componentsJSON', type: 'string', description: 'A JSON string of an array of component references to place on the specified layer.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::add_layer_constraint'
    },
    {
        name: 'Add Fixed Property Constraint',
        description: 'Fixes a specific property of a component, like its rotation or side, preventing it from being changed by the simulation. Use this for components with required orientations.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To give the agent precise control over individual component properties that are non-negotiable, such as the orientation of a polarized capacitor or a specific connector.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'componentReference', type: 'string', description: 'The reference designator of the component (e.g., "U1").', required: true },
            { name: 'propertiesJSON', type: 'string', description: 'A JSON string of an object with properties to fix. E.g., \'{"rotation": 90}\'.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::add_fixed_property_constraint'
    },
    {
        name: 'Add Symmetrical Pair Constraint',
        description: 'Constrains two components to be symmetrical about an axis with a specific separation distance between them. It automatically handles their relative rotation to face each other.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To correctly model and place pairs of components like DIP packages or board-edge connectors (e.g., XIAO) that have a fixed, mirrored physical relationship.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'pairJSON', type: 'string', description: 'A JSON string of an array with two component references. E.g., \'["J_XIAO_1", "J_XIAO_2"]\'.', required: true },
            { name: 'axis', type: 'string', description: 'The axis of symmetry: "vertical" or "horizontal".', required: true },
            { name: 'separation', type: 'number', description: 'The required distance between the two components in millimeters.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::add_symmetrical_pair_constraint'
    },
    {
        name: 'Define KiCad Component',
        description: 'Defines a single electronic component by its schematic reference, value, and physical footprint. This must be called for every component before creating the netlist for the PCB.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To define the fundamental building blocks of an electronic circuit, creating a complete Bill of Materials (BOM) and providing the necessary data to translate the logical schematic into a physical PCB layout.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project, used to group all related files.', required: true },
            { name: 'componentReference', type: 'string', description: 'The unique reference designator for the component on the schematic (e.g., U1, R1, C1).', required: true },
            { name: 'componentDescription', type: 'string', description: `A human-readable description of the component's function (e.g., "MCU", "10k Resistor").`, required: true },
            { name: 'componentValue', type: 'string', description: `The value of the component (e.g., "ESP32-S3-WROOM-1", "10k"). For components from a library, use the format 'LibraryName:PartName'.`, required: true },
            { name: 'footprintIdentifier', type: 'string', description: `The KiCad footprint identifier for the component's physical package (e.g., "Resistor_SMD:R_0805_2012Metric").`, required: true },
            { name: 'numberOfPins', type: 'number', description: 'The total number of pins for this component. Used for creating generic parts. Set to 0 if this is a pre-defined library part specified in componentValue.', required: true },
            { name: 'pinConnections', type: 'string', description: "Optional: A JSON string of an array of objects mapping pin numbers to net names for validation. E.g., '[{\"pin\": 1, \"net\": \"VCC\"}, {\"pin\": 2, \"net\": \"GND\"}]'.", required: false },
            { name: 'side', type: 'string', description: "The initial side of the board for the component ('top' or 'bottom'). Defaults to 'top'.", required: false },
            { name: 'metaphysicalPropertiesJSON', type: 'string', description: "Optional: A JSON string describing the component's lore properties (e.g., '{\"Essence_Type\": \"Perception\", \"Aetheric_Affinity\": \"Psionic\"}').", required: false },
            { name: 'exportSVG', type: 'boolean', description: "Generate an SVG footprint of the component. (Used for demo visualization)", required: false },
            { name: 'exportGLB', type: 'boolean', description: "Generate a 3D GLB model of the component. (Used for demo visualization)", required: false }
        ],
        implementationCode: 'kicad_service_proxy::define_component'
    },
    {
        name: 'Define KiCad Net',
        description: 'Defines a single electrical connection (a net) by its name and the component pins it connects. This must be called for every net in the schematic design.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: "To translate a logical connection from an electronic schematic into a physical requirement for the PCB layout, defining the electrical conductivity paths between components.",
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'netName', type: 'string', description: "The name of the net (e.g., 'GND', 'VCC', 'DATA0').", required: true },
            { name: 'pins', type: 'array', description: 'An array of component pin strings to connect to this net (e.g., ["U1-1", "R1-2"]).', required: true },
            { name: 'ritualDescription', type: 'string', description: "Optional: A lore-friendly description of the magical act of creating this connection.", required: false },
        ],
        implementationCode: 'kicad_service_proxy::define_net'
    },
    {
        name: 'Generate KiCad Netlist',
        description: 'Generates the final KiCad netlist file from all previously defined components and nets. This is the bridge between the schematic and the PCB layout stages.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To consolidate all defined components and nets into a single, machine-readable netlist file that serves as the blueprint for the physical PCB layout and routing.',
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::generate_netlist'
    },
    {
        name: 'Create Initial PCB',
        description: 'Creates a blank .kicad_pcb file and imports the generated netlist, placing all component footprints at the origin, ready for arrangement. Creates a 4-layer board by default.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To create the physical board file and load all the component footprints into it, officially starting the physical design phase of the hardware project.',
        parameters: [{ name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true }],
        implementationCode: 'kicad_service_proxy::create_initial_pcb'
    },
    {
        name: 'Create Board Outline',
        description: 'Defines the physical shape and size of the PCB. Can be a fixed-size rectangle/circle, or a dynamic rectangle that auto-sizes to fit component placement.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To define the physical dimensions and shape of the final printed circuit board, a critical step for mechanical fitting and manufacturing.',
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'shape', type: 'string', description: "The shape of the board outline. Can be 'rectangle' or 'circle'. Defaults to 'rectangle'.", required: false },
            { name: 'boardWidthMillimeters', type: 'number', description: "For 'rectangle' shape, the desired width in mm. Omit or set to 0 for dynamic auto-sizing based on component placement.", required: false },
            { name: 'boardHeightMillimeters', type: 'number', description: "For 'rectangle' shape, the desired height in mm. Omit or set to 0 for dynamic auto-sizing.", required: false },
            { name: 'diameterMillimeters', type: 'number', description: "For 'circle' shape, the desired diameter in mm. If omitted, it will auto-size to fit components.", required: false },
        ],
        implementationCode: 'kicad_service_proxy::create_board_outline'
    },
    {
        name: 'Create Copper Pour',
        description: 'Creates a copper pour (zone) connected to a specified net on a specified layer. The zone will fill the entire board outline.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To create large copper areas, typically for ground (GND) or power planes, which improves signal integrity, provides shielding, and simplifies routing for the autorouter.',
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'layerName', type: 'string', description: 'The name of the copper layer to create the pour on (e.g., "F.Cu", "In1.Cu", "B.Cu").', required: true },
            { name: 'netName', type: 'string', description: 'The name of the net to connect the pour to (e.g., "GND", "VCC").', required: true },
        ],
        implementationCode: 'kicad_service_proxy::create_copper_pour'
    },
    {
        name: 'Arrange Components',
        description: "Extracts component and net data from the PCB file and sends it to the client for interactive or autonomous layout. This step organizes the physical placement of components.",
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To bridge the gap between the abstract electronic schematic and the physical PCB reality by generating an initial component placement, which is the foundational step for routing and manufacturing.',
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'waitForUserInput', type: 'boolean', description: "Set to 'true' to pause the workflow for interactive manual layout on the client. Set to 'false' to perform an autonomous layout on the client and continue the workflow automatically.", required: true },
            { name: 'layoutStrategy', type: 'string', description: "The layout engine to use: 'agent' for rule-based, 'physics' for Rapier.js simulation. Defaults to 'agent'.", required: false },
        ],
        implementationCode: 'kicad_service_proxy::arrange_components'
    },
    {
        name: 'Update KiCad Component Positions',
        description: 'Updates the positions of components on the .kicad_pcb file and automatically calculates a new board outline to tightly fit the placed components.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To commit the refined component layout from the arrangement stage back to the KiCad board file and create the final, optimized board outline for manufacturing.',
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
            { name: 'componentPositionsJSON', type: 'string', description: `A JSON string of an object mapping component references to their new {x, y, rotation, side} coordinates. Example: '{"U1": {"x": 10, "y": 15, "rotation": 90, "side": "top"}, "R1": {"x": 25, "y": 15, "rotation": 0, "side": "bottom"}}'.`, required: true },
            { name: 'boardPadding', type: 'number', description: 'Optional margin in mm to add around components when auto-sizing the board outline.', required: false },
        ],
        implementationCode: 'kicad_service_proxy::update_component_positions'
    },
    {
        name: 'Autoroute PCB',
        description: 'Automatically routes the copper traces between components on the PCB based on the netlist. It exports to a DSN file, runs an external autorouter, and imports the results.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To automatically create the copper traces that form the electrical connections between components, transforming the placed board into a functional electronic circuit.',
        parameters: [
            { name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true },
        ],
        implementationCode: 'kicad_service_proxy::autoroute_pcb'
    },
    {
        name: 'Export Fabrication Files',
        description: 'Generates all necessary manufacturing outputs (Gerbers, drill files, 3D model) and packages them into a zip file, ready for a PCB fabrication house.',
        category: 'Server',
        executionEnvironment: 'Server',
        purpose: 'To produce the final, complete manufacturing dataset required by a factory to produce the physical electronic device, marking the successful culmination of the hardware design process.',
        parameters: [{ name: 'projectName', type: 'string', description: 'The unique name for this hardware project.', required: true }],
        implementationCode: 'kicad_service_proxy::export_fabrication_files'
    },
    {
        name: 'Update Workflow Checklist',
        description: "Communicates the agent's plan for a specific workflow stage to the UI, which renders a detailed checklist. Used to track progress within complex steps like defining dozens of components.",
        category: 'Functional',
        executionEnvironment: 'Client',
        purpose: "To provide granular, real-time progress updates of the PCB design process to the user by showing the agent's detailed plan and tracking its completion.",
        parameters: [
            { name: 'workflowStepName', type: 'string', description: 'The name of the workflow step this checklist applies to (e.g., "Define Components").', required: true },
            { name: 'checklistItems', type: 'array', description: 'An array of strings representing the sub-tasks for this step (e.g., ["U1", "C1", "R1"]).', required: true },
        ],
        implementationCode: `
            // This is a special client-side tool. Its logic is handled inside useAppRuntime
            // to directly update the state in useKicadManager.
            // It requires no further implementation here as it's a state management trigger.
            return { success: true, message: \`UI checklist updated for step: \${args.workflowStepName}\` };
        `
    }
];

const WORKFLOW_STAGES_TOOL: ToolCreatorPayload = {
    name: 'Workflow Stages',
    description: 'A UI panel that displays the agent\'s progress through the KiCad workflow stages.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide the user with a clear, high-level, interactive view of the agent\'s progress and actions during the PCB design process.',
    parameters: [
        { name: 'workflowSteps', type: 'array', description: 'List of workflow stages and their status.', required: true },
    ],
    implementationCode: `
        return (
            <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 text-white">
                <h3 className="text-lg font-bold text-indigo-300 mb-3">Project Workflow</h3>
                <div className="space-y-4">
                    {workflowSteps.map((step, index) => {
                        const isCompleted = step.status === 'completed';
                        const isInProgress = step.status === 'in-progress';
                        
                        let statusColor = 'border-gray-600';
                        if (isInProgress) statusColor = 'border-indigo-500';
                        if (isCompleted) statusColor = 'border-green-500';

                        return (
                            <div key={index} className={\`p-3 rounded-lg bg-gray-900/50 border-l-4 \${statusColor}\`}>
                                <div className="flex items-center justify-between">
                                    <div>
                                        <p className="font-semibold text-gray-400 text-sm">STAGE {index + 1}: {step.role}</p>
                                        <h4 className="font-bold text-white text-base">{step.name}</h4>
                                        <p className="text-xs text-gray-400">{step.description}</p>
                                    </div>
                                    <div className="flex items-center justify-center w-8 h-8 rounded-full bg-gray-700">
                                        {isCompleted && <span className="text-green-400 text-xl">✓</span>}
                                        {isInProgress && <div className="w-4 h-4 rounded-full bg-indigo-500 animate-pulse"></div>}
                                    </div>
                                </div>
                            </div>
                        )
                    })}
                </div>
            </div>
        );
    `
};

const LEAD_ENGINEER_WORKBENCH_TOOL: ToolCreatorPayload = {
    name: 'Lead Engineer Workbench',
    description: 'The main UI for the KiCad workflow, orchestrating all sub-panels for layout, heuristics, and progress monitoring, following a human-in-the-loop Holacracy model.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide a user-friendly, all-in-one interface for the complex hardware generation workflow, managed by an AI swarm and directed by a human Lead Engineer.',
    parameters: [
        // Core State & Setters
        { name: 'userInput', type: 'string', description: 'Current value of the input.', required: true },
        { name: 'setUserInput', type: 'object', description: 'Function to update the input value.', required: true },
        { name: 'isSwarmRunning', type: 'boolean', description: 'Flag indicating if the agent is running.', required: true },
        { name: 'workflowSteps', type: 'array', description: 'List of workflow stages and their status.', required: true },
        { name: 'currentLayoutData', type: 'object', description: 'Graph data for the interactive layout tool.', required: true },
        { name: 'isLayoutInteractive', type: 'boolean', description: 'Flag for interactive layout mode.', required: true },
        { name: 'layoutHeuristics', type: 'object', description: 'Current heuristics for the layout simulation.', required: false },
        { name: 'visibility', type: 'object', description: 'Visibility flags for different layers.', required: true },
        { name: 'isServerConnected', type: 'boolean', description: 'Flag for server connection status.', required: true },
        { name: 'isAutonomousMode', type: 'boolean', description: 'Flag indicating if the agent is in autonomous mode.', required: true },
        { name: 'demoScripts', type: 'array', description: 'Array of available demo workflow scripts.', required: true },
        { name: 'currentUserTask', type: 'object', description: 'The current high-level task object for the agent.', required: true },
        
        // Callbacks & Handlers
        { name: 'onStartTask', type: 'object', description: 'Function to start the main design task.', required: true },
        { name: 'onCommitLayout', type: 'object', description: 'Callback to commit the final layout.', required: true },
        { name: 'onUpdateLayout', type: 'object', description: 'Callback to update layout data.', required: true },
        { name: 'setLayoutHeuristics', type: 'object', description: 'Function to update layout heuristics.', required: true },
        { name: 'setVisibility', type: 'object', description: 'Function to update layer visibility.', required: true },
        { name: 'setIsAutonomousMode', type: 'object', description: 'Function to set the autonomous mode.', required: true },
        
        // Agent Dependencies
        { name: 'startSwarmTask', type: 'object', description: 'Function to start an agent task.', required: true },
        { name: 'allTools', type: 'array', description: 'List of all available tools.', required: true },
        { name: 'getKicadSystemPrompt', type: 'object', description: 'Function to get the system prompt.', required: true },
        { name: 'getTool', type: 'object', description: 'Function to retrieve a tool definition.', required: true },
        
        // Scripted Workflow Props
        { name: 'scriptExecutionState', type: 'string', description: 'The current state of the script execution engine.', required: true },
        { name: 'currentScriptStepIndex', type: 'number', description: 'The index of the currently executing script step.', required: true },
        { name: 'stepStatuses', type: 'array', description: 'An array tracking the status of each script step.', required: true },
        { name: 'onPlayPause', type: 'object', description: 'Callback to play or pause script execution.', required: true },
        { name: 'onStop', type: 'object', description: 'Callback to stop script execution.', required: true },
        { name: 'onStepForward', type: 'object', description: 'Callback to execute the next step.', required: true },
        { name: 'onStepBackward', type: 'object', description: 'Callback to move the execution pointer back one step.', required: true },
        { name: 'onRunFromStep', type: 'object', description: 'Callback to start execution from a specific step.', required: true },
    ],
    implementationCode: `
        const [selectedInspectorId, setSelectedInspectorId] = React.useState(null);
        const [selectedScript, setSelectedScript] = React.useState('');
        
        const handleSubmit = () => {
            if (!userInput.trim()) return;
            onStartTask({ prompt: userInput, files: [], urls: [], useSearch: false, isAutonomous: isAutonomousMode }, startSwarmTask, allTools, getKicadSystemPrompt);
        };
        
        const handleRunScript = () => {
            if (!selectedScript) return;
            const scriptToRun = demoScripts.find(s => s.name === selectedScript);
            if (scriptToRun) {
                const projectName = \`proj_\${Date.now()}\`;
                const task = {
                    isScripted: true,
                    script: scriptToRun.workflow,
                    projectName: projectName
                };
                startSwarmTask({ task, systemPrompt: getKicadSystemPrompt(projectName), sequential: true, allTools });
            }
        };
        
        const isExecutingScript = scriptExecutionState !== 'idle' && currentUserTask?.isScripted;
        
        const layoutProps = { graph: currentLayoutData, layoutStrategy: currentLayoutData?.layoutStrategy || 'agent', mode: 'pcb', isLayoutInteractive: isLayoutInteractive, onCommit: onCommitLayout, onUpdateLayout: onUpdateLayout, getTool: getTool, heuristics: layoutHeuristics, isServerConnected: isServerConnected, visibility: visibility };
        const rulesProps = { rules: currentLayoutData?.rules || [], onUpdateRules: (newRules) => onUpdateLayout(prev => ({ ...prev, rules: newRules })) };
        const visibilityProps = { visibility, setVisibility };
        const selectedNode = React.useMemo(() => currentLayoutData?.nodes?.find(n => n.id === selectedInspectorId) || null, [selectedInspectorId, currentLayoutData?.nodes]);
        const inspectorProps = { graph: currentLayoutData, debugInfo: {}, selectedId: selectedInspectorId, selectedNode, onSelect: setSelectedInspectorId, onHover: () => {} };
        const workflowControllerProps = {
            workflow: currentUserTask?.script || [],
            executionState: scriptExecutionState,
            currentStepIndex: currentScriptStepIndex,
            stepStatuses: stepStatuses,
            onPlayPause, onStop, onStepForward, onStepBackward, onRunFromStep
        };

        return (
            <div className="h-full w-full grid grid-cols-12 gap-4">
                <div className="col-span-3 h-full flex flex-col gap-4">
                    {isExecutingScript ? (
                        <UIToolRunner tool={getTool('Interactive Workflow Controller')} props={workflowControllerProps} />
                    ) : (
                        <UIToolRunner tool={getTool('Workflow Stages')} props={{ workflowSteps }} />
                    )}
                </div>
                
                <div className="col-span-6 h-full flex flex-col gap-4">
                    {!isSwarmRunning && (
                         <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 space-y-4">
                             <div>
                                <h3 className="text-lg font-bold text-indigo-300 mb-2">1. Process Tension: Design a new PCB</h3>
                                <textarea value={userInput} onChange={(e) => setUserInput(e.target.value)} placeholder="e.g., An 8-channel EEG board based on the ADS131M08..." className="w-full h-24 p-3 bg-gray-900 border border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500" />
                                <div className="flex items-center justify-between mt-2">
                                    <div className="flex items-center"><input type="checkbox" id="autonomous-mode" checked={isAutonomousMode} onChange={(e) => setIsAutonomousMode(e.target.checked)} className="h-4 w-4 rounded border-gray-500 bg-gray-700 text-indigo-500" /><label htmlFor="autonomous-mode" className="ml-2 text-sm text-gray-300">Autonomous Mode</label></div>
                                    <button onClick={handleSubmit} disabled={!userInput.trim()} className="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-indigo-700 disabled:bg-gray-600">Start Task</button>
                                </div>
                            </div>
                            <div className="border-t border-gray-700 pt-3">
                                <h3 className="text-lg font-bold text-purple-300 mb-2">OR: Run a Demo Scenario</h3>
                                <div className="flex gap-2">
                                    <select value={selectedScript} onChange={e => setSelectedScript(e.target.value)} className="flex-grow bg-gray-900 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-indigo-500"><option value="">Select a demo script...</option>{demoScripts.map(s => <option key={s.name} value={s.name}>{s.name}</option>)}</select>
                                    <button onClick={handleRunScript} disabled={!selectedScript} className="bg-purple-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-purple-700 disabled:bg-gray-600">Run Script</button>
                                </div>
                            </div>
                         </div>
                    )}
                    <div className="flex-grow min-h-0">
                       <UIToolRunner tool={getTool('Interactive PCB Layout Tool')} props={layoutProps} />
                    </div>
                </div>

                <div className="col-span-3 h-full flex flex-col gap-4">
                    <div className="flex-1 min-h-0"><UIToolRunner tool={getTool('Inspector')} props={inspectorProps} /></div>
                    <div className="flex-1 min-h-0"><UIToolRunner tool={getTool('Layout Rules')} props={rulesProps} /></div>
                    <UIToolRunner tool={getTool('Visibility')} props={visibilityProps} />
                </div>
            </div>
        );
    `
};


const KICAD_INSTALLER_TOOL: ToolCreatorPayload = {
    name: 'Install KiCad Engineering Suite',
    description: 'Installs the complete KiCad suite. This one-time action creates all required client-side tools for PCB design simulation. This MUST be called before any other KiCad tool.',
    category: 'Automation',
    executionEnvironment: 'Client',
    purpose: "To fully bootstrap the agent's hardware engineering capabilities by installing all necessary tool definitions for the client-side simulation.",
    parameters: [],
    implementationCode: `
        // --- Step 1: Write the new Python service scripts to the server ---
        const scriptsToWrite = [
            { name: 'kicad_service.py', content: ${JSON.stringify(KICAD_SERVICE_SCRIPT)} },
            { name: 'kicad_service_commands.py', content: ${JSON.stringify(KICAD_SERVICE_COMMANDS_SCRIPT)} },
            { name: 'kicad_dsn_utils.py', content: ${JSON.stringify(KICAD_DSN_UTILS_SCRIPT)} },
            { name: 'kicad_ses_utils.py', content: ${JSON.stringify(KICAD_SES_UTILS_SCRIPT)} },
        ];
        
        runtime.logEvent(\`[INFO] Writing \${scriptsToWrite.length} KiCad Python service scripts to the server...\`);
        if (runtime.isServerConnected()) {
            for (const script of scriptsToWrite) {
                try {
                    await runtime.tools.run('Server File Writer', { filePath: script.name, content: script.content });
                } catch (e) {
                    runtime.logEvent(\`[WARN] Failed to write script '\${script.name}' to server: \${e.message}\`);
                }
            }
            runtime.logEvent('[INFO] KiCad Python service scripts written successfully.');
        } else {
             runtime.logEvent('[INFO] Server not connected. Skipping Python script creation. KiCad tools will be simulated.');
        }

        // --- Step 2: Create the tool definitions ---
        const toolPayloads = [
            ...${JSON.stringify(KICAD_TOOL_DEFINITIONS)},
            ${JSON.stringify(LEAD_ENGINEER_WORKBENCH_TOOL)},
            ${JSON.stringify(WORKFLOW_STAGES_TOOL)}
        ];

        runtime.logEvent(\`[INFO] Creating \${toolPayloads.length} KiCad tools...\`);
        const allTools = runtime.tools.list();
        const existingToolNames = new Set(allTools.map(t => t.name));

        for (const payload of toolPayloads) {
            if (existingToolNames.has(payload.name)) {
                runtime.logEvent(\`[INFO] Tool '\${payload.name}' already exists. Skipping installation.\`);
                continue;
            }
            try {
                await runtime.tools.run('Tool Creator', payload);
            } catch (e) {
                runtime.logEvent(\`[WARN] Failed to create new tool '\${payload.name}'. Error: \${e.message}\`);
            }
        }
        
        if (runtime.isServerConnected()) {
            try {
                const { count } = await runtime.forceRefreshServerTools();
                runtime.logEvent(\`[INFO] Client state synchronized with server. \${count} server tools loaded.\`);
            } catch (e) {
                runtime.logEvent(\`[ERROR] Failed to force-refresh server tools after installation: \${e.message}\`);
            }
        }
        
        return { success: true, message: 'KiCad Engineering Suite and all associated tools installed successfully.' };
    `
};

export const KICAD_TOOLS: ToolCreatorPayload[] = [
    KICAD_INSTALLER_TOOL,
];

```

# bootstrap/index.ts
```bootstrap/index.ts
import type { ToolCreatorPayload } from '../types';

import { AUTOMATION_TOOLS } from './automation_tools';
import { UI_CONFIG_TOOLS } from './ui_config_tools';
import { UI_DISPLAY_TOOLS } from './ui_display_tools';
import { KICAD_TOOLS } from './kicad_tools';
import { ROBOTICS_TOOLS } from './robotics_tools';
import { UI_AGENT_TOOLS } from './ui_agent_tools';
import { PHYSICS_LAYOUT_TOOLS } from './rapier_layout_tool';
import { STRATEGY_TOOLS } from './strategy_tools';
import { WORKFLOW_CAPTURE_PANEL_TOOL } from './post_run_tools';
import { UI_WORKFLOW_TOOLS } from './ui_demo_tools';
import { LAYOUT_RULES_TOOLS } from './ui_layout_rules_tools';
import { UI_LAYOUT_HEURISTICS_TOOLS } from './ui_layout_heuristics_tools';
import { INSPECTOR_TOOL_PAYLOAD } from './ui_inspector_tool';
import { UI_LAYOUT_TOOLS } from './ui_layout_tools';
import { SIMULATION_TOOLS } from './simulation_tools';
import { DATASHEET_TOOLS } from './datasheet_tools';
import { AETHERIUM_TOOLS, AETHERIUM_CLIENT_TOOL_PAYLOAD } from './aetherium_tools';
import { NEUROFEEDBACK_TOOLS } from './neurofeedback_tools';
import { SUPPLY_CHAIN_TOOLS } from './supply_chain_tools';
import { UI_SYSTEM_TOOLS } from './ui_system_tools';


export const BOOTSTRAP_TOOL_PAYLOADS: ToolCreatorPayload[] = [
    ...AUTOMATION_TOOLS,
    ...UI_CONFIG_TOOLS,
    ...UI_DISPLAY_TOOLS,
    ...KICAD_TOOLS,
    ...ROBOTICS_TOOLS,
    ...UI_AGENT_TOOLS,
    ...PHYSICS_LAYOUT_TOOLS,
    ...STRATEGY_TOOLS,
    ...SIMULATION_TOOLS,
    ...DATASHEET_TOOLS,
    ...AETHERIUM_TOOLS,
    AETHERIUM_CLIENT_TOOL_PAYLOAD,
    ...NEUROFEEDBACK_TOOLS,
    ...SUPPLY_CHAIN_TOOLS,
    WORKFLOW_CAPTURE_PANEL_TOOL,
    ...UI_WORKFLOW_TOOLS,
    ...LAYOUT_RULES_TOOLS,
    ...UI_LAYOUT_HEURISTICS_TOOLS,
    INSPECTOR_TOOL_PAYLOAD,
    ...UI_LAYOUT_TOOLS,
    ...UI_SYSTEM_TOOLS,
];
```

# bootstrap/ui_agent_tools.ts
```bootstrap/ui_agent_tools.ts
import type { ToolCreatorPayload } from '../types';

export const UI_AGENT_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'Agent Control Panel',
        description: 'A unified UI for managing the robotics simulation, including defining agents, controlling the simulation, and manual piloting for skill observation.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide a comprehensive control interface for the robotics simulation and learning environment.',
        parameters: [
          { name: 'robotState', type: 'object', description: 'The current state of all robots and the environment.', required: true },
          { name: 'personalities', type: 'array', description: 'The defined personalities for the agents.', required: true },
          { name: 'handleManualControl', type: 'object', description: 'Function to execute a manual command.', required: true },
        ],
        implementationCode: `
          const { robotStates, environmentState, observationHistory } = robotState;
          
          const pilotAgentId = 'Mind-Weaver-1'; // Pilot the Mind Weaver creature

          const handleDefineAgent = () => {
              // Deploys a team for the mission
              handleManualControl('Define Robot Agent', { id: 'Mind-Weaver-1', asset_glb: 'game/creatures/creature_schematic_mind_weaver_ads131m08.glb', startX: 2, startY: 2, behaviorType: 'seek_target', targetId: 'red_car_1' });
              // You can define other agents here if needed, for example a resource collector for depleted batteries.
          };
          
          // --- Multi-input Control System ---
          const [gamepadStatus, setGamepadStatus] = React.useState('Disconnected');
          const joystickBaseRef = React.useRef(null);
          const joystickKnobRef = React.useRef(null);
          const inputState = React.useRef({
              joyX: 0, joyY: 0, joyActive: false,
              keyF: 0, keyB: 0, keyL: 0, keyR: 0,
              padX: 0, padY: 0, padConnected: false,
          });
          const lastCommandTimeRef = React.useRef(0);
          const animationFrameId = React.useRef(null);
          
          const COMMAND_INTERVAL = 150; // ms between commands

          React.useEffect(() => {
            const handleGamepadConnected = (e) => {
                inputState.current.padConnected = true;
                setGamepadStatus(\`Connected: \${e.gamepad.id}\`);
            };
            const handleGamepadDisconnected = (e) => {
                inputState.current.padConnected = false;
                setGamepadStatus('Disconnected');
            };
            window.addEventListener('gamepadconnected', handleGamepadConnected);
            window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);

            const handleKeyDown = (e) => {
                if (e.repeat) return;
                if (e.key === 'w' || e.key === 'ArrowUp') inputState.current.keyF = 1;
                if (e.key === 's' || e.key === 'ArrowDown') inputState.current.keyB = 1;
                if (e.key === 'a' || e.key === 'ArrowLeft') inputState.current.keyL = 1;
                if (e.key === 'd' || e.key === 'ArrowRight') inputState.current.keyR = 1;
            };
            const handleKeyUp = (e) => {
                if (e.key === 'w' || e.key === 'ArrowUp') inputState.current.keyF = 0;
                if (e.key === 's' || e.key === 'ArrowDown') inputState.current.keyB = 0;
                if (e.key === 'a' || e.key === 'ArrowLeft') inputState.current.keyL = 0;
                if (e.key === 'd' || e.key === 'ArrowRight') inputState.current.keyR = 0;
            };
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            const base = joystickBaseRef.current;
            const knob = joystickKnobRef.current;
            if (!base || !knob) return;
            
            const handlePointerDown = (e) => {
                e.preventDefault();
                inputState.current.joyActive = true;
            };
            const handlePointerMove = (e) => {
                if (!inputState.current.joyActive) return;
                e.preventDefault();
                const rect = base.getBoundingClientRect();
                const size = rect.width;
                const halfSize = size / 2;
                let x = e.clientX - rect.left - halfSize;
                let y = e.clientY - rect.top - halfSize;
                const dist = Math.min(halfSize, Math.hypot(x, y));
                const angle = Math.atan2(y, x);
                x = Math.cos(angle) * dist;
                y = Math.sin(angle) * dist;
                knob.style.transform = \`translate(-50%, -50%) translate(\${x}px, \${y}px)\`;
                inputState.current.joyX = x / halfSize;
                inputState.current.joyY = y / halfSize;
            };
            const handlePointerUp = (e) => {
                e.preventDefault();
                inputState.current.joyActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                inputState.current.joyX = 0;
                inputState.current.joyY = 0;
            };
            
            base.addEventListener('pointerdown', handlePointerDown);
            window.addEventListener('pointermove', handlePointerMove);
            window.addEventListener('pointerup', handlePointerUp);

            const gameLoop = () => {
                const now = performance.now();
                
                if (inputState.current.padConnected) {
                    const gp = navigator.getGamepads()[0];
                    if (gp) {
                        const deadzone = 0.2;
                        const rawX = gp.axes[0] || 0;
                        const rawY = gp.axes[1] || 0;
                        inputState.current.padX = Math.abs(rawX) > deadzone ? rawX : 0;
                        inputState.current.padY = Math.abs(rawY) > deadzone ? rawY : 0;
                    }
                }
                
                // Combine inputs (gamepad takes precedence)
                const finalY = inputState.current.padConnected ? -inputState.current.padY : -inputState.current.joyY + (inputState.current.keyF - inputState.current.keyB);
                const finalX = inputState.current.padConnected ? inputState.current.padX : inputState.current.joyX + (inputState.current.keyR - inputState.current.keyL);

                if (now - lastCommandTimeRef.current > COMMAND_INTERVAL) {
                    let command = null;
                    if (finalY > 0.5) command = 'Move Forward';
                    else if (finalY < -0.5) command = 'Move Backward';
                    else if (finalX < -0.5) command = 'Turn Left';
                    else if (finalX > 0.5) command = 'Turn Right';
                    
                    if (command) {
                        handleManualControl(command, { agentId: pilotAgentId });
                        lastCommandTimeRef.current = now;
                    }
                }
                animationFrameId.current = requestAnimationFrame(gameLoop);
            };
            gameLoop();

            return () => {
                window.removeEventListener('gamepadconnected', handleGamepadConnected);
                window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
                window.removeEventListener('keydown', handleKeyDown);
                window.removeEventListener('keyup', handleKeyUp);
                if (base) base.removeEventListener('pointerdown', handlePointerDown);
                window.removeEventListener('pointermove', handlePointerMove);
                window.removeEventListener('pointerup', handlePointerUp);
                if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);
            };
          }, [handleManualControl]);

          return (
            <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 space-y-4">
              <h3 className="text-lg font-bold text-indigo-300">Robotics Control</h3>
              
              <div className="grid grid-cols-3 gap-2">
                <button onClick={() => handleManualControl('Start Robot Simulation')} className="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-lg">Start</button>
                <button onClick={() => handleManualControl('Step Robot Simulation')} className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-lg">Step</button>
                <button onClick={() => handleManualControl('Stop Robot Simulation')} className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-3 rounded-lg">Stop</button>
              </div>

              <button onClick={handleDefineAgent} className="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-3 rounded-lg">Define Agents</button>
              
              <div className="pt-2 border-t border-gray-700">
                  <h4 className="font-semibold text-gray-300 text-center mb-2">Manual Pilot for {pilotAgentId}</h4>
                  <p className="text-xs text-center text-gray-400 mb-2">Use Joystick, WASD/Arrows, or connect a Gamepad.</p>
                  <div className="flex items-center justify-center gap-4">
                      <div ref={joystickBaseRef} className="relative w-32 h-32 bg-gray-700/50 rounded-full flex-shrink-0 touch-none select-none">
                          <div ref={joystickKnobRef} className="absolute w-16 h-16 bg-gray-500 rounded-full border-2 border-gray-400" style={{ top: '50%', left: '50%', transform: 'translate(-50%, -50%)', transition: 'transform 0.1s' }}></div>
                      </div>
                      <div className="flex flex-col gap-2">
                          <button onClick={() => handleManualControl('Create Skill From Observation', { skillName: 'LearnedPatrol', skillDescription: 'A pattern learned from manual piloting.' })} className="bg-yellow-600 hover:bg-yellow-500 rounded-lg p-3 text-sm font-bold">
                              Learn Skill
                          </button>
                          <div className="text-center text-xs p-2 bg-gray-900/50 rounded-lg">
                              <p className="font-semibold text-gray-300">Gamepad:</p>
                              <p className={\`\${inputState.current.padConnected ? 'text-green-400' : 'text-gray-500'}\`}>
                                  {gamepadStatus}
                              </p>
                          </div>
                      </div>
                  </div>
              </div>
              
               <div className="pt-2 border-t border-gray-700">
                  <h4 className="font-semibold text-gray-300 mb-2">Agent Status</h4>
                   <div className="space-y-2 max-h-48 overflow-y-auto">
                     {personalities.map(p => {
                        const activeAgent = robotStates.find(r => r.id === p.id);
                        const statusColor = activeAgent ? 'text-green-400' : 'text-yellow-400';
                        const statusText = activeAgent ? 'Active' : 'Defined';

                        const powerLevel = activeAgent?.powerLevel || 0;
                        const powerColor = powerLevel > 50 ? 'text-green-400' : powerLevel > 20 ? 'text-yellow-400' : 'text-red-500';

                        return (
                           <div key={p.id} className="bg-gray-900/50 p-2 rounded-lg text-sm">
                                <div className="flex justify-between">
                                   <span className="font-bold">{p.id}</span>
                                   <span className={\`font-mono \${statusColor}\`}>{statusText}</span>
                                </div>
                                {activeAgent ? (
                                    <div className="font-mono text-xs text-gray-400 flex justify-between items-center">
                                      <span>({activeAgent.x.toFixed(0)}, {activeAgent.y.toFixed(0)}) rot: {activeAgent.rotation}°</span>
                                      <span className={powerColor}>PWR: {powerLevel}%</span>
                                    </div>
                                ) : (
                                    <div className="font-mono text-xs text-gray-400">Behavior: {p.behaviorType}</div>
                                )}
                           </div>
                        );
                     })}
                     {personalities.length === 0 && <p className="text-gray-500 text-sm">No agents defined.</p>}
                   </div>
               </div>
            </div>
          );
        `
    },
    {
        name: 'Agent Status Display',
        description: 'Visualizes the status and activity of the agent swarm master.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: "To provide a real-time visualization of the agent's state, actions, and health.",
        parameters: [
          { name: 'agentSwarm', type: 'array', description: 'The array of agent workers (usually just one).', required: true },
          { name: 'isSwarmRunning', type: 'boolean', description: 'Whether the agent is running.', required: true },
          { name: 'handleStopSwarm', type: 'object', description: 'Function to stop the agent task.', required: true },
          { name: 'currentUserTask', type: 'object', description: 'The current high-level task for the agent.', required: true },
        ],
        implementationCode: `
              if (!isSwarmRunning && (!agentSwarm || agentSwarm.length === 0 || agentSwarm.every(a => a.status === 'idle'))) {
                  return (
                      <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 h-full flex items-center justify-center">
                          <p className="text-gray-400 text-center">Agent is idle. Assign a task to activate.</p>
                      </div>
                  );
              }
      
              return (
                  <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 h-full flex flex-col">
                     <div className="flex-shrink-0 flex flex-col sm:flex-row justify-between items-center gap-2 mb-4">
                        <div>
                           <h3 className="text-lg font-bold text-indigo-300">Agent Status</h3>
                           <p className="text-sm text-gray-400 truncate">Goal: {currentUserTask?.userRequest?.text || 'None'}</p>
                        </div>
                        <button
                            onClick={() => handleStopSwarm()}
                            disabled={!isSwarmRunning}
                            className="px-4 py-2 font-semibold rounded-lg transition-colors text-white bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed"
                        >
                            Stop Task
                        </button>
                      </div>
                  </div>
              );
          `
    }
];
```

# bootstrap/local_ai_tools.ts
```bootstrap/local_ai_tools.ts

import type { ToolCreatorPayload } from '../types';

// The Python server script is removed as it's not used in the client-only demo.
export const GEMMA_SERVER_SCRIPT = ``;

export const LOCAL_AI_PANEL_TOOL_PAYLOAD: ToolCreatorPayload = {
    name: 'Local AI Server Panel',
    description: 'A self-contained control panel for managing the local multimodal AI server. It handles its own state and uses provided functions to interact with server tools.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide a user-friendly interface for managing the local AI server, which grants the agent advanced multimodal capabilities.',
    parameters: [
      { name: 'logEvent', type: 'object', description: 'Function to log events to the main debug log.', required: true },
    ],
    implementationCode: `
      return (
        <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 space-y-4 text-center">
          <h3 className="text-lg font-bold text-indigo-300">Local AI Server</h3>
            <div className="flex items-center justify-center gap-2 mt-1">
              <div className={'w-3 h-3 rounded-full bg-yellow-500'}></div>
              <p className="text-sm text-gray-300">
                Feature Disabled
              </p>
            </div>
            <p className="text-xs text-gray-400 mt-2">
              The local multimodal AI server requires a Node.js backend to run Python scripts. This feature is disabled in the client-only demo.
            </p>
             <div className="flex flex-wrap gap-2 mt-4">
                <button disabled className="flex-1 bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg disabled:cursor-not-allowed">Start</button>
                <button disabled className="flex-1 bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg disabled:cursor-not-allowed">Stop</button>
             </div>
        </div>
      );
    `
};
```

# bootstrap/kicad_ses_utils.ts
```bootstrap/kicad_ses_utils.ts
// bootstrap/kicad_ses_utils.ts
export const KICAD_SES_UTILS_SCRIPT = `
import sys
import os
import traceback
import json
import re

# Deferred pcbnew import
pcbnew = None

def _initialize_pcbnew():
    global pcbnew
    if pcbnew is None:
        try:
            sys.path.insert(0, '/usr/lib/python3/dist-packages') # This can be problematic, better to rely on system path
            import pcbnew as pcbnew_lib
            pcbnew = pcbnew_lib
        except ImportError:
            raise RuntimeError("KiCad's pcbnew library not found for SES parsing.")

def log_error_and_exit(message):
    print(json.dumps({"error": message, "trace": traceback.format_exc()}), file=sys.stderr)
    sys.exit(1)

def tokenize_s_expression(text):
    """A robust, character-by-character tokenizer for S-expressions."""
    tokens = []
    in_quote = False
    current_token = ''
    i = 0
    while i < len(text):
        char = text[i]
        if in_quote:
            if char == '\\\\' and i + 1 < len(text):
                current_token += text[i+1]
                i += 1
            elif char == '"':
                in_quote = False
                tokens.append(f'"{current_token}"')
                current_token = ''
            else:
                current_token += char
        elif char in '()':
            if current_token:
                tokens.append(current_token)
                current_token = ''
            tokens.append(char)
        elif char.isspace():
            if current_token:
                tokens.append(current_token)
                current_token = ''
        elif char == '"':
            if current_token:
                tokens.append(current_token)
                current_token = ''
            in_quote = True
        else:
            current_token += char
        i += 1
    if current_token:
        tokens.append(current_token)
    return tokens


def parse_s_expression_recursive(tokens):
    """Recursively parses a list of tokens into an S-expression AST."""
    if not tokens:
        raise ValueError("Unexpected EOF while parsing S-expression.")
    
    token = tokens.pop(0)
    if token == '(':
        ast = []
        while tokens and tokens[0] != ')':
            ast.append(parse_s_expression_recursive(tokens))
        if not tokens or tokens.pop(0) != ')':
            raise ValueError("Missing ')' in S-expression.")
        return ast
    elif token == ')':
        raise ValueError("Unexpected ')' in S-expression.")
    else:
        # It's an atom.
        if token.startswith('"') and token.endswith('"'):
            return token[1:-1] # Unquote string
        try:
            return int(token)
        except ValueError:
            try:
                return float(token)
            except ValueError:
                return token # It's a symbol (string without quotes)

def find_node_recursively(ast_list, key):
    """Recursively finds the first node starting with a specific key in a list of ASTs."""
    if not isinstance(ast_list, list): return None
    for item in ast_list:
        if isinstance(item, list) and item and len(item) > 0 and item[0] == key: return item
        if isinstance(item, list):
            found = find_node_recursively(item, key)
            if found: return found
    return None

def find_all_nodes(ast, key):
    """Finds all nodes starting with a specific key in a parsed AST."""
    if not isinstance(ast, list): return []
    return [node for node in ast if isinstance(node, list) and node and node[0] == key]
    
def find_node(ast, key):
    """Finds the first node starting with a specific key in a parsed AST."""
    if not isinstance(ast, list): return None
    for node in ast:
        if isinstance(node, list) and node and node[0] == key:
            return node
    return None

def parse_and_apply_ses(board, ses_path):
    """Parses a FreeRouting SES file and applies tracks and vias to the board."""
    _initialize_pcbnew()
    try:
        with open(ses_path, 'r', encoding='utf-8') as f: content = f.read()
        tokens = tokenize_s_expression(content)
        
        parsed_ast = []
        while tokens: parsed_ast.append(parse_s_expression_recursive(tokens))

        routes_node = find_node_recursively(parsed_ast, 'routes')
        if not routes_node: routes_node = find_node_recursively(parsed_ast, 'network_out')
        if not routes_node: raise ValueError("Could not find a '(routes ...)' or '(network_out ...)' block in the parsed SES file.")

        multiplier = 1000.0
        resolution_node = find_node(routes_node, 'resolution')
        if resolution_node and len(resolution_node) == 3:
            unit, value = resolution_node[1], resolution_node[2]
            if unit == 'um' and isinstance(value, (int, float)) and value > 0:
                multiplier = 1000.0 / float(value)
        
        network_node = find_node(routes_node, 'network_out') or routes_node

        for net_def in find_all_nodes(network_node, 'net'):
            net_name_from_ses = net_def[1] if len(net_def) > 1 and not isinstance(net_def[1], list) else ""
            items_to_process = net_def[2:] if net_name_from_ses else net_def[1:]
            
            original_net_name = "" if net_name_from_ses == "unnamed_net" else net_name_from_ses
            net_info = board.FindNet(original_net_name)
            if not net_info:
                print(f"Warning: Net '{original_net_name}' not found in board. Skipping.", file=sys.stderr)
                continue
            
            netclass = board.GetDesignSettings().m_NetSettings.GetDefaultNetclass()
            try:
                netclass = net_info.GetNetClassSlow()
            except AttributeError: pass

            for item in items_to_process:
                if not isinstance(item, list) or not item: continue
                item_type = item[0]
                if item_type == 'wire':
                    for path_data in find_all_nodes(item, 'path'):
                        layer_name, width, *coords = path_data[1:]
                        layer_id, width_nm = board.GetLayerID(layer_name), int(width * multiplier)
                        
                        for i in range(0, len(coords) - 2, 2):
                            start_x, start_y = coords[i], coords[i+1]
                            end_x, end_y = coords[i+2], coords[i+3]
                            
                            start_pt = pcbnew.VECTOR2I(int(start_x * multiplier), int(-start_y * multiplier))
                            end_pt = pcbnew.VECTOR2I(int(end_x * multiplier), int(-end_y * multiplier))
                            
                            track = pcbnew.PCB_TRACK(board)
                            track.SetStart(start_pt); track.SetEnd(end_pt)
                            track.SetWidth(width_nm); track.SetLayer(layer_id)
                            track.SetNet(net_info)
                            board.Add(track)
                elif item_type == 'via':
                    if len(item) < 4: continue
                    padstack_name, x, y = item[1], item[2], item[3]
                    x_nm, y_nm = int(x * multiplier), int(-y * multiplier)
                    match = re.search(r'_(\\\\d+):(\\\\d+)_um', padstack_name)
                    if match:
                        via_dia_um, via_drill_um = int(match.group(1)), int(match.group(2))
                        via_dia_nm, via_drill_nm = via_dia_um * 1000, via_drill_um * 1000
                    else:
                        via_dia_nm, via_drill_nm = netclass.GetViaDiameter(), netclass.GetViaDrill()
                        print(f"Warning: Could not parse via size from '{padstack_name}'. Falling back to netclass defaults.", file=sys.stderr)
                    via = pcbnew.PCB_VIA(board)
                    via.SetPosition(pcbnew.VECTOR2I(x_nm, y_nm))
                    via.SetNet(net_info)
                    via.SetDrill(via_drill_nm)
                    via.SetWidth(via_dia_nm)
                    via.SetLayerPair(pcbnew.F_Cu, pcbnew.B_Cu)
                    board.Add(via)
    except Exception as e:
        log_error_and_exit(f"Failed to parse and apply the routed session (SES) file '{os.path.basename(ses_path)}'. Error: {e}")
`;
```

# bootstrap/ui_system_tools.ts
```bootstrap/ui_system_tools.ts
// bootstrap/ui_system_tools.ts
import type { ToolCreatorPayload } from '../types';

export const UI_SYSTEM_TOOLS: ToolCreatorPayload[] = [
    {
        name: 'System State Manager',
        description: 'A UI panel for exporting and importing the entire application state, including all learned tools and player progress.',
        category: 'UI Component',
        executionEnvironment: 'Client',
        purpose: 'To provide a robust mechanism for users to back up, restore, and share their agent\'s progress and created tools.',
        parameters: [
            { name: 'tools', type: 'array', description: 'The current array of all LLMTools.', required: true },
            { name: 'setTools', type: 'object', description: 'Function to overwrite the current toolset.', required: true },
            { name: 'playerState', type: 'object', description: 'The current state of the player.', required: false },
            { name: 'setPlayerState', type: 'object', description: 'Function to overwrite the player state.', required: true },
            { name: 'savePlayerState', type: 'object', description: 'Function to persist the player state after import.', required: true },
        ],
        implementationCode: `
            const handleExport = () => {
                const stateToSave = {
                    tools: tools,
                    playerState: playerState,
                };
                const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // FIX: Replaced nested template literal with string concatenation to avoid a parsing error where the outer string was prematurely terminated and treated as a function.
                a.download = 'singularity_agent_state_' + new Date().toISOString().slice(0,10) + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleImport = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const text = e.target.result;
                        const importedState = JSON.parse(text);

                        if (Array.isArray(importedState.tools) && (importedState.playerState === null || typeof importedState.playerState === 'object')) {
                            if (window.confirm('This will overwrite ALL current tools and player data with the contents of this file. This cannot be undone. Are you sure?')) {
                                setTools(importedState.tools);
                                setPlayerState(importedState.playerState);
                                if (importedState.playerState) {
                                    savePlayerState(importedState.playerState);
                                }
                                alert('State imported successfully!');
                            }
                        } else {
                            throw new Error('Invalid state file format. Must contain "tools" (array) and "playerState" (object or null).');
                        }
                    } catch (err) {
                        alert('Error importing state: ' + err.message);
                    }
                };
                reader.readAsText(file);
                // Reset file input to allow importing the same file again if needed
                event.target.value = null;
            };
            
            return (
                <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-3 space-y-3">
                    <h3 className="text-lg font-bold text-indigo-300">System State</h3>
                    <p className="text-xs text-gray-400">Export your agent's learned tools and player progress, or import a saved state.</p>
                    <div className="flex gap-2">
                        <button 
                            onClick={handleExport}
                            className="flex-1 bg-green-700 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors"
                        >
                            Export State
                        </button>
                        <label 
                            className="flex-1 text-center bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg transition-colors cursor-pointer"
                        >
                            Import State
                            <input type="file" accept=".json" onChange={handleImport} className="hidden" />
                        </label>
                    </div>
                </div>
            );
        `
    }
];
```

# bootstrap/rapier_layout_tool.ts
```bootstrap/rapier_layout_tool.ts
// bootstrap/rapier_layout_tool.ts
import React from 'react';
import type { ToolCreatorPayload } from '../types';
import { GraphicsClassString } from './sim/graphics';
import { AgentSimulationCoreString } from './sim/agent_simulation';
import { ForceSimulationFunctionsString } from './sim/simulation_forces';
import { CollisionSimulationFunctionsString } from './sim/simulation_collisions';

const FullAgentSimulationClassString = `
class AgentSimulation {
    ${AgentSimulationCoreString}
    ${ForceSimulationFunctionsString}
    ${CollisionSimulationFunctionsString}
}
`;

const PCB_LAYOUT_TOOL: ToolCreatorPayload = {
    name: 'Interactive PCB Layout Tool',
    description: 'An interactive 3D simulation for arranging PCB components or simulating robot agents. It supports a rule-based agent layout and a physics-based engine.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide a powerful and intuitive unified interface for component placement and robotics simulation, modeled as emergent behavior of autonomous agents.',
    parameters: [
        { name: 'graph', type: 'object', description: 'The graph data including nodes (agents), edges (connections), and board outline.', required: true },
        { name: 'mode', type: 'string', description: "The simulation mode: 'pcb' or 'robotics'.", required: true },
        { name: 'layoutStrategy', type: 'string', description: "The layout engine to use: 'agent' for rule-based, 'physics' for Rapier.js simulation.", required: false },
        { name: 'onCommit', type: 'object', description: 'Callback function to commit final positions (PCB mode only).', required: true },
        { name: 'onUpdateLayout', type: 'object', description: 'Callback function to update the layout data (e.g., rules).', required: true },
        { name: 'isLayoutInteractive', type: 'boolean', description: 'Flag to determine if the commit button should be active.', required: true },
        { name: 'getTool', type: 'object', description: 'Function to retrieve a tool definition by name.', required: true },
        { name: 'heuristics', type: 'object', description: 'Initial simulation heuristics from the workflow.', required: false },
        { name: 'isServerConnected', type: 'boolean', description: 'Flag indicating if the backend server is connected.', required: true },
        { name: 'visibility', type: 'object', description: 'An object with boolean flags for rendering different layers.', required: true },
        { name: 'playerId', type: 'string', description: 'The ID of the player character for the 3rd person camera.', required: false },
    ],
    implementationCode: `
        // --- Injected Module Code ---
        ${GraphicsClassString}
        ${FullAgentSimulationClassString}
        // --- End Injected Code ---

        const mountRef = React.useRef(null);
        const simRef = React.useRef(null);
        const [isSimReady, setIsSimReady] = React.useState(false);
        const [isAutoCommitDone, setIsAutoCommitDone] = React.useState(false);
        const [isCommitting, setIsCommitting] = React.useState(false);
        
        // When a new graph is passed in (a new layout task), reset the auto-commit state.
        React.useEffect(() => {
            setIsAutoCommitDone(false);
            setIsCommitting(false);
        }, [graph]);

        // --- Initialization Effect (Runs Once) ---
        React.useEffect(() => {
            if (!mountRef.current) return;
            let isMounted = true;
            setIsSimReady(false);

            const init = async () => {
                let sim, graphics;
                let animationFrameId; // To hold the requestAnimationFrame ID
                try {
                    const THREE = await import('three');
                    const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
                    const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
                    const { SVGLoader } = await import('three/addons/loaders/SVGLoader.js');
                    
                    // Ensure Rapier is initialized only once using a global promise.
                    if (!window.rapierInitializationPromise) {
                        window.rapierInitializationPromise = import('@dimforge/rapier3d-compat').then(RAPIER_module => {
                            const RAPIER = RAPIER_module.default;
                            return RAPIER.init().then(() => RAPIER);
                        });
                    }
                    const RAPIER = await window.rapierInitializationPromise;

                    if (!isMounted) return null;
                    
                    const simScale = mode === 'pcb' ? 1 : 10;
                    
                    graphics = new Graphics(mountRef.current, THREE, OrbitControls, GLTFLoader, SVGLoader, graph?.board_outline, simScale, isServerConnected, mode, playerId);
                    
                    const initialGraph = graph ? { ...graph, nodes: [], edges: [], rules: [] } : { nodes: [], edges: [], rules: [], board_outline: null };
                    sim = new AgentSimulation(initialGraph, simScale, THREE, mode, onUpdateLayout, RAPIER);

                    if (!isMounted) return { sim, graphics };
                    graphics.setSimulation(sim);
                    simRef.current = { sim, graphics };
                    if (isMounted) setIsSimReady(true);
                    
                    const animate = () => {
                        if (!isMounted || !simRef.current) return;
                        simRef.current.sim.step();
                        simRef.current.graphics.render();
                        animationFrameId = requestAnimationFrame(animate);
                    };
                    animate();
                    
                    return () => { // Cleanup function
                        cancelAnimationFrame(animationFrameId); // Crucial: Stop the loop before cleaning up
                        if (sim) sim.cleanup();
                        if (graphics) graphics.cleanup();
                        simRef.current = null;
                    };

                } catch(e) {
                     console.error("Failed to initialize simulation:", e);
                     if(mountRef.current) mountRef.current.innerHTML = '<p class="text-red-400">Error initializing simulation. Check console.</p>';
                     return null;
                }
            };
            
            const cleanupPromise = init();

            return () => {
                isMounted = false;
                cleanupPromise.then((cleanupFn) => {
                    if (cleanupFn) cleanupFn();
                });
            };
        }, [mode, playerId]);

        // --- Data Update Effects ---
        React.useEffect(() => {
            if (isSimReady && simRef.current?.sim && graph) {
                if (mode === 'robotics') {
                    simRef.current.sim.setAuthoritativeState(graph.nodes);
                }
                simRef.current.sim.updateGraph(graph);
            }
        }, [graph, isSimReady, mode]);

        React.useEffect(() => {
            if (simRef.current?.graphics && isSimReady) {
                simRef.current.graphics.updateConnectionStatus(isServerConnected);
            }
        }, [isServerConnected, isSimReady]);

        React.useEffect(() => {
            if (isSimReady && simRef.current?.sim && heuristics && Object.keys(heuristics).length > 0) {
                simRef.current.sim.updateParams(heuristics);
            }
        }, [heuristics, isSimReady]);

        React.useEffect(() => {
            if (!isSimReady || !simRef.current || !graph || !graph.nodes) return;
            const { sim, graphics } = simRef.current;
            
            graph.nodes.forEach(node => {
                if (!sim.agents.has(node.id)) {
                    sim.addAgent(node);
                    graphics.addMesh(node.id, node, mode, sim.SCALE);
                }
            });
            graph.nodes.forEach(node => {
                const simNode = sim.nodeMap.get(node.id);
                if (simNode && simNode.side !== node.side) sim.updateNode(node);
            });
        }, [graph?.nodes, mode, isSimReady]);
        
        React.useEffect(() => {
            if (!isSimReady || !simRef.current || !graph || !graph.edges) return;
            simRef.current.sim.updateEdges(graph.edges);
        }, [graph?.edges, isSimReady]);
        
        React.useEffect(() => {
            if (isSimReady && simRef.current?.graphics && graph) {
                simRef.current.graphics.updateNetVisuals(graph);
            }
        }, [graph?.edges, isSimReady]);

        React.useEffect(() => {
            if (isSimReady && simRef.current?.graphics) {
                simRef.current.graphics.updateBoardMesh(graph?.board_outline, simRef.current.sim.SCALE);
            }
        }, [graph?.board_outline, isSimReady]);

        React.useEffect(() => {
            if (isSimReady && simRef.current?.graphics) {
                simRef.current.graphics.updateVisibility(visibility);
            }
        }, [visibility, isSimReady]);
        
        React.useEffect(() => {
            if (isSimReady && simRef.current?.sim && graph?.rules) {
                const sanitizedRules = graph.rules.map(rule => ({ ...rule, enabled: rule.enabled !== false }));
                simRef.current.sim.updateRules(sanitizedRules);
            }
        }, [graph?.rules, isSimReady]);


        const handleCommit = React.useCallback(() => {
            if (onCommit && simRef.current?.sim) {
                setIsCommitting(true);
                const finalPositions = simRef.current.sim.getFinalPositions();
                onCommit(finalPositions);
            }
        }, [onCommit]);

        React.useEffect(() => {
            // Only run auto-commit if there's an actual graph with nodes to process.
            if (!isLayoutInteractive && !isAutoCommitDone && simRef.current?.sim && graph && graph.nodes && graph.nodes.length > 0) {
                const stabilityCheckInterval = setInterval(() => {
                    if (simRef.current?.sim?.isStable) {
                        handleCommit();
                        setIsAutoCommitDone(true); // Mark as done for this layout
                        clearInterval(stabilityCheckInterval);
                    }
                }, 500);

                const timeoutId = setTimeout(() => {
                    if (!isAutoCommitDone) {
                        handleCommit();
                        setIsAutoCommitDone(true);
                        clearInterval(stabilityCheckInterval);
                    }
                }, 30000); // 30-second failsafe timeout

                return () => { clearInterval(stabilityCheckInterval); clearTimeout(timeoutId); };
            }
        }, [isLayoutInteractive, isAutoCommitDone, handleCommit, graph]);
        
        const Spinner = () => (
            <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        );

        return (
            <div className="bg-gray-900/50 border border-cyan-700/60 rounded-xl p-2 h-full flex flex-col relative">
                <div ref={mountRef} className="w-full h-full bg-black/30 rounded overflow-hidden touch-none cursor-grab" />
                {!isSimReady && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-cyan-300"></div>
                        <p className="text-cyan-300 ml-3">Initializing 3D Engine...</p>
                   </div>
                )}
                {isLayoutInteractive && (
                    <div className="absolute bottom-4 right-4 z-10">
                        <button
                          onClick={handleCommit}
                          disabled={isCommitting}
                          className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg flex items-center gap-2 transition-colors disabled:bg-green-800 disabled:cursor-wait"
                          aria-label="Commit layout and continue workflow"
                        >
                          {isCommitting ? <Spinner /> : (
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                            </svg>
                          )}
                          {isCommitting ? 'Committing...' : 'Commit Layout & Continue'}
                        </button>
                    </div>
                )}
            </div>
        );
    `
};

export const PHYSICS_LAYOUT_TOOLS: ToolCreatorPayload[] = [
    PCB_LAYOUT_TOOL,
];
```

# bootstrap/post_run_tools.ts
```bootstrap/post_run_tools.ts
import type { ToolCreatorPayload } from '../types';

export const WORKFLOW_CAPTURE_PANEL_TOOL: ToolCreatorPayload = {
    name: 'Workflow Capture Panel',
    description: 'Displays the captured workflow from the last agent run, allowing it to be copied for debugging and deterministic replay.',
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: 'To provide a crucial debugging tool by allowing developers to capture and replay agent behavior.',
    parameters: [
        { name: 'history', type: 'array', description: 'The history of EnrichedAIResponse from the last run.', required: true },
        { name: 'onClose', type: 'object', description: 'Function to close the panel.', required: true },
    ],
    implementationCode: `
        const [copyStatus, setCopyStatus] = React.useState('Copy Script');

        const workflowScript = React.useMemo(() => {
            const toolCalls = history
                .map(item => item.toolCall)
                .filter(Boolean);

            const formattedCalls = toolCalls.map(call => {
                const argsString = JSON.stringify(call.arguments, null, 4)
                    .split('\\n')
                    .map((line, index) => index > 0 ? '        ' + line : line)
                    .join('\\n');

                return \`    {
        name: '\${call.name}',
        arguments: \${argsString}
    }\`;
            }).join(',\\n');
            
            return \`import type { AIToolCall } from '../types';\\n\\nexport const CAPTURED_WORKFLOW: AIToolCall[] = [\\n\${formattedCalls}\\n];\`;
        }, [history]);

        const handleCopy = () => {
            navigator.clipboard.writeText(workflowScript).then(() => {
                setCopyStatus('Copied!');
                setTimeout(() => setCopyStatus('Copy Script'), 2000);
            }, () => {
                setCopyStatus('Failed!');
                setTimeout(() => setCopyStatus('Copy Script'), 2000);
            });
        };

        return (
            <div className="bg-gray-800/80 border-2 border-green-500/60 rounded-xl p-4 shadow-lg flex flex-col h-full">
                <div className="flex justify-between items-center mb-3">
                    <h3 className="text-lg font-bold text-green-300">Workflow Run Captured</h3>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
                </div>
                <p className="text-sm text-gray-300 mb-2">
                    The agent's workflow has been captured. You can copy the script below and paste it into <code>demo_workflow.ts</code> to replay it for debugging.
                </p>
                <div className="flex-grow bg-black/30 rounded-lg overflow-hidden relative font-mono text-sm border border-gray-700">
                    <pre className="p-4 h-full overflow-auto text-cyan-200"><code>{workflowScript}</code></pre>
                    <button onClick={handleCopy} className="absolute top-2 right-2 bg-gray-700 hover:bg-gray-600 text-white font-semibold py-1 px-3 rounded-md text-xs transition-colors">
                        {copyStatus}
                    </button>
                </div>
                <button onClick={onClose} className="mt-4 w-full text-center bg-indigo-600 text-white font-semibold py-2.5 px-4 rounded-lg hover:bg-indigo-700">
                    Dismiss
                </button>
            </div>
        );
    `
};
```

# bootstrap/demo_presets.ts
```bootstrap/demo_presets.ts
import type { AIToolCall } from '../types';

export const EXAMPLE_PROMPTS: { name: string; prompt: string }[] = [
    {
        name: 'EEG Phylactery Quest',
        prompt: `An archivist from the Great Library requires a 'Phylactery of True Sight' to awaken a dormant XIAO-series Golem Core. This Phylactery must be a stackable mezzanine board that grants the Core advanced neuro-sensing capabilities.

Here is the plan, transcribed from the ancient schematics:

1.  **Reagent Inscription (Component Definition):**
    *   The Phylactery's heart 'U1' is an 'ADS131M08' with footprint 'Package_QFP:LQFP-32_5x5mm_P0.5mm'.
    *   It requires twin LDO lifeblood sources, 'U2' & 'U3', of type 'LP5907QMFX-3.3Q1' with footprint 'Package_TO_SOT_SMD:SOT-23-5'.
    *   A time-crystal 'X1' of '8.192MHz' in a 'freeeeg8-alpha:Oscillator_SMD_EuroQuartz_XO32-4Pin_3.2x2.5mm_RotB_HandSoldering' chassis.
    *   Various capacitor essences: 'C1' (220nF), 'C2' (100nF), 'C3' & 'C4' (1uF) in 'Capacitor_SMD:C_0402_1005Metric' forms. 'C5'-'C8' (2.2uF) in 'Capacitor_SMD:C_0603_1608Metric' forms.
    *   Two binding tablets for the Golem Core, 'J_XIAO_1' and 'J_XIAO_2', with footprint 'Connector_PinHeader_2.54mm:PinHeader_1x07_P2.54mm_Vertical_SMD_Pin1Right'.
    *   Ten 'bottom'-layer pogo-pin contact spines ('J1'-'J10') for neural interface, footprint 'freeeeg8-alpha:pogo_pin_d5x10mm_smd'. All other reagents are for the 'top' layer.

2.  **Matrix Weaving (Net Definition):**
    *   A 'GND' net must link: ["U1-13", "U1-25", "U1-28", "J10-1", "C1-1", "C2-1", "C3-2", "C4-2", "U2-2", "C5-2", "C6-1", "C7-1", "C8-2", "J_XIAO_2-6", "X1-2"].
    *   Weave all other nets as per the FreeEEG8-alpha schematic standard.

3.  **Placement Glyphs (Layout Rules):**
    *   Arrange the pogo pins ('J1'-'J10') in a circle of 10mm radius.
    *   The core 'U1' and time-crystal 'X1' must be aligned on the central vertical axis.
    *   The Phylactery must be symmetrical. Mirror these reagent pairs across the vertical axis: [J_XIAO_1, J_XIAO_2], [U2, U3], [C5, C7], [C6, C8].
    *   Ensure decoupling capacitors C1-C4 are near U1; C5-C6 near U2; C7-C8 near U3.

4.  **Board Manifestation:**
    *   Create a circular board outline of 26mm diameter.
    *   Arrange components using the 'agent' strategy and await user input for final adjustments.
    *   Autoroute the PCB and export fabrication files.
    `
    },
];

const EEG_MEZZANINE_WORKFLOW: AIToolCall[] = [
    // This workflow is based on verified datasheet pinouts.
    // --- Phase 1: Schematic & Rule Definition (Populates the live simulation) ---
    { name: 'Define KiCad Component', arguments: { componentReference: 'U1', componentDescription: '8-Channel ADC', componentValue: 'ADS131M08', footprintIdentifier: 'Package_QFP:LQFP-32_5x5mm_P0.5mm', numberOfPins: 32, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":29,"net":"AIN0P"},{"pin":32,"net":"AIN1P"},{"pin":1,"net":"AIN2P"},{"pin":4,"net":"AIN3P"},{"pin":5,"net":"AIN4P"},{"pin":8,"net":"AIN5P"},{"pin":9,"net":"AIN6P"},{"pin":12,"net":"AIN7P"},{"pin":2,"net":"AINREF"},{"pin":3,"net":"AINREF"},{"pin":6,"net":"AINREF"},{"pin":7,"net":"AINREF"},{"pin":10,"net":"AINREF"},{"pin":11,"net":"AINREF"},{"pin":30,"net":"AINREF"},{"pin":31,"net":"AINREF"},{"pin":13,"net":"GND"},{"pin":25,"net":"GND"},{"pin":28,"net":"GND"},{"pin":24,"net":"CAP"},{"pin":14,"net":"REFIN"},{"pin":15,"net":"AVDD"},{"pin":26,"net":"DVDD"},{"pin":16,"net":"SYNC/RESET"},{"pin":17,"net":"CS"},{"pin":18,"net":"DRDY"},{"pin":19,"net":"SCLK"},{"pin":20,"net":"DOUT"},{"pin":21,"net":"DIN"},{"pin":23,"net":"XTAL1/CLKIN"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'U2', componentDescription: '3.3V LDO Voltage Regulator', componentValue: 'LP5907QMFX-3.3Q1', footprintIdentifier: 'Package_TO_SOT_SMD:SOT-23-5', numberOfPins: 5, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":5,"net":"AVDD"},{"pin":1,"net":"5V"},{"pin":3,"net":"5V"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'U3', componentDescription: '3.3V LDO Voltage Regulator', componentValue: 'LP5907QMFX-3.3Q1', footprintIdentifier: 'Package_TO_SOT_SMD:SOT-23-5', numberOfPins: 5, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":5,"net":"DVDD"},{"pin":1,"net":"5V"},{"pin":3,"net":"5V"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'X1', componentDescription: '8.192MHz Oscillator', componentValue: '8.192MHz', footprintIdentifier: 'freeeeg8-alpha:Oscillator_SMD_EuroQuartz_XO32-4Pin_3.2x2.5mm_RotB_HandSoldering', numberOfPins: 4, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":4,"net":"DVDD"},{"pin":3,"net":"XTAL1/CLKIN"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C1', componentDescription: '220nF Ceramic Capacitor', componentValue: '220nF', footprintIdentifier: 'Capacitor_SMD:C_0402_1005Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":1,"net":"GND"},{"pin":2,"net":"CAP"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C2', componentDescription: '100nF Ceramic Capacitor', componentValue: '100nF', footprintIdentifier: 'Capacitor_SMD:C_0402_1005Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":1,"net":"GND"},{"pin":2,"net":"REFIN"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C3', componentDescription: '1uF Ceramic Capacitor', componentValue: '1uF', footprintIdentifier: 'Capacitor_SMD:C_0402_1005Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":1,"net":"AVDD"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C4', componentDescription: '1uF Ceramic Capacitor', componentValue: '1uF', footprintIdentifier: 'Capacitor_SMD:C_0402_1005Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":1,"net":"DVDD"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C5', componentDescription: '2.2uF Ceramic Capacitor', componentValue: '2.2uF', footprintIdentifier: 'Capacitor_SMD:C_0603_1608Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":1,"net":"AVDD"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C6', componentDescription: '2.2uF Ceramic Capacitor', componentValue: '2.2uF', footprintIdentifier: 'Capacitor_SMD:C_0603_1608Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":1,"net":"GND"},{"pin":2,"net":"5V"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C7', componentDescription: '2.2uF Ceramic Capacitor', componentValue: '2.2uF', footprintIdentifier: 'Capacitor_SMD:C_0603_1608Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":1,"net":"GND"},{"pin":2,"net":"DVDD"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'C8', componentDescription: '2.2uF Ceramic Capacitor', componentValue: '2.2uF', footprintIdentifier: 'Capacitor_SMD:C_0603_1608Metric', numberOfPins: 2, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":1,"net":"5V"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J1', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN0P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J2', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN1P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J3', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN2P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J4', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN3P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J5', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN4P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J6', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN5P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J7', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN6P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J8', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AIN7P"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J9', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"AINREF"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J10', componentDescription: 'Pogo Pin Electrode', componentValue: 'POGO', footprintIdentifier: 'freeeeg8-alpha:pogo_pin_d5x10mm_smd', numberOfPins: 1, side: 'bottom', exportSVG: true, pinConnections: `[{"pin":1,"net":"GND"}]` } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J_XIAO_1', componentDescription: 'XIAO Header', componentValue: 'XIAO_HEADER', footprintIdentifier: 'Connector_PinHeader_2.54mm:PinHeader_1x07_P2.54mm_Vertical_SMD_Pin1Right', numberOfPins: 7, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":1,"net":"SYNC/RESET"},{"pin":2,"net":"DRDY"},{"pin":3,"net":"CS"}]' } },
    { name: 'Define KiCad Component', arguments: { componentReference: 'J_XIAO_2', componentDescription: 'XIAO Header', componentValue: 'XIAO_HEADER', footprintIdentifier: 'Connector_PinHeader_2.54mm:PinHeader_1x07_P2.54mm_Vertical_SMD_Pin1Left', numberOfPins: 7, side: 'top', exportSVG: true, exportGLB: true, pinConnections: '[{"pin":2,"net":"GND"},{"pin":1,"net":"5V"},{"pin":6,"net":"SCLK"},{"pin":5,"net":"DOUT"},{"pin":4,"net":"DIN"}]' } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN0P', pins: ["J1-1", "U1-29"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN1P', pins: ["J2-1", "U1-32"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN2P', pins: ["J3-1", "U1-1"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN3P', pins: ["J4-1", "U1-4"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN4P', pins: ["J5-1", "U1-5"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN5P', pins: ["J6-1", "U1-8"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN6P', pins: ["J7-1", "U1-9"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AIN7P', pins: ["J8-1", "U1-12"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AINREF', pins: ["J9-1", "U1-2", "U1-3", "U1-6", "U1-7", "U1-10", "U1-11", "U1-30", "U1-31"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'GND', pins: ["J10-1", "U1-13", "U1-25", "U1-28", "C1-1", "C2-1", "C3-2", "C4-2", "U2-2", "U3-2", "C5-2", "C6-1", "C7-1", "C8-2", "J_XIAO_2-2", "X1-2"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'CAP', pins: ["C1-2", "U1-24"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'REFIN', pins: ["C2-2", "U1-14"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'AVDD', pins: ["U2-5", "U1-15", "C3-1", "C5-1"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'DVDD', pins: ["U3-5", "U1-26", "X1-4", "C4-1", "C7-2"] } },
    { name: 'Define KiCad Net', arguments: { netName: '5V', pins: ["C6-2", "C8-1", "J_XIAO_2-1", "U2-1", "U3-1", "U2-3", "U3-3"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'SYNC/RESET', pins: ["U1-16", "J_XIAO_1-1"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'CS', pins: ["U1-17", "J_XIAO_1-3"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'DRDY', pins: ["U1-18", "J_XIAO_1-2"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'SCLK', pins: ["U1-19", "J_XIAO_2-6"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'DOUT', pins: ["U1-20", "J_XIAO_2-5"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'DIN', pins: ["U1-21", "J_XIAO_2-4"] } },
    { name: 'Define KiCad Net', arguments: { netName: 'XTAL1/CLKIN', pins: ["U1-23", "X1-3"] } },
    { name: 'Set Simulation Heuristics', arguments: { boardPadding: 0.20, } },
    { name: 'Add Circular Constraint', arguments: { componentsJSON: '["J1","J2","J3","J4","J5","J6","J7","J8","J9","J10"]', radius: 12.5, centerX: 0, centerY: 0 } },
    { name: 'Add Layer Constraint', arguments: { layer: 'bottom', componentsJSON: '["J1","J2","J3","J4","J5","J6","J7","J8","J9","J10"]' } },
    { name: 'Add Symmetrical Pair Constraint', arguments: { pairJSON: '["J_XIAO_1", "J_XIAO_2"]', axis: 'vertical', separation: 2.54*7 } },
    { name: 'Add Proximity Constraint', arguments: { groupsJSON: '[["U1", "C1"], ["U1", "C2"], ["U1", "C3"], ["U1", "C4"], ["U2", "C5"], ["U2", "C6"], ["U3", "C7"], ["U3", "C8"]]' } },
    { name: 'Add Symmetry Constraint', arguments: { axis: 'vertical', pairsJSON: '[["U2", "U3"]]' } },
    
    // --- Phase 2: Create PCB and Arrange (This step now runs autonomously) ---
    { name: 'Generate KiCad Netlist', arguments: {} },
    { name: 'Create Initial PCB', arguments: {} },
    { name: 'Create Board Outline', arguments: { shape: 'circle', diameterMillimeters: 33 } },
    { name: 'Create Copper Pour', arguments: { layerName: 'In1.Cu', netName: 'GND' } },
    { name: 'Arrange Components', arguments: { waitForUserInput: true, layoutStrategy: 'agent' } },

    // --- Phase 3: Post-Layout Steps (These run after the simulation is committed) ---
    // 'Update KiCad Component Positions' is handled by the commit logic
    { name: 'Autoroute PCB', arguments: {} },
    { name: 'Export Fabrication Files', arguments: {} },
    { name: 'Task Complete', arguments: { reason: "Demo PCB design workflow finished." } }
];

// This script is now the single source of truth for both local and server world generation.
export const AETHERIUM_INITIAL_WORLD_SETUP: AIToolCall[] = [
    // Define the types of creatures that can exist
    { name: 'Define World Creature', arguments: { creatureId: 'mind_weaver', name: 'Mind Weaver', description: 'A crab-like schematic-creature that yields a Crystal of Immaculate Mind.', asset_glb: 'assets/game/creatures/creature_schematic_mind_weaver_ads131m08.glb' } },
    { name: 'Define World Creature', arguments: { creatureId: 'heartbeat_beetle', name: 'Heartbeat Beetle', description: 'A small beetle whose core pulses with stable energy.', asset_glb: 'assets/game/creatures/creature_schematic_heartbeat_beetle_lp5907.glb' } },
    { name: 'Define World Creature', arguments: { creatureId: 'time_crystal_cicada', name: 'Time-Crystal Cicada', description: 'A crystalline insect whose wings vibrate at a precise frequency, yielding a Flawless Crystal of Time.', asset_glb: 'assets/game/creatures/creature_schematic_time_cicada_ecs2520mv.glb' } },
    { name: 'Define World Creature', arguments: { creatureId: 'ley_capacitor_mite', name: 'Ley-Capacitor Mite', description: 'A tiny, swarming insect made of ceramic that stores ambient magical energy, yielding a Ley-Capacitor Spore.', asset_glb: 'assets/game/creatures/creature_schematic_capacitor_mite.glb' } },
    { name: 'Define World Creature', arguments: { creatureId: 'golden_contact_needler', name: 'Golden Contact Needler', description: 'An agile, needle-like creature that flits through the air, yielding a Golden Contact Spine.', asset_glb: 'assets/game/creatures/creature_schematic_pogo_needler.glb' } },
    { name: 'Define World Creature', arguments: { creatureId: 'logic_weaving_worm', name: 'Logic-Weaving Worm', description: 'A segmented worm with metallic legs that leaves a faint trail of light, yielding a Tablet of Logical Weaving.', asset_glb: 'assets/game/creatures/creature_schematic_header_worm.glb' } },
    
    // Place key environment objects
    { name: 'Place Environment Object', arguments: { objectId: 'central_forge', type: 'Alchemists_Forge', x: 0, y: 0, asset_glb: 'assets/game/stations/station_alchemists_forge.glb' } },

    // Spawn specific instances of creatures/NPCs in the world
    { name: 'Define Robot Agent', arguments: { id: 'mind_weaver_1', startX: 10, startY: 10, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'heartbeat_beetle_1', startX: -8, startY: -5, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'heartbeat_beetle_2', startX: -9, startY: -6, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'time_crystal_cicada_1', startX: 5, startY: -8, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'ley_capacitor_mite_1', startX: 10, startY: -5, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'ley_capacitor_mite_2', startX: 11, startY: -5, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'ley_capacitor_mite_3', startX: 10, startY: -4, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'ley_capacitor_mite_4', startX: 11, startY: -4, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'golden_contact_needler_1', startX: -10, startY: 10, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'golden_contact_needler_2', startX: -11, startY: 9, behaviorType: 'patroller' } },
    { name: 'Define Robot Agent', arguments: { id: 'logic_weaving_worm_1', startX: -2, startY: 9, behaviorType: 'patroller' } },
];


export const WORKFLOW_SCRIPTS: { name: string; workflow: AIToolCall[] }[] = [
    {
        name: 'Forge Phylactery of True Sight',
        workflow: EEG_MEZZANINE_WORKFLOW
    },
    {
        name: 'Aetherium: Genesis Ritual',
        workflow: AETHERIUM_INITIAL_WORLD_SETUP
    },
];
```

# bootstrap/aetherium_tools.ts
```bootstrap/aetherium_tools.ts
// bootstrap/aetherium_tools.ts
import type { ToolCreatorPayload } from '../types';
import { AETHERIUM_INITIAL_WORLD_SETUP } from './demo_presets';

// This is the template for the Node.js server process that runs a single game world (shard).
const WORLD_SETUP_SCRIPT_STRING = JSON.stringify(AETHERIUM_INITIAL_WORLD_SETUP, null, 4);

const GAME_SERVER_TEMPLATE = `
import express from 'express';
import cors from 'cors';
import type { PlayerState, RobotState, AgentPersonality, EnvironmentObject, LLMTool, ServerInventoryItem, VaultItem, Party, WorldEvent } from '../../types';

const PORT = process.env.PORT || 4001;
const SHARD_ID = process.env.SHARD_ID || 'unknown_shard';

const app = express();
app.use(cors());
app.use(express.json());

// --- Game State ---
let players = new Map<string, PlayerState>();
let npcStates = new Map<string, RobotState>();
let agentPersonalities = new Map<string, AgentPersonality>();
let environmentState: EnvironmentObject[] = [];
let parties = new Map<string, Party>();
let worldEvents: WorldEvent[] = [];
let worldCreatures = new Map<string, any>();
let gameTick = 0;

// --- Tool Runtime (Server-Side Implementation) ---
const executeServerTool = (toolName: string, args: any, context?: {playerId: string}): { success: boolean, message: string, data?: any } => {
    try {
        if (toolName === 'Game Tick') {
            const boardBounds = { minX: -40, maxX: 40, minY: -40, maxY: 40 };
            npcStates.forEach((npc, id) => {
                const personality = agentPersonalities.get(id);
                if (!personality || personality.behaviorType !== 'patroller') return;
        
                let { x, y, rotation } = npc;
                let nextX = x, nextY = y;
        
                if (rotation === 0) nextY += 1;
                if (rotation === 90) nextX += 1;
                if (rotation === 180) nextY -= 1;
                if (rotation === 270) nextX -= 1;
                
                let collision = false;
                if (nextX < boardBounds.minX || nextX > boardBounds.maxX || nextY < boardBounds.minY || nextY > boardBounds.maxY) {
                    collision = true;
                } else {
                    const allEntities = [...Array.from(npcStates.values()).filter(other => other.id !== id), ...Array.from(players.values()), ...environmentState];
                    for (const entity of allEntities) {
                        if (entity.x === nextX && entity.y === nextY) { collision = true; break; }
                    }
                }
        
                if (collision) {
                    const turnDirection = Math.random() > 0.5 ? 90 : -90;
                    npc.rotation = (rotation + turnDirection + 360) % 360;
                } else {
                    npc.x = nextX;
                    npc.y = nextY;
                }
            });

            // World Event Spawner & Manager
            const now = Date.now();
            const activeEvents = worldEvents.filter(e => e.expiresAt > now);
            const hadActiveEvents = worldEvents.length > 0;

            // Spawn new event
            if (gameTick > 0 && gameTick % 300 === 0 && activeEvents.length === 0) {
                const newEvent: WorldEvent = { 
                    id: 'anomaly_' + now, 
                    name: 'Nexus Anomaly', 
                    description: 'A powerful schematic-creature has manifested!', 
                    type: 'Nexus_Anomaly', 
                    x: Math.floor(Math.random() * 20 - 10), 
                    y: Math.floor(Math.random() * 20 - 10), 
                    expiresAt: now + 300000 
                };
                activeEvents.push(newEvent);
                
                environmentState.push({ id: newEvent.id, type: 'Nexus_Anomaly', x: newEvent.x, y: newEvent.y, asset_glb: 'assets/game/events/nexus_anomaly.glb' });
                
                const bossId = \`anomaly_boss_\${now}\`;
                const creatureType = worldCreatures.get('mind_weaver');
                const bossAsset = creatureType ? creatureType.asset_glb : 'assets/game/creatures/creature_schematic_mind_weaver_ads131m08.glb';

                const bossPersonality: AgentPersonality = {
                    id: bossId, startX: newEvent.x, startY: newEvent.y,
                    behaviorType: 'patroller', 
                    asset_glb: bossAsset
                };
                agentPersonalities.set(bossId, bossPersonality);
                
                const bossState: RobotState = {
                    id: bossId, x: newEvent.x, y: newEvent.y,
                    rotation: 0, hasResource: false, powerLevel: 500
                };
                npcStates.set(bossId, bossState);

                console.log(\`[\${SHARD_ID}] [EVENT] Spawned Nexus Anomaly at (\${newEvent.x}, \${newEvent.y})\`);
            }

            // Cleanup expired events
            if (hadActiveEvents && activeEvents.length < worldEvents.length) {
                const expiredEvents = worldEvents.filter(e => e.expiresAt <= now);
                expiredEvents.forEach(e => {
                    console.log(\`[\${SHARD_ID}] [EVENT] Nexus Anomaly at (\${e.x}, \${e.y}) expired.\`);
                    environmentState = environmentState.filter(obj => obj.id !== e.id);
                    const bossId = \`anomaly_boss_\${e.id.split('_')[1]}\`;
                    npcStates.delete(bossId);
                    agentPersonalities.delete(bossId);
                });
            }

            worldEvents = activeEvents;

            return { success: true, message: 'Game state advanced by one tick.' };

        } else if (toolName === 'Define World Creature') {
            worldCreatures.set(args.creatureId, { name: args.name, description: args.description, asset_glb: args.asset_glb });
            console.log(\`[\${SHARD_ID}] [LORE] Creature type defined: \${args.name}\`);
            return { success: true, message: \`Creature type '\${args.name}' defined.\` };

        } else if (toolName === 'Place Environment Object') {
            const { objectId, type, x, y, asset_glb } = args;
            environmentState = environmentState.filter(obj => obj.id !== objectId);
            environmentState.push({ id: objectId, type, x, y, asset_glb });
            return { success: true, message: \`Placed \${objectId} at (\${x}, \${y}).\` };

        } else if (toolName === 'Define Robot Agent') {
            const creatureId = args.id.split('_').slice(0, -1).join('_');
            const creatureType = worldCreatures.get(creatureId);
            const asset = creatureType ? creatureType.asset_glb : args.asset_glb;

            const personality: AgentPersonality = { id: args.id, startX: args.startX, startY: args.startY, behaviorType: args.behaviorType, targetId: args.targetId, asset_glb: asset };
            agentPersonalities.set(personality.id, personality);
            const newRobotState: RobotState = { id: args.id, x: args.startX, y: args.startY, rotation: Math.floor(Math.random() * 4) * 90, hasResource: false, powerLevel: 100 };
            npcStates.set(newRobotState.id, newRobotState);
            return { success: true, message: \`Agent '\${args.id}' defined and spawned.\` };
        } else if (toolName === 'Form Forgemaster Party') {
            if (!context || !context.playerId) return { success: false, message: 'Player context required.' };
            const leader = players.get(context.playerId);
            const target = players.get(args.targetPlayerId);
            if (!leader || !target) return { success: false, message: 'Player not found.' };

            if (leader.partyId) { // Leader is in a party, add target
                const party = parties.get(leader.partyId);
                if (party && party.leaderId === leader.id && !party.memberIds.includes(target.id)) {
                    party.memberIds.push(target.id);
                    target.partyId = party.id;
                    return { success: true, message: \`\${target.name} joined the party.\`, data: { party } };
                }
            } else { // Create a new party
                const partyId = 'party_' + Date.now();
                const newParty: Party = { id: partyId, leaderId: leader.id, memberIds: [leader.id, target.id] };
                parties.set(partyId, newParty);
                leader.partyId = partyId;
                target.partyId = partyId;
                return { success: true, message: 'Party created.', data: { party: newParty } };
            }
        } else if (toolName === 'Trade Reagents') {
            // Placeholder for trade logic
            return { success: true, message: 'Trade offer sent (simulation).' };
        } else if (toolName === 'Challenge to Aetheric Duel') {
            // Placeholder for duel logic
            return { success: true, message: 'Duel challenged issued (simulation).' };
        } else if (toolName === 'Interact With Entity') {
            if (!context || !context.playerId) return { success: false, message: 'Player context required.' };
            const player = players.get(context.playerId);
            const targetNpc = npcStates.get(args.targetId);
            if (!player || !targetNpc) return { success: false, message: 'Player or target not found.' };

            const dx = player.x - targetNpc.x; const dy = player.y - targetNpc.y;
            if (Math.sqrt(dx * dx + dy * dy) > 2.5) return { success: false, message: 'Target is too far away.' };

            let drop: ServerInventoryItem | null = null;
            if (args.targetId.startsWith('mind_weaver')) {
                drop = { id: 'essence_mind_crystal_' + Date.now(), name: 'Crystal of Immaculate Mind', type: 'CreatureEssence', description: 'Harvested from a Mind Weaver.', quantity: 1 };
            } else if (args.targetId.startsWith('heartbeat_beetle')) {
                drop = { id: 'essence_heartstone_' + Date.now(), name: 'Heartstone of the Regulator', type: 'CreatureEssence', description: 'Harvested from a Heartbeat Beetle.', quantity: 1 };
            }
            
            if (drop) {
                npcStates.delete(args.targetId);
                agentPersonalities.delete(args.targetId);
                
                const newInventory = player.inventory || [];
                const existingItemIndex = newInventory.findIndex(item => item.name === drop.name);
                if (existingItemIndex > -1) { newInventory[existingItemIndex].quantity += 1;
                } else { newInventory.push(drop); }
                player.inventory = newInventory;
                
                return { success: true, message: \`Harvested \${drop.name} from \${args.targetId}!\` };
            }
            return { success: false, message: 'Nothing to harvest.' };
        }
        
        return { success: true, message: \`Tool '\${toolName}' executed (no-op).\` };

    } catch (e) {
        const errorMsg = e instanceof Error ? e.message : String(e);
        console.error(\`[\${SHARD_ID}] Error executing tool '\${toolName}': \${errorMsg}\`);
        return { success: false, message: errorMsg, data: null };
    }
};

// --- World Initialization ---
const WORLD_SETUP_SCRIPT = ${WORLD_SETUP_SCRIPT_STRING};
const initializeWorld = () => {
    console.log(\`[\${SHARD_ID}] Initializing world state from script...\`);
    for (const step of WORLD_SETUP_SCRIPT) {
        if (step.name === 'Task Complete') continue;
        executeServerTool(step.name, step.arguments);
    }
    console.log(\`[\${SHARD_ID}] World initialized with \${npcStates.size} NPCs and \${environmentState.length} objects.\`);
};
initializeWorld();

// --- Game Loop ---
setInterval(() => {
    gameTick++;
    executeServerTool('Game Tick', {});
}, 1000);

// --- API Endpoints ---
app.post('/api/join', (req, res) => {
    const { playerState } = req.body;
    if (!playerState || !playerState.id) return res.status(400).json({ error: 'Invalid player state: ID is missing.' });
    
    const serverPlayerState: PlayerState = { ...playerState, inventory: [] };
    playerState.vault.forEach((blueprint: VaultItem) => {
        if (blueprint.name === 'Phylactery of True Sight') {
            serverPlayerState.inventory?.push({ id: 'phylactery_amulet_1', name: 'Amulet of True Sight', type: 'Artifact', description: 'An amulet that hums with psionic power, granted for your knowledge of its forging.', quantity: 1 });
        }
    });

    players.set(playerState.id, serverPlayerState);
    console.log(\`[\${SHARD_ID}] Player '\${playerState.name}' joined. Vault interpreted, inventory granted.\`);
    res.json({ success: true, player: serverPlayerState });
});

app.post('/api/player/:id/action', (req, res) => {
    const player = players.get(req.params.id);
    if (!player) return res.status(404).json({ error: 'Player not found.' });
    
    const { toolName, arguments: args } = req.body;

    if (['Move Forward', 'Move Backward', 'Turn Left', 'Turn Right'].includes(toolName)) {
        let { x, y, rotation } = player;
        if (toolName === 'Move Forward') {
            if (rotation === 0) y += 1; if (rotation === 90) x += 1; if (rotation === 180) y -= 1; if (rotation === 270) x -= 1;
        } else if (toolName === 'Move Backward') {
            if (rotation === 0) y -= 1; if (rotation === 90) x -= 1; if (rotation === 180) y += 1; if (rotation === 270) x += 1;
        } else if (toolName === 'Turn Left') {
            rotation = (rotation + 90 + 360) % 360; // Left is CCW, so add angle
        } else if (toolName === 'Turn Right') {
            rotation = (rotation - 90 + 360) % 360; // Right is CW, so subtract angle
        }
        const updatedPlayer = { ...player, x, y, rotation };
        players.set(req.params.id, updatedPlayer);
        res.json({ success: true, player: updatedPlayer });
    } else {
        const result = executeServerTool(toolName, args, { playerId: req.params.id });
        if (result.success) {
            res.json(result);
        } else {
            res.status(500).json({ error: result.message });
        }
    }
});

app.post('/api/player/:id/craft', (req, res) => {
    const player = players.get(req.params.id);
    if (!player) return res.status(404).json({ error: 'Player not found.' });
    const { recipeName } = req.body;

    if (recipeName === 'Phylactery of True Sight') {
        const required = [ { name: 'Crystal of Immaculate Mind', quantity: 1 }, { name: 'Heartstone of the Regulator', quantity: 2 } ];
        const inventoryMap = new Map((player.inventory || []).map(i => [i.name, i.quantity]));
        const hasAllReagents = required.every(req => (inventoryMap.get(req.name) || 0) >= req.quantity);
        if (!hasAllReagents) return res.status(400).json({ error: 'Missing required reagents.' });

        const newInventory = [...(player.inventory || [])];
        required.forEach(req => { const itemIndex = newInventory.findIndex(i => i.name === req.name); if (itemIndex > -1) { newInventory[itemIndex].quantity -= req.quantity; } });
        player.inventory = newInventory.filter(i => i.quantity > 0);

        const blueprint: Omit<VaultItem, 'id' | 'createdAt'> = { name: 'Phylactery of True Sight', type: 'KiCad Design', description: 'A real-world EEG mezzanine board design, forged in the Aetherium.', files: [ { path: 'phylactery.kicad_pcb', content: '... (kicad_pcb file content) ...' }, { path: 'phylactery.kicad_sch', content: '... (kicad_sch file content) ...' } ] };
        res.json({ success: true, message: 'Forge successful! Blueprint transmitted.', blueprint });
    } else {
        res.status(400).json({ error: 'Unknown recipe.' });
    }
});

app.get('/api/state', (req, res) => {
    res.json({
        players: Array.from(players.values()),
        npcs: Array.from(npcStates.values()),
        environment: environmentState,
        agentPersonalities: Array.from(agentPersonalities.values()),
        parties: Array.from(parties.values()),
        worldEvents: worldEvents,
    });
});

app.listen(PORT, () => console.log(\`[\${SHARD_ID}] Aetherium world shard listening on http://localhost:\${PORT}\`));
`;

const SERVER_PROCESS_TOOLS: ToolCreatorPayload[] = [
    { name: 'Start Node Process', description: 'Starts a managed Node.js process on the server.', category: 'Server', executionEnvironment: 'Server', purpose: 'To dynamically launch and manage server-side processes like game worlds.', parameters: [{ name: 'processId', type: 'string', description: 'A unique ID for the process.', required: true }, { name: 'scriptPath', type: 'string', description: 'The path to the Node.js script to run.', required: true }], implementationCode: 'start_node_process' },
    { name: 'Stop Node Process', description: 'Stops a managed Node.js process.', category: 'Server', executionEnvironment: 'Server', purpose: 'To terminate server-side processes.', parameters: [{ name: 'processId', type: 'string', description: 'The ID of the process to stop.', required: true }], implementationCode: 'stop_node_process' },
    { name: 'List Managed Processes', description: 'Lists all currently managed Node.js processes.', category: 'Server', executionEnvironment: 'Server', purpose: 'To monitor and get the status of running server-side processes.', parameters: [], implementationCode: 'list_managed_processes' }
];

const DEFINE_WORLD_CREATURE_TOOL: ToolCreatorPayload = {
    name: 'Define World Creature', description: 'Defines a creature type available in the Aetherium world, including its lore and visual asset.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To establish the bestiary of a world shard, defining the creatures players and agents can interact with.',
    parameters: [ { name: 'creatureId', type: 'string', description: 'A unique ID for the creature type.', required: true }, { name: 'name', type: 'string', description: 'The display name of the creature.', required: true }, { name: 'description', type: 'string', description: 'Lore-friendly description of the creature.', required: true }, { name: 'asset_glb', type: 'string', description: 'Path to the GLB model for the creature.', required: true }, ],
    implementationCode: `// This tool's logic is handled by the runtime to update game state.`
};

const GAME_LOGIC_TOOLS: ToolCreatorPayload[] = [
    { name: 'Game Tick', description: 'Advances the game world state by one discrete step. This causes all NPCs to perform actions based on their defined behaviors (e.g., patrolling). This is the heartbeat of the world.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To provide a fundamental mechanism for the passage of time and autonomous agent behavior within the game world, making the world feel alive.', parameters: [], implementationCode: `// This tool's logic is implemented directly in the core runtime (client and server) and is called by the game loop.` },
    DEFINE_WORLD_CREATURE_TOOL,
    { name: 'Aetheric Push', description: 'Unleashes a short-range telekinetic blast to shove a target creature or object. A fundamental combat and interaction spell.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To provide a direct, physics-based interaction with the game world, allowing players to manipulate their environment and adversaries.', parameters: [ { name: 'playerId', type: 'string', description: 'The ID of the player casting the spell.', required: true }, { name: 'targetId', type: 'string', description: 'The ID of the creature or object to push.', required: true }, ], implementationCode: `// This tool is handled by the physics-based useGameWorldManager hook.` },
    { name: 'Interact With Entity', description: 'Allows a player to interact with a nearby creature or object, potentially harvesting resources or triggering an event.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To provide the core mechanism for player interaction with the game world, such as harvesting creatures for reagents.',
      parameters: [ { name: 'playerId', type: 'string', description: 'The ID of the player initiating the interaction.', required: true }, { name: 'targetId', type: 'string', description: 'The ID of the NPC or object to interact with.', required: true }, ],
      implementationCode: `// This tool is handled by the core runtime to modify game state.`
    },
    { name: 'Forge Artifact', description: "Crafts a new artifact by consuming in-game reagents on the server and receiving a permanent design blueprint for the client's Vault.", category: 'Functional', executionEnvironment: 'Client', purpose: "To handle the core crafting loop, transforming temporary server-side items into permanent client-side intellectual property.",
      parameters: [ { name: 'playerId', type: 'string', description: 'The ID of the player initiating the craft.', required: true }, { name: 'recipeName', type: 'string', description: 'The name of the artifact recipe to craft.', required: true }, { name: 'serverPort', type: 'number', description: 'The port of the game server where crafting occurs.', required: false }, ],
      implementationCode: ` const { playerId, recipeName, serverPort } = args; if (!serverPort) { /* Offline logic is handled in useAppRuntime */ return; } const response = await fetch(\`http://localhost:\${serverPort}/api/player/\${playerId}/craft\`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ recipeName }), }); const result = await response.json(); if (!response.ok) { throw new Error(result.error || 'Crafting failed on the server.'); } return { success: true, message: result.message, blueprint: result.blueprint };`
    },
    { name: 'Form Forgemaster Party', description: 'Invites another player to join your party.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To enable cooperative gameplay.', parameters: [{ name: 'targetPlayerId', type: 'string', description: 'The ID of the player to invite.', required: true }], implementationCode: `// Client-side, this will send a request to the server via handleManualControl or a direct fetch.` },
    { name: 'Trade Reagents', description: 'Initiates a trade with another player.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To facilitate a player-driven economy.', parameters: [{ name: 'targetPlayerId', type: 'string', description: 'The ID of the player to trade with.', required: true }, { name: 'itemsToOffer', type: 'array', description: 'An array of items to offer.', required: true }], implementationCode: `// Client-side, sends a request to the server.` },
    { name: 'Challenge to Aetheric Duel', description: 'Challenges another player to a PvP duel.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To provide a competitive outlet and a way to test crafted artifacts.', parameters: [{ name: 'targetPlayerId', type: 'string', description: 'The ID of the player to challenge.', required: true }], implementationCode: `// Client-side, sends a request to the server.` },
    { name: 'Discover New Research', description: 'Simulates finding a new scientific paper, potentially unlocking new crafting recipes and quests.', category: 'Functional', executionEnvironment: 'Client', purpose: 'To provide a mechanism for continuous content discovery.', parameters: [], implementationCode: `return { success: true, message: 'You have discovered a new research paper: "The Effects of Quantum Entanglement on Cognitive Functions"!' };` },
];

const PLAYER_DASHBOARD_TOOL_PAYLOAD: ToolCreatorPayload = {
    name: 'Player Dashboard', description: "Displays the player's permanent Vault and temporary in-game inventory.", category: 'UI Component', executionEnvironment: 'Client', purpose: "To provide a clear view of both the player's permanent IP (Vault) and their temporary, world-specific items (Inventory).",
    parameters: [ { name: 'playerState', type: 'object', description: 'The full state object of the active player, including vault and server inventory.', required: true }, { name: 'connectedServerInfo', type: 'object', description: 'Info about the connected server, if any.', required: false }, ],
    implementationCode: ` if (!playerState) { return <div className="text-center text-gray-400">No active player.</div>; } const { name, vault, inventory } = playerState;
        const ItemList = ({ title, items, isVault = false }) => (
            <div> <h5 className="font-semibold text-gray-300 mb-1">{title} ({items?.length || 0})</h5> <div className="bg-gray-800/60 p-2 rounded space-y-1 max-h-32 overflow-y-auto">
                    {(items && items.length > 0) ? ( items.map(item => ( <div key={item.id} className="p-1 rounded" title={item.description}> <div className="flex justify-between items-center text-sm"> <span className={isVault ? "text-yellow-300" : "text-white"}>{item.name}</span> {item.quantity && <span className="font-mono text-cyan-300">x{item.quantity}</span>} </div> <p className="text-xs text-gray-400">{item.type}</p> </div> )) ) : ( <p className="text-xs text-gray-500 text-center italic py-2">Empty</p> )}
                </div> </div> );
        return ( <div className="bg-gray-900/50 border border-gray-700 rounded-lg p-3 h-full flex flex-col gap-2"> <h4 className="text-lg font-bold text-green-400 text-center">{name}</h4> {connectedServerInfo && <p className="text-xs text-center text-gray-400">Connected to: {connectedServerInfo.processId}</p>}
                <div className="flex-grow flex flex-col gap-3 overflow-y-auto pr-1"> <ItemList title="Vault (Permanent)" items={vault} isVault={true} /> {inventory && <ItemList title="Inventory (Temporary)" items={inventory} />} </div> </div> ); `
};

const CODEX_AETHERIUM_TOOL_PAYLOAD: ToolCreatorPayload = {
    name: 'Codex Aetherium',
    description: "An in-game encyclopedia that displays the engineering and metaphysical lore of the player's current project.",
    category: 'UI Component',
    executionEnvironment: 'Client',
    purpose: "To provide a discoverable, in-game view of the lore that the AI generates, bridging the gap between engineering and magic.",
    parameters: [
        { name: 'projectState', type: 'object', description: 'The current state of the KiCad project, containing components and nets.', required: false },
    ],
    implementationCode: `
        const [selectedItem, setSelectedItem] = React.useState(null);
        if (!projectState) {
            return <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 h-full flex items-center justify-center"><p className="text-gray-400 text-center italic">No active project to inspect.</p></div>;
        }
        const { components = [], nets = [] } = projectState;
        const handleSelect = (type, item) => { setSelectedItem(prev => (prev && prev.item.name === item.name) ? null : { type, item }); };

        const renderDetails = () => {
            if (!selectedItem) return <p className="text-sm text-gray-500 italic text-center">Select an item to view its lore.</p>;
            const { type, item } = selectedItem;
            return (
                <div className="space-y-3">
                    <h5 className="font-bold text-yellow-300">{item.name || item.ref}</h5>
                    {type === 'component' && (
                        <div className="text-xs space-y-2">
                           <p><span className="font-semibold text-gray-400">Footprint:</span> <span className="font-mono">{item.footprint}</span></p>
                           {item.metaphysicalProperties && Object.entries(item.metaphysicalProperties).map(([key, value]) => (
                             <div key={key}><p className="font-semibold text-purple-300">{key.replace(/_/g, ' ')}:</p><p className="text-gray-300 pl-2">{value}</p></div>
                           ))}
                        </div>
                    )}
                    {type === 'net' && (
                         <div className="text-xs space-y-2">
                           <p className="font-semibold text-purple-300">Ritual Weaving:</p>
                           <p className="text-gray-300 italic pl-2">{item.ritualDescription || "A standard connection."}</p>
                         </div>
                    )}
                </div>
            );
        };
        
        return (
            <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-2 h-full flex flex-col">
                <h4 className="text-lg font-bold text-purple-300 text-center mb-2 flex-shrink-0">Codex Aetherium</h4>
                <div className="grid grid-cols-2 gap-2 flex-grow min-h-0">
                    <div className="flex flex-col gap-2">
                        <h5 className="font-semibold text-gray-300 text-sm">Reagents</h5>
                        <div className="bg-black/20 p-1 rounded overflow-y-auto flex-grow space-y-1">
                            {components.map(c => <button key={c.ref} onClick={() => handleSelect('component', c)} className={\`w-full text-left p-1 text-xs rounded \${selectedItem?.item.ref === c.ref ? 'bg-indigo-600 text-white' : 'bg-gray-700/50 hover:bg-gray-600'}\`}>{c.ref}</button>)}
                        </div>
                    </div>
                    <div className="flex flex-col gap-2">
                        <h5 className="font-semibold text-gray-300 text-sm">Weavings</h5>
                        <div className="bg-black/20 p-1 rounded overflow-y-auto flex-grow space-y-1">
                            {nets.map(n => <button key={n.name} onClick={() => handleSelect('net', n)} className={\`w-full text-left p-1 text-xs rounded \${selectedItem?.item.name === n.name ? 'bg-indigo-600 text-white' : 'bg-gray-700/50 hover:bg-gray-600'}\`}>{n.name}</button>)}
                        </div>
                    </div>
                </div>
                <div className="flex-shrink-0 mt-2 p-2 border-t border-gray-700 bg-black/20 rounded">
                    {renderDetails()}
                </div>
            </div>
        );
    `
};

export const AETHERIUM_CLIENT_TOOL_PAYLOAD: ToolCreatorPayload = {
    name: 'Aetherium Game Client', description: 'The main user interface for the Aetherium game, handling character management, world connection, and in-game UI.', category: 'UI Component', executionEnvironment: 'Client', purpose: 'To provide the player with a view into the Aetherium world and controls for interacting with it.',
    parameters: [ { name: 'gameState', type: 'object', description: 'The current state of the game world.', required: true }, { name: 'playerState', type: 'object', description: 'The active player character state from client-side storage.', required: true }, { name: 'isServerConnected', type: 'boolean', description: 'Flag for backend server connection.', required: true }, { name: 'demoScripts', type: 'array', description: 'Array of available demo scripts.', required: true }, { name: 'logEvent', type: 'object', description: 'Function to log events.', required: true }, { name: 'onLoadPlayer', type: 'object', description: 'Callback to load or create a player character.', required: true }, { name: 'onStartLocalGame', type: 'object', description: 'Callback to start a local game.', required: true }, { name: 'onExitGame', type: 'object', description: 'Callback to exit any active game session.', required: true }, { name: 'onConnectToShard', type: 'object', description: 'Callback to connect to a remote world shard.', required: true }, { name: 'getTool', type: 'object', description: 'Function to retrieve a tool definition by name.', required: true }, { name: 'handleManualControl', type: 'object', description: 'Function to send player actions.', required: true }, { name: 'setPilotMode', type: 'object', description: 'Function to set the AI pilot mode.', required: true }, { name: 'setAiPilotTarget', type: 'object', description: 'Function to set the AI pilot target.', required: true } ],
    implementationCode: ` const [servers, setServers] = React.useState([]); const [playerNameInput, setPlayerNameInput] = React.useState('Forgemaster'); const [isLoading, setIsLoading] = React.useState(false); const [selectedPlayerId, setSelectedPlayerId] = React.useState(null); const [pushTargetId, setPushTargetId] = React.useState('');
        const { pilotMode, aiPilotTarget } = gameState;
        const runnerRef = React.useRef(window.executeActionRef?.current); React.useEffect(() => { runnerRef.current = window.executeActionRef?.current; }, []);
        const executeTool = async (name, args = {}) => { if (!runnerRef.current) throw new Error("Execution context not found."); const result = await runnerRef.current({ name, arguments: args }, 'aetherium-client', 'AETHERIUM_GAME'); if (result.executionError) { logEvent('[ERROR] ' + result.executionError); throw new Error(result.executionError); } if(result.executionResult?.message) { logEvent('[GAME] ' + result.executionResult.message); } return result.executionResult; };
        const refreshServerList = React.useCallback(async () => { if (!isServerConnected) return setServers([]); try { const result = await executeTool('List Managed Processes'); setServers(result.processes || []); } catch (e) { console.error("Failed to refresh server list:", e); setServers([]); } }, [isServerConnected]);
        React.useEffect(() => { if (isServerConnected) refreshServerList(); const interval = setInterval(refreshServerList, 5000); return () => clearInterval(interval); }, [refreshServerList, isServerConnected]);
        const handleForgeWorld = async () => { const worldId = 'aetheria_' + Date.now(); setIsLoading(true); try { await executeTool('Start Node Process', { processId: worldId, scriptPath: 'aetherium_server.ts' }); await refreshServerList(); } catch (e) { logEvent('[ERROR] World forging failed: ' + e.message); } finally { setIsLoading(false); } };
        const handleJoinServer = async (server) => { setIsLoading(true); try { await onConnectToShard(server, playerState); } catch (e) { logEvent('[ERROR] Failed to join: ' + e.message); } finally { setIsLoading(false); } };
        const isPlaying = gameState.isLocalGameRunning || gameState.connectedServerInfo; const localPlayer = isPlaying ? gameState.players.find(p => p.id === playerState?.id) : null;
        
        const joystickBaseRef = React.useRef(null); const joystickKnobRef = React.useRef(null); const inputState = React.useRef({ joyX: 0, joyY: 0, joyActive: false, keyF: 0, keyB: 0, keyL: 0, keyR: 0, padX: 0, padY: 0, padConnected: false, }); const lastCommandTimeRef = React.useRef(0); const animationFrameId = React.useRef(null); const COMMAND_INTERVAL = 150;

          React.useEffect(() => {
            if (!isPlaying || !playerState || pilotMode !== 'MANUAL') { if(animationFrameId.current) cancelAnimationFrame(animationFrameId.current); animationFrameId.current = null; return; }
            const handleGamepadConnected = (e) => { inputState.current.padConnected = true; }; const handleGamepadDisconnected = (e) => { inputState.current.padConnected = false; }; window.addEventListener('gamepadconnected', handleGamepadConnected); window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);
            const handleKeyDown = (e) => { if (e.repeat || document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; if (e.key === 'w' || e.key === 'ArrowUp') inputState.current.keyF = 1; if (e.key === 's' || e.key === 'ArrowDown') inputState.current.keyB = 1; if (e.key === 'a' || e.key === 'ArrowLeft') inputState.current.keyL = 1; if (e.key === 'd' || e.key === 'ArrowRight') inputState.current.keyR = 1; };
            const handleKeyUp = (e) => { if (e.key === 'w' || e.key === 'ArrowUp') inputState.current.keyF = 0; if (e.key === 's' || e.key === 'ArrowDown') inputState.current.keyB = 0; if (e.key === 'a' || e.key === 'ArrowLeft') inputState.current.keyL = 0; if (e.key === 'd' || e.key === 'ArrowRight') inputState.current.keyR = 0; };
            window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
            const base = joystickBaseRef.current; const knob = joystickKnobRef.current; if (!base || !knob) return;
            const handlePointerDown = (e) => { e.preventDefault(); inputState.current.joyActive = true; };
            const handlePointerMove = (e) => { if (!inputState.current.joyActive) return; e.preventDefault(); const rect = base.getBoundingClientRect(); const size = rect.width; const halfSize = size / 2; let x = e.clientX - rect.left - halfSize; let y = e.clientY - rect.top - halfSize; const dist = Math.min(halfSize, Math.hypot(x, y)); const angle = Math.atan2(y, x); x = Math.cos(angle) * dist; y = Math.sin(angle) * dist; knob.style.transform = \`translate(-50%, -50%) translate(\${x}px, \${y}px)\`; inputState.current.joyX = x / halfSize; inputState.current.joyY = y / halfSize; };
            const handlePointerUp = (e) => { e.preventDefault(); inputState.current.joyActive = false; knob.style.transform = 'translate(-50%, -50%)'; inputState.current.joyX = 0; inputState.current.joyY = 0; };
            base.addEventListener('pointerdown', handlePointerDown); window.addEventListener('pointermove', handlePointerMove); window.addEventListener('pointerup', handlePointerUp);
            const gameLoop = () => {
                const now = performance.now();
                if (inputState.current.padConnected) { const gp = navigator.getGamepads()[0]; if (gp) { const deadzone = 0.2; const rawX = gp.axes[0] || 0; const rawY = gp.axes[1] || 0; inputState.current.padX = Math.abs(rawX) > deadzone ? rawX : 0; inputState.current.padY = Math.abs(rawY) > deadzone ? rawY : 0; } }
                const finalY = inputState.current.padConnected ? -inputState.current.padY : -inputState.current.joyY + (inputState.current.keyF - inputState.current.keyB);
                const finalX = inputState.current.padConnected ? inputState.current.padX : inputState.current.joyX + (inputState.current.keyR - inputState.current.keyL);
                if (now - lastCommandTimeRef.current > COMMAND_INTERVAL) {
                    let command = null;
                    if (finalY > 0.5) command = 'Move Forward'; else if (finalY < -0.5) command = 'Move Backward'; else if (finalX < -0.5) command = 'Turn Left'; else if (finalX > 0.5) command = 'Turn Right';
                    if (command) { handleManualControl(command, { playerId: playerState.id }); lastCommandTimeRef.current = now; }
                }
                animationFrameId.current = requestAnimationFrame(gameLoop);
            };
            if (!animationFrameId.current) gameLoop();
            return () => { window.removeEventListener('gamepadconnected', handleGamepadConnected); window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected); window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); if (base) base.removeEventListener('pointerdown', handlePointerDown); window.removeEventListener('pointermove', handlePointerMove); window.removeEventListener('pointerup', handlePointerUp); if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current); animationFrameId.current = null; };
          }, [isPlaying, playerState, pilotMode, handleManualControl]);

        if (isPlaying) {
            const nearbyNpcs = gameState.robotStates.filter(npc => Math.hypot(npc.x - localPlayer.x, npc.y - localPlayer.y) < 10);
            const pilotModes = [ {id: 'MANUAL', label: 'Manual', desc: 'You have full control.'}, {id: 'ASSISTED', label: 'Assisted', desc: 'Familiar pursues a specific target.'}, {id: 'AUTONOMOUS', label: 'Autonomous', desc: 'Familiar acts on its own.'} ];
            
            return ( <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-2 h-full flex flex-col gap-2">
                    <div className="flex-shrink-0 grid grid-cols-1 gap-2"> <UIToolRunner tool={getTool('Player Dashboard')} props={{ playerState: localPlayer, connectedServerInfo: gameState.connectedServerInfo }} /> </div>
                    <div className="flex-grow flex flex-col gap-2 overflow-hidden">
                        <div className="bg-black/20 p-2 rounded-lg space-y-1 overflow-y-auto">
                          <h5 className="font-semibold text-gray-300 text-sm mb-1 text-center">Nearby</h5>
                          {nearbyNpcs.map(npc => (<div key={npc.id} onClick={() => setPushTargetId(npc.id)} className={\`p-1.5 rounded-md bg-gray-700/50 flex justify-between items-center cursor-pointer \${pushTargetId === npc.id ? 'ring-2 ring-red-500' : ''}\`}><p className="font-semibold text-white text-sm">{npc.id.split('_')[0]}</p><button onClick={(e) => {e.stopPropagation(); executeTool('Interact With Entity', { playerId: playerState.id, targetId: npc.id })}} className="px-2 py-0.5 bg-green-600/80 rounded hover:bg-green-500 text-xs">Harvest</button></div>))}
                          {nearbyNpcs.length === 0 && <p className="text-xs text-gray-500 italic text-center">Nothing nearby.</p>}
                        </div>
                    </div>
                    <div className="bg-gray-900/50 p-2 rounded-lg">
                        <h5 className="font-semibold text-purple-300 text-sm mb-2 text-center">Familiar Pilot Control</h5>
                        <div className="flex rounded-md shadow-sm"> {pilotModes.map((mode, idx) => ( <button key={mode.id} onClick={() => setPilotMode(mode.id)} className={\`px-3 py-1.5 text-xs font-medium flex-1 transition-colors \${pilotMode === mode.id ? 'bg-indigo-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} \${idx === 0 ? 'rounded-l-md' : ''} \${idx === pilotModes.length - 1 ? 'rounded-r-md' : 'border-r border-gray-500'}\`}>{mode.label}</button>))} </div>
                        {pilotMode !== 'MANUAL' && ( <input type="text" value={aiPilotTarget} onChange={(e) => setAiPilotTarget(e.target.value)} placeholder="Familiar's Objective..." className="mt-2 w-full bg-gray-800 border-gray-600 rounded-md p-1.5 text-xs" /> )}
                        <p className="text-xs text-center text-gray-400 mt-1">{pilotModes.find(m => m.id === pilotMode)?.desc}</p>
                    </div>
                    <div className="flex-shrink-0 flex items-center justify-between gap-2">
                        <div ref={joystickBaseRef} className={\`relative w-24 h-24 bg-gray-700/50 rounded-full self-center flex-shrink-0 touch-none select-none \${pilotMode !== 'MANUAL' ? 'opacity-30 pointer-events-none' : ''}\`}> <div ref={joystickKnobRef} className="absolute w-12 h-12 bg-gray-500 rounded-full border-2 border-gray-400" style={{ top: '50%', left: '50%', transform: 'translate(-50%, -50%)', transition: 'transform 0.1s' }}></div> </div>
                        <div className="flex-grow h-24 flex flex-col gap-2">
                           <button onClick={() => handleManualControl('Aetheric Push', { playerId: playerState.id, targetId: pushTargetId })} disabled={!pushTargetId} className="flex-1 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg disabled:bg-gray-600 disabled:cursor-not-allowed">Aetheric Push</button>
                           <button onClick={onExitGame} className="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg">Exit World</button>
                        </div>
                    </div>
                </div> )
        }
        if (!playerState) {
             return ( <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 h-full flex flex-col justify-center gap-4">
                    <h3 className="text-lg font-bold text-purple-300 text-center">Enter Aetherium</h3>
                    <input id="player-name" placeholder="Enter your name..." type="text" value={playerNameInput} onChange={e => setPlayerNameInput(e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-indigo-500" />
                    <button onClick={() => onLoadPlayer(playerNameInput)} disabled={!playerNameInput.trim()} className="w-full bg-green-600 text-white font-semibold py-2 rounded-lg hover:bg-green-700">Load Character</button>
                </div> );
        }
        return ( <div className="bg-gray-800/60 border border-gray-700 rounded-xl p-4 h-full flex flex-col gap-4">
                <UIToolRunner tool={getTool('Player Dashboard')} props={{ playerState }} />
                 <div className="flex-grow border border-gray-700 rounded-lg p-2 bg-black/20 overflow-y-auto space-y-2">
                    <p className="text-xs text-gray-400 text-center">Available World Shards</p>
                    {servers.map(s => <button key={s.processId} onClick={() => handleJoinServer(s)} disabled={isLoading} className="w-full text-left p-2 bg-gray-700/50 rounded hover:bg-indigo-600/50">{s.processId}</button>)}
                    {servers.length === 0 && <p className="text-sm text-gray-500 text-center italic py-4">No shards active.</p>}
                 </div>
                <div className="flex gap-2">
                    <button onClick={() => onStartLocalGame(demoScripts.find(s => s.name === 'Aetherium: Genesis Ritual').workflow, playerState)} className="flex-1 bg-purple-600 text-white font-semibold py-2 rounded-lg">Offline Session</button>
                    <button onClick={handleForgeWorld} disabled={isLoading || !isServerConnected} className="flex-1 bg-indigo-600 text-white font-semibold py-2 rounded-lg disabled:bg-gray-600">Forge World Shard</button>
                </div>
            </div> ); `
};

const payloadsForInstaller = [ PLAYER_DASHBOARD_TOOL_PAYLOAD, CODEX_AETHERIUM_TOOL_PAYLOAD, ...SERVER_PROCESS_TOOLS, ...GAME_LOGIC_TOOLS ];
const AETHERIUM_INSTALLER_TOOL: ToolCreatorPayload = {
    name: 'Install Aetherium Game Suite', description: 'Installs the tools required to interact with and manage the Aetherium game world, including server management and the game client.', category: 'Automation', executionEnvironment: 'Client', purpose: "To bootstrap the agent's ability to operate within the Aetherium game world.", parameters: [],
    implementationCode: ` runtime.logEvent('[INFO] Installing Aetherium Game Suite...'); const serverTemplate = ${JSON.stringify(GAME_SERVER_TEMPLATE)};
        if (runtime.isServerConnected()) { try { await runtime.tools.run('Server File Writer', { filePath: 'aetherium_server.ts', content: serverTemplate, }); runtime.logEvent('[INFO] ✅ File \\'aetherium_server.ts\\' written successfully to \\'scripts\\' directory.'); } catch (e) { runtime.logEvent(\`[WARN] ❌ Failed to write aetherium_server.ts: \${e.message}\`); } }
        const allPayloadsToCreate = ${JSON.stringify(payloadsForInstaller)}; const allTools = runtime.tools.list(); const existingToolNames = new Set(allTools.map(t => t.name));
        for (const payload of allPayloadsToCreate) { if (existingToolNames.has(payload.name)) { runtime.logEvent(\`[INFO] Tool '\${payload.name}' already exists. Skipping.\`); continue; } try { await runtime.tools.run('Tool Creator', payload); } catch (e) { runtime.logEvent(\`[ERROR] ❌ Failed to create new tool '\${payload.name}'. Error: \${e.message}\`); } }
        if (runtime.isServerConnected()) { await runtime.forceRefreshServerTools(); runtime.logEvent(\`[SYSTEM] Server tool cache synchronized. Loaded \${runtime.tools.list().filter(t=>t.category==='Server').length} server tools.\`); }
        return { success: true, message: 'Aetherium Game Suite installed successfully.' }; `
};

export const AETHERIUM_TOOLS: ToolCreatorPayload[] = [ AETHERIUM_INSTALLER_TOOL, ];

```

# bootstrap/kicad_service_commands.ts
```bootstrap/kicad_service_commands.ts
// bootstrap/kicad_service_commands.ts
export const KICAD_SERVICE_COMMANDS_SCRIPT = `
import os
import sys
import json
import subprocess
import time
import re
import zipfile
import glob
import traceback
import ast
import fcntl
import shutil
from math import sqrt

# --- Deferred Heavy Imports ---
# These will be imported once when the service starts
pcbnew = None
skidl = None
dsn_utils = None
ses_utils = None

def _initialize_libraries():
    """Initializes heavy libraries on first use."""
    global pcbnew, skidl, dsn_utils, ses_utils
    if pcbnew is None:
        try:
            sys.path.insert(0, '/usr/lib/python3/dist-packages') # This can be problematic, better to rely on system path
            import pcbnew as pcbnew_lib
            pcbnew = pcbnew_lib
            print("INFO: pcbnew loaded successfully.", file=sys.stderr)
        except ImportError:
            raise RuntimeError("KiCad's pcbnew library not found. The service cannot function.")
    if skidl is None:
        try:
            import skidl as skidl_lib
            skidl = skidl_lib
            print("INFO: skidl loaded successfully.", file=sys.stderr)
        except ImportError:
            raise RuntimeError("SKiDL library not found. The service cannot function.")
    if dsn_utils is None:
        try:
            import kicad_dsn_utils as dsn_utils_lib
            dsn_utils = dsn_utils_lib
            print("INFO: kicad_dsn_utils loaded successfully.", file=sys.stderr)
        except ImportError:
            raise RuntimeError("kicad_dsn_utils.py not found.")
    if ses_utils is None:
        try:
            import kicad_ses_utils as ses_utils_lib
            ses_utils = ses_utils_lib
            print("INFO: kicad_ses_utils loaded successfully.", file=sys.stderr)
        except ImportError:
            raise RuntimeError("kicad_ses_utils.py not found.")

# --- State File Configuration ---
STATE_DIR = os.path.join(os.path.dirname(__file__), '..', 'assets')
os.makedirs(STATE_DIR, exist_ok=True)
DATASHEET_CACHE_DIR = os.path.join(STATE_DIR, 'datasheet_cache')
os.makedirs(DATASHEET_CACHE_DIR, exist_ok=True)
FREEROUTING_JAR_PATH = os.path.join(os.path.dirname(__file__), 'freerouting.jar')

# --- Utility Functions ---
class AutoStopper:
    def __init__(self, patience=50, low_progress_threshold=10.0):
        self.patience = patience
        self.low_progress_threshold = low_progress_threshold
        self.low_progress_count = 0

    def __call__(self, msg_text):
        match = re.search(r"(?:making|There were only) (\\\\d+\\\\.?\\\\d*) changes", msg_text)
        if match:
            changes = float(match.group(1))
            if changes < self.low_progress_threshold:
                self.low_progress_count += 1
            else:
                self.low_progress_count = 0
        if self.low_progress_count >= self.patience:
            print(f"INFO: Stopping autorouter due to low progress.", file=sys.stderr)
            return True
        return False

def get_state_path(board_name, suffix):
    return os.path.join(STATE_DIR, f"{board_name}_{suffix}")

def add_rule_to_state(project_name, rule_object):
    state_file = get_state_path(project_name, 'state.json')
    lock_path = state_file + '.lock'
    with open(lock_path, 'w') as lock_file:
        fcntl.flock(lock_file, fcntl.LOCK_EX)
        try:
            state = json.load(open(state_file)) if os.path.exists(state_file) else {}
            if 'rules' not in state: state['rules'] = []
            state['rules'].append(rule_object)
            with open(state_file, 'w') as f:
                json.dump(state, f, indent=2)
        finally:
             fcntl.flock(lock_file, fcntl.LOCK_UN)

# --- Service Command Implementations ---

def read_datasheet_cache(payload):
    cache_key = payload.get('cacheKey')
    if not cache_key or '..' in cache_key or '/' in cache_key:
        raise ValueError("Invalid cache key.")
    
    file_path = os.path.join(DATASHEET_CACHE_DIR, cache_key)
    
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Cache entry not found for key: {cache_key}")
        
    with open(file_path, 'r') as f:
        data = json.load(f)
    
    return {"message": "Cache read successfully.", "answer": data.get("answer")}

def write_datasheet_cache(payload):
    cache_key = payload.get('cacheKey')
    data_to_cache = payload.get('data')
    if not cache_key or '..' in cache_key or '/' in cache_key:
        raise ValueError("Invalid cache key.")
    if not data_to_cache:
        raise ValueError("No data provided to cache.")

    file_path = os.path.join(DATASHEET_CACHE_DIR, cache_key)
    
    with open(file_path, 'w') as f:
        json.dump(data_to_cache, f, indent=2)
        
    return {"message": f"Cache entry '{cache_key}' written successfully."}

def get_layer_geometry_info(footprint, layer_id):
    """
    Calculates the bounding box and shape type for graphical items on a specific layer, EXCLUDING TEXT.
    Returns (dimensions_dict, shape_string).
    """
    _initialize_libraries()
    layer_name = pcbnew.BOARD.GetStandardLayerName(layer_id)
    
    all_graphical_items = list(footprint.GraphicalItems())
    items_on_layer = [item for item in all_graphical_items if item.GetLayer() == layer_id]
    
    shape_items = [item for item in items_on_layer if isinstance(item, pcbnew.PCB_SHAPE)]
    
    if not shape_items:
        return None, 'rectangle'

    bbox = pcbnew.BOX2I()
    is_likely_circle = False
    if len(shape_items) == 1:
        item = shape_items[0]
        item_shape_enum = item.GetShape()
        if isinstance(item, pcbnew.PCB_SHAPE) and item_shape_enum == pcbnew.S_CIRCLE: is_likely_circle = True
        elif isinstance(item, pcbnew.PAD) and item_shape_enum == pcbnew.PAD_SHAPE_CIRCLE: is_likely_circle = True

    for item in shape_items:
        bbox.Merge(item.GetBoundingBox())

    if not bbox.IsValid(): return None, 'rectangle'

    if is_likely_circle:
        diameter = max(bbox.GetWidth(), bbox.GetHeight())
        return {'width': pcbnew.ToMM(diameter), 'height': pcbnew.ToMM(diameter)}, 'circle'
    
    return {'width': pcbnew.ToMM(bbox.GetWidth()), 'height': pcbnew.ToMM(bbox.GetHeight())}, 'rectangle'

def define_component(payload):
    _initialize_libraries()
    state_file = get_state_path(payload['projectName'], 'state.json')
    lock_path = state_file + '.lock'
    new_component = {}
    with open(lock_path, 'w') as lock_file:
        fcntl.flock(lock_file, fcntl.LOCK_EX)
        try:
            state = json.load(open(state_file)) if os.path.exists(state_file) else {}
            if 'components' not in state: state['components'] = []

            svg_path_rel, glb_path_rel = None, None
            pins_data = []

            try:
                footprint_id = payload.get('footprintIdentifier', '')
                fp = None
                if footprint_id and ':' in footprint_id:
                    library_name, footprint_name = footprint_id.split(':', 1)
                    system_footprint_dir = os.environ.get('KICAD_FOOTPRINT_DIR', '/usr/share/kicad/footprints')
                    custom_footprint_dir = os.path.join(STATE_DIR, 'footprints')
                    
                    library_path_to_use = None
                    if os.path.isdir(os.path.join(custom_footprint_dir, f"{library_name}.pretty")): library_path_to_use = custom_footprint_dir
                    elif os.path.isdir(os.path.join(system_footprint_dir, f"{library_name}.pretty")): library_path_to_use = system_footprint_dir
                    
                    if library_path_to_use:
                        fp = pcbnew.FootprintLoad(os.path.join(library_path_to_use, f"{library_name}.pretty"), footprint_name)
                
                placeholder_dimensions, placeholder_shape, drc_dimensions, drc_shape = None, 'rectangle', None, 'rectangle'

                if fp:
                    is_bottom_side = fp.GetLayer() == pcbnew.B_Cu
                    fab_f_dimensions, fab_f_shape = get_layer_geometry_info(fp, pcbnew.F_Fab)
                    crtyd_f_dimensions, crtyd_f_shape = get_layer_geometry_info(fp, pcbnew.F_CrtYd)
                    
                    placeholder_dimensions = fab_f_dimensions
                    placeholder_shape = fab_f_shape
                    drc_dimensions = crtyd_f_dimensions or fab_f_dimensions
                    drc_shape = crtyd_f_shape or fab_f_shape
                    
                    if not placeholder_dimensions:
                        bbox = fp.GetBoundingBox(False, False)
                        placeholder_dimensions = {'width': pcbnew.ToMM(bbox.GetWidth()), 'height': pcbnew.ToMM(bbox.GetHeight())}
                    
                    if not drc_dimensions:
                        drc_dimensions, drc_shape = placeholder_dimensions, placeholder_shape
                    
                    sanitized_footprint_id = re.sub(r'[\\\\/:*?"<>|]+', '_', footprint_id.replace(':', '_'))

                    if payload.get('exportSVG'):
                        final_svg_filename = f"{sanitized_footprint_id}.svg"
                        final_svg_path_abs = os.path.join(STATE_DIR, final_svg_filename)
                        
                        if not os.path.exists(final_svg_path_abs):
                            try:
                                temp_svg_path = os.path.join(STATE_DIR, f"{footprint_name}.svg")
                                if os.path.exists(temp_svg_path): os.remove(temp_svg_path)
                                cli_command = [ 'kicad-cli', 'fp', 'export', 'svg', '--footprint', footprint_name, '--output', STATE_DIR, '--layers', 'F.Cu,F.Courtyard', '--black-and-white', os.path.join(library_path_to_use, f"{library_name}.pretty") ]
                                subprocess.run(cli_command, check=True, capture_output=True, text=True)
                                if os.path.exists(temp_svg_path): os.rename(temp_svg_path, final_svg_path_abs)
                            except subprocess.CalledProcessError as e:
                                print(f"ERROR: kicad-cli SVG export failed for {footprint_id}. Stderr: {e.stderr}", file=sys.stderr)
                        svg_path_rel = os.path.join('assets', final_svg_filename).replace(os.path.sep, '/')
                    
                    if payload.get('exportGLB'):
                        final_glb_filename = f"{sanitized_footprint_id}.glb"
                        final_glb_path_abs = os.path.join(STATE_DIR, final_glb_filename)
                        if not os.path.exists(final_glb_path_abs):
                            temp_pcb_path = None
                            try:
                                temp_board = pcbnew.BOARD(); temp_board.Add(fp)
                                temp_pcb_path = os.path.join(STATE_DIR, '_temp_fp_board.kicad_pcb')
                                pcbnew.SaveBoard(temp_pcb_path, temp_board)
                                glb_cmd = ['kicad-cli', 'pcb', 'export', 'glb', '--output', final_glb_path_abs, '--subst-models', '--force', temp_pcb_path]
                                subprocess.run(glb_cmd, check=True, capture_output=True, text=True)
                            except subprocess.CalledProcessError as e:
                                print(f"ERROR: kicad-cli GLB export failed for {footprint_id}. Stderr: {e.stderr}", file=sys.stderr)
                            finally:
                                if temp_pcb_path and os.path.exists(temp_pcb_path): os.remove(temp_pcb_path)
                        glb_path_rel = os.path.join('assets', final_glb_filename).replace(os.path.sep, '/')
                    
                    for pad in fp.Pads():
                        pad_pos = pad.GetPosition()
                        pins_data.append({"name": str(pad.GetPadName()), "x": pcbnew.ToMM(pad_pos.x), "y": pcbnew.ToMM(pad_pos.y), "rotation": pad.GetOrientationDegrees()})
            except Exception as e:
                print(f"WARNING: Footprint processing error for {payload.get('footprintIdentifier')}: {e}", file=sys.stderr)

            new_component = { "id": payload['componentReference'], "label": payload['componentReference'], "ref": payload['componentReference'], "part": payload['componentDescription'], "value": payload['componentValue'], "footprint": payload['footprintIdentifier'], "pin_count": payload.get('numberOfPins', 0), "svgPath": svg_path_rel, "glbPath": glb_path_rel, "pins": pins_data, "side": payload.get('side', 'top'), "placeholder_dimensions": placeholder_dimensions, "placeholder_shape": placeholder_shape, "drc_dimensions": drc_dimensions, "drc_shape": drc_shape }
            if payload.get('pinConnections'):
                try:
                    connections = json.loads(payload['pinConnections']) if isinstance(payload['pinConnections'], str) else payload['pinConnections']
                    if isinstance(connections, list):
                        new_component['pinConnections'] = connections
                except (json.JSONDecodeError, TypeError):
                    print(f"WARNING: Could not parse pinConnections for {payload['componentReference']}", file=sys.stderr)
            state['components'] = [c for c in state['components'] if c['ref'] != new_component['ref']]
            state['components'].append(new_component)
            with open(state_file, 'w') as f: json.dump(state, f, indent=2)
        finally:
            fcntl.flock(lock_file, fcntl.LOCK_UN)
    return {"message": f"Component '{payload['componentReference']}' defined.", "newNode": new_component}

def define_net(payload):
    state_file = get_state_path(payload['projectName'], 'state.json')
    lock_path = state_file + '.lock'
    new_net = {}
    warnings = []
    with open(lock_path, 'w') as lock_file:
        fcntl.flock(lock_file, fcntl.LOCK_EX)
        try:
            state = json.load(open(state_file)) if os.path.exists(state_file) else {}
            if 'nets' not in state: state['nets'] = []
            
            components_map = {c['ref']: c for c in state.get('components', [])}
            pins_data = payload.get('pins', [])
            if isinstance(pins_data, str):
                 pins_data = ast.literal_eval(pins_data)

            for pin_str in pins_data:
                match = re.match(r'([A-Za-z0-9_]+)-([0-9A-Za-z_]+)', pin_str)
                if not match: continue
                ref, pin_num_str = match.groups()
                component = components_map.get(ref)
                if component and 'pinConnections' in component:
                    for conn in component.get('pinConnections', []):
                        if str(conn.get('pin')) == pin_num_str:
                            component_net_name = conn.get('net')
                            if component_net_name != payload['netName']:
                                warnings.append(f"Pin {pin_str}: Net is '{payload['netName']}', but component '{ref}' expects '{component_net_name}'. Please verify datasheet.")
                            break
            
            new_net = { "name": payload['netName'], "pins": pins_data }
            state['nets'] = [n for n in state['nets'] if n['name'] != new_net['name']]
            state['nets'].append(new_net)
            with open(state_file, 'w') as f: json.dump(state, f, indent=2)
        finally: fcntl.flock(lock_file, fcntl.LOCK_UN)
    
    final_message = f"Net '{payload['netName']}' defined."
    if warnings:
        final_message += " VALIDATION WARNINGS: " + " | ".join(warnings)

    edges = []
    pins_on_net = new_net.get('pins', [])
    if len(pins_on_net) > 1:
        for i in range(len(pins_on_net)):
            for j in range(i + 1, len(pins_on_net)):
                edges.append({
                    "source": pins_on_net[i],
                    "target": pins_on_net[j],
                    "label": new_net['name']
                })

    return {"message": final_message, "net": new_net, "warnings": warnings, "edges": edges}

def add_absolute_position_constraint(payload):
    if 'x' not in payload and 'y' not in payload: raise ValueError("Absolute Position Constraint requires at least an 'x' or a 'y' coordinate.")
    rule = {"type": "AbsolutePositionConstraint", "component": payload['componentReference'], "enabled": True}
    message_parts = []
    if 'x' in payload: rule['x'] = payload['x']; message_parts.append(f"x={payload['x']}")
    if 'y' in payload: rule['y'] = payload['y']; message_parts.append(f"y={payload['y']}")
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Lock {payload['componentReference']} to ({', '.join(message_parts)}).", "rule": rule}

def add_proximity_constraint(payload):
    groups = json.loads(payload['groupsJSON'])
    rule = {"type": "ProximityConstraint", "groups": groups, "enabled": True}
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Proximity constraint for {len(groups)} groups.", "rule": rule}

def add_alignment_constraint(payload):
    components = json.loads(payload['componentsJSON'])
    rule = {"type": "AlignmentConstraint", "axis": payload['axis'], "components": components, "enabled": True}
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Align {len(components)} components.", "rule": rule}

def add_symmetry_constraint(payload):
    pairs = json.loads(payload['pairsJSON'])
    rule = {"type": "SymmetryConstraint", "axis": payload['axis'], "pairs": pairs, "enabled": True}
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Symmetry for {len(pairs)} pairs.", "rule": rule}

def add_circular_constraint(payload):
    components = json.loads(payload['componentsJSON'])
    rule = {"type": "CircularConstraint", "components": components, "radius": payload['radius'], "center": [payload['centerX'], payload['centerY']], "enabled": True}
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Circular arrangement for {len(components)} components.", "rule": rule}

def add_layer_constraint(payload):
    components = json.loads(payload['componentsJSON'])
    rule = {"type": "LayerConstraint", "layer": payload['layer'], "components": components, "enabled": True}
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Place {len(components)} components on {payload['layer']}.", "rule": rule}

def add_fixed_property_constraint(payload):
    properties = json.loads(payload['propertiesJSON'])
    rule = {"type": "FixedPropertyConstraint", "component": payload['componentReference'], "properties": properties, "enabled": True}
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Fix properties for {payload['componentReference']}.", "rule": rule}

def add_symmetrical_pair_constraint(payload):
    pair = json.loads(payload['pairJSON'])
    rule = {"type": "SymmetricalPairConstraint", "pair": pair, "axis": payload['axis'], "separation": payload['separation'], "enabled": True}
    add_rule_to_state(payload['projectName'], rule)
    return {"message": f"Rule added: Symmetrical pair for {pair[0]}/{pair[1]}.", "rule": rule}

def generate_netlist(payload):
    _initialize_libraries()
    skidl.reset()
    state_file = get_state_path(payload['projectName'], 'state.json')
    if not os.path.exists(state_file): raise FileNotFoundError("State file not found.")
    state = json.load(open(state_file))
    circuit = skidl.Circuit()
    with circuit:
        for comp_data in state.get("components", []):
            part_value, pin_count = comp_data.get('value', ''), comp_data.get('pin_count', 0)
            if ':' in part_value and pin_count == 0:
                lib, name = part_value.split(':', 1)
                skidl.Part(lib=f"{lib}.kicad_sym", name=name, ref=comp_data['ref'], footprint=comp_data['footprint'])
            else:
                p = skidl.Part(tool=skidl.SKIDL, name=comp_data['part'], ref=comp_data['ref'], footprint=comp_data['footprint'])
                p.value = comp_data['value']
                if pin_count > 0: p += [skidl.Pin(num=i) for i in range(1, pin_count + 1)]
        for net_obj in state.get("nets", []):
            net = skidl.Net(net_obj['name'])
            pins_to_connect = []
            for pin_str in net_obj['pins']:
                ref, pin_num = re.match(r'([A-Za-z0-9_]+)-([0-9A-Za-z_]+)', pin_str).groups()
                part = next((p for p in circuit.parts if str(p.ref) == ref), None)
                if part: pins_to_connect.append(part[pin_num])
            net += tuple(pins_to_connect)
    netlist_path = get_state_path(payload['projectName'], 'netlist.net')
    circuit.generate_netlist(file_=netlist_path)
    return {"message": "Netlist generated successfully."}

def create_initial_pcb(payload):
    _initialize_libraries()
    netlist_path, pcb_path = get_state_path(payload['projectName'], 'netlist.net'), get_state_path(payload['projectName'], 'pcb.kicad_pcb')
    if not os.path.exists(netlist_path): raise FileNotFoundError("Netlist file not found.")
    custom_footprints_path = os.path.join(STATE_DIR, 'footprints')
    command = ['kinet2pcb', '-i', netlist_path, '-o', pcb_path, '-l', '.']
    if os.path.isdir(custom_footprints_path): command.extend(['-l', custom_footprints_path])
    try: subprocess.run(command, check=True, capture_output=True, text=True)
    except subprocess.CalledProcessError as e: raise Exception(f"kinet2pcb failed. Stderr: {e.stderr}. Stdout: {e.stdout}") from e
    board = pcbnew.LoadBoard(pcb_path); board.SetCopperLayerCount(4)
    state_file = get_state_path(payload['projectName'], 'state.json')
    if os.path.exists(state_file):
        state_data = json.load(open(state_file))
        for comp_data in state_data.get('components', []):
            if comp_data.get('side') == 'bottom':
                ref = comp_data.get('ref')
                fp = board.FindFootprintByReference(ref)
                if fp and fp.GetLayer() == pcbnew.F_Cu:
                    fp.SetLayerAndFlip(pcbnew.B_Cu)
    pcbnew.SaveBoard(pcb_path, board)
    return {"message": "Initial 4-layer PCB created."}

def create_board_outline(payload):
    _initialize_libraries()
    project_name, pcb_path = payload['projectName'], get_state_path(payload['projectName'], 'pcb.kicad_pcb')
    state_file, lock_path = get_state_path(project_name, 'state.json'), get_state_path(project_name, 'state.json') + '.lock'
    if not os.path.exists(pcb_path): raise FileNotFoundError("PCB file not found.")
    board = pcbnew.LoadBoard(pcb_path)
    for drawing in list(board.GetDrawings()):
        if drawing.GetLayerName() == 'Edge.Cuts': board.Remove(drawing)
    is_auto_size = not any(key in payload and payload[key] is not None and payload[key] > 0 for key in ['boardWidthMillimeters', 'boardHeightMillimeters', 'diameterMillimeters'])
    outline_data = {"shape": payload.get('shape', 'rectangle'), "autoSize": is_auto_size}
    if payload.get('shape') == 'circle':
        diameter_mm = payload.get('diameterMillimeters', 0) or (0 if is_auto_size else 50)
        outline_data['diameter'] = diameter_mm
        if not is_auto_size:
            radius_nm, center = pcbnew.FromMM(diameter_mm / 2.0), pcbnew.VECTOR2I(0,0)
            circle = pcbnew.PCB_SHAPE(board, pcbnew.SHAPE_T_CIRCLE); circle.SetLayer(pcbnew.Edge_Cuts); circle.SetStart(center); circle.SetEnd(pcbnew.VECTOR2I(center.x + int(radius_nm), center.y)); board.Add(circle)
        message = f"Circular board outline created (diameter: {diameter_mm:.2f}mm, autoSize: {is_auto_size})."
    else: # rectangle
        width_mm, height_mm = payload.get('boardWidthMillimeters', 0) or (0 if is_auto_size else 50), payload.get('boardHeightMillimeters', 0) or (0 if is_auto_size else 50)
        outline_data.update({'width': width_mm, 'height': height_mm})
        if not is_auto_size:
            w_nm, h_nm = pcbnew.FromMM(width_mm), pcbnew.FromMM(height_mm)
            x_offset, y_offset = -w_nm // 2, -h_nm // 2
            points = [ pcbnew.VECTOR2I(x_offset, y_offset), pcbnew.VECTOR2I(x_offset + w_nm, y_offset), pcbnew.VECTOR2I(x_offset + w_nm, y_offset + h_nm), pcbnew.VECTOR2I(x_offset, y_offset + h_nm), pcbnew.VECTOR2I(x_offset, y_offset) ]
            for i in range(len(points) - 1):
                seg = pcbnew.PCB_SHAPE(board); seg.SetShape(pcbnew.S_SEGMENT); seg.SetStart(points[i]); seg.SetEnd(points[i+1]); seg.SetLayer(pcbnew.Edge_Cuts); seg.SetWidth(pcbnew.FromMM(0.1)); board.Add(seg)
        message = f"Rectangular board outline created ({width_mm:.2f}mm x {height_mm:.2f}mm, autoSize: {is_auto_size})."
    pcbnew.SaveBoard(pcb_path, board)
    with open(lock_path, 'w') as lock_file:
        fcntl.flock(lock_file, fcntl.LOCK_EX)
        try:
            state = json.load(open(state_file)) if os.path.exists(state_file) else {}
            state['board_outline'] = outline_data
            with open(state_file, 'w') as f: json.dump(state, f, indent=2)
        finally: fcntl.flock(lock_file, fcntl.LOCK_UN)
    return {"message": message, "board_outline": outline_data}

def create_copper_pour(payload):
    _initialize_libraries()
    pcb_path = get_state_path(payload['projectName'], 'pcb.kicad_pcb')
    if not os.path.exists(pcb_path): raise FileNotFoundError(f"PCB file not found.")
    board = pcbnew.LoadBoard(pcb_path)
    merged_outlines = dsn_utils.merge_all_drawings(board, 'Edge.Cuts')
    if not merged_outlines or not merged_outlines[0]: raise ValueError("Board outline is missing.")
    zone_outline = pcbnew.SHAPE_POLY_SET(); outline_contour = zone_outline.NewOutline()
    for point_tuple in merged_outlines[0]: zone_outline.Append(int(point_tuple[0]), int(point_tuple[1]), outline_contour)
    net_info = board.FindNet(payload['netName'])
    if not net_info or net_info.GetNetCode() == 0: raise ValueError(f"Net '{payload['netName']}' not found.")
    layer_id = board.GetLayerID(payload['layerName'])
    if layer_id == pcbnew.UNDEFINED_LAYER or not board.IsLayerEnabled(layer_id) or not pcbnew.IsCopperLayer(layer_id): raise ValueError(f"Layer '{payload['layerName']}' is not a valid copper layer.")
    zone = pcbnew.ZONE(board); board.Add(zone); zone.SetLayer(layer_id); zone.SetNet(net_info); zone.SetOutline(zone_outline);
    zone.SetMinThickness(pcbnew.FromMM(0.25)); zone.SetThermalReliefGap(pcbnew.FromMM(0.5)); zone.SetThermalReliefSpokeWidth(pcbnew.FromMM(0.5)); zone.SetPadConnection(pcbnew.ZONE_CONNECTION_THERMAL); zone.SetIsFilled(False)
    pcbnew.SaveBoard(pcb_path, board)
    return {"message": f"Copper pour created on layer '{payload['layerName']}' for net '{payload['netName']}'."}

def arrange_components(payload):
    _initialize_libraries()
    pcb_path, state_file = get_state_path(payload['projectName'], 'pcb.kicad_pcb'), get_state_path(payload['projectName'], 'state.json')
    if not os.path.exists(pcb_path) or not os.path.exists(state_file): raise FileNotFoundError("PCB or State file not found.")
    board = pcbnew.LoadBoard(pcb_path); state_data = json.load(open(state_file))
    board_outline_settings = state_data.get('board_outline', {})
    edge_cuts = dsn_utils.merge_all_drawings(board, 'Edge.Cuts')
    min_x, max_x, min_y, max_y = (0, 0, 0, 0)
    if edge_cuts and edge_cuts[0]:
        all_x = [p[0] for p in edge_cuts[0]]; all_y = [p[1] for p in edge_cuts[0]]
        min_x, max_x, min_y, max_y = min(all_x), max(all_x), min(all_y), max(all_y)
    final_outline = { "shape": board_outline_settings.get('shape', 'rectangle'), "autoSize": board_outline_settings.get('autoSize', True), "x": pcbnew.ToMM(min_x), "y": pcbnew.ToMM(min_y), "width": pcbnew.ToMM(max_x - min_x), "height": pcbnew.ToMM(max_y - min_y) }
    layout_data = { "nodes": [], "edges": [], "rules": state_data.get("rules", []), "layoutStrategy": payload.get("layoutStrategy", "agent"), "board_outline": final_outline }
    state_components_map = {comp['ref']: comp for comp in state_data.get('components', [])}
    for fp in board.Footprints():
        ref, state_comp = fp.GetReference(), state_components_map.get(fp.GetReference(), {})
        layout_data["nodes"].append({ "id": ref, "label": ref, "x": pcbnew.ToMM(fp.GetPosition().x), "y": pcbnew.ToMM(fp.GetPosition().y), "rotation": fp.GetOrientationDegrees(), "side": state_comp.get('side', 'top'), "svgPath": state_comp.get('svgPath'), "glbPath": state_comp.get('glbPath'), "pins": state_comp.get('pins', []), "footprint": state_comp.get('footprint'), "placeholder_dimensions": state_comp.get('placeholder_dimensions'), "placeholder_shape": state_comp.get('placeholder_shape'), "drc_dimensions": state_comp.get('drc_dimensions'), "drc_shape": state_comp.get('drc_shape') })
    
    # Re-enable clique topology for nets to ensure all-to-all connections are simulated.
    for net in state_data.get('nets', []):
        pins_on_net = net.get('pins', [])
        if len(pins_on_net) > 1:
            for i in range(len(pins_on_net)):
                for j in range(i + 1, len(pins_on_net)):
                    layout_data["edges"].append({
                        "source": pins_on_net[i],
                        "target": pins_on_net[j],
                        "label": net['name']
                    })

    return {"message": "Extracted layout data.", "layout_data": layout_data, "waitForUserInput": payload.get('waitForUserInput', True)}

def update_component_positions(payload):
    _initialize_libraries()
    project_name = payload['projectName']
    pcb_path = get_state_path(project_name, 'pcb.kicad_pcb')
    state_file = get_state_path(project_name, 'state.json')
    lock_path = state_file + '.lock'
    
    board = pcbnew.LoadBoard(pcb_path)
    positions = json.loads(payload['componentPositionsJSON'])
    
    for ref, pos_data in positions.items():
        fp = board.FindFootprintByReference(ref)
        if fp:
            fp.SetPosition(pcbnew.VECTOR2I(pcbnew.FromMM(pos_data['x']), pcbnew.FromMM(pos_data['y'])))
            fp.SetOrientation(pcbnew.EDA_ANGLE(float(pos_data.get('rotation', 0)), pcbnew.DEGREES_T))
            if pos_data.get('side') == 'bottom' and not fp.IsFlipped(): fp.SetLayerAndFlip(pcbnew.B_Cu)
            elif pos_data.get('side') == 'top' and fp.IsFlipped(): fp.SetLayerAndFlip(pcbnew.F_Cu)

    state_data = json.load(open(state_file)) if os.path.exists(state_file) else {}
    board_outline_settings = state_data.get('board_outline', {})
    should_auto_resize = board_outline_settings.get('autoSize', False)
    message = "Component positions updated."

    if should_auto_resize:
        for drawing in list(board.GetDrawings()):
            if drawing.GetLayerName() == 'Edge.Cuts': board.Remove(drawing)
        
        footprints_bbox = pcbnew.BOX2I()
        for fp in board.Footprints(): footprints_bbox.Merge(fp.GetBoundingBox(True, False))
        
        margin_mm = payload.get('boardPadding', 5.0)
        margin_nm = pcbnew.FromMM(margin_mm)
        footprints_bbox.Inflate(margin_nm, margin_nm)
        
        x_offset, y_offset, w_nm, h_nm = footprints_bbox.GetX(), footprints_bbox.GetY(), footprints_bbox.GetWidth(), footprints_bbox.GetHeight()

        new_outline_data = { "autoSize": False } # After sizing, it's no longer auto
        
        if board_outline_settings.get('shape') == 'circle':
            new_outline_data['shape'] = 'circle'
            diameter_nm, radius_nm = max(w_nm, h_nm), max(w_nm, h_nm) / 2
            new_outline_data['diameter'] = pcbnew.ToMM(diameter_nm)
            center = pcbnew.VECTOR2I(int(x_offset + w_nm / 2), int(y_offset + h_nm / 2))
            circle = pcbnew.PCB_SHAPE(board, pcbnew.SHAPE_T_CIRCLE)
            circle.SetLayer(pcbnew.Edge_Cuts)
            circle.SetStart(center)
            circle.SetEnd(pcbnew.VECTOR2I(center.x + int(radius_nm), center.y))
            board.Add(circle)
        else: # rectangle
            new_outline_data['shape'] = 'rectangle'
            new_outline_data['width'] = pcbnew.ToMM(w_nm)
            new_outline_data['height'] = pcbnew.ToMM(h_nm)
            points = [ pcbnew.VECTOR2I(x_offset, y_offset), pcbnew.VECTOR2I(x_offset + w_nm, y_offset), pcbnew.VECTOR2I(x_offset + w_nm, y_offset + h_nm), pcbnew.VECTOR2I(x_offset, y_offset + h_nm), pcbnew.VECTOR2I(x_offset, y_offset) ]
            for i in range(len(points) - 1):
                seg = pcbnew.PCB_SHAPE(board); seg.SetShape(pcbnew.S_SEGMENT); seg.SetStart(points[i]); seg.SetEnd(points[i+1]); seg.SetLayer(pcbnew.Edge_Cuts); seg.SetWidth(pcbnew.FromMM(0.1)); board.Add(seg)
        
        message = "Component positions updated and board outline resized."
        
        with open(lock_path, 'w') as lock_file:
            fcntl.flock(lock_file, fcntl.LOCK_EX)
            try:
                state_data['board_outline'] = new_outline_data
                with open(state_file, 'w') as f: json.dump(state_data, f, indent=2)
            finally: fcntl.flock(lock_file, fcntl.LOCK_UN)
    
    pcbnew.SaveBoard(pcb_path, board)
    return {"message": message}

def autoroute_pcb(payload):
    _initialize_libraries()
    project_name = payload['projectName']
    pcb_path = get_state_path(project_name, 'pcb.kicad_pcb')
    dsn_path = get_state_path(project_name, 'design.dsn')
    ses_path = get_state_path(project_name, 'routed.ses')
    
    if not os.path.exists(pcb_path): raise FileNotFoundError("PCB file not found.")
    board = pcbnew.LoadBoard(pcb_path)

    # Hybrid DSN Generation: Try official API, fall back to custom implementation
    dsn_generated = False
    try:
        # pcbnew.ExportSpecctraDSN returns a boolean in some versions, None in others
        result = pcbnew.ExportSpecctraDSN(board, dsn_path)
        if result is False: raise Exception("pcbnew.ExportSpecctraDSN returned False.")
        dsn_generated = True
        print(f"INFO: Successfully exported DSN using official pcbnew.ExportSpecctraDSN.", file=sys.stderr)
    except Exception as e:
        print(f"WARNING: Official DSN export failed: {e}. Falling back to custom DSN generator.", file=sys.stderr)
        try:
            dsn_content = dsn_utils.board_to_dsn(pcb_path, board)
            with open(dsn_path, 'w', encoding='utf-8') as f:
                f.write(str(dsn_content))
            dsn_generated = True
            print(f"INFO: Successfully exported DSN using custom kicad_dsn_utils.", file=sys.stderr)
        except Exception as custom_e:
            raise Exception(f"Custom DSN export also failed: {custom_e}")

    if not dsn_generated: raise Exception("All DSN generation methods failed.")

    if not os.path.exists(FREEROUTING_JAR_PATH): raise FileNotFoundError(f"FreeRouting JAR not found at {FREEROUTING_JAR_PATH}")
    
    command = ["java", "-jar", FREEROUTING_JAR_PATH, "-de", dsn_path, "-do", ses_path]
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, errors='replace')
    
    auto_stopper = AutoStopper(patience=10, low_progress_threshold=5.0)
    stop_routing = False
    
    for line in iter(proc.stderr.readline, ''):
        print("FREEROUTING:", line.strip(), file=sys.stderr)
        if auto_stopper(line.strip()):
            proc.terminate(); stop_routing = True; break
    
    if not stop_routing: proc.wait()
    if proc.returncode != 0 and not stop_routing: raise Exception(f"FreeRouting failed. Last output: {proc.stderr.read()}")
    if not os.path.exists(ses_path): raise FileNotFoundError("Routed session file (.ses) not created.")
    
    # Clear existing tracks before import
    for track in list(board.GetTracks()): board.Remove(track)
    
    # Hybrid SES Import
    ses_imported = False
    try:
        result = pcbnew.ImportSpecctraSES(board, ses_path)
        if result is False: raise Exception("pcbnew.ImportSpecctraSES returned False.")
        ses_imported = True
        print(f"INFO: Successfully imported SES using official pcbnew.ImportSpecctraSES.", file=sys.stderr)
    except Exception as e:
        print(f"WARNING: Official SES import failed: {e}. Falling back to custom SES parser.", file=sys.stderr)
        try:
            ses_utils.parse_and_apply_ses(board, ses_path)
            ses_imported = True
            print(f"INFO: Successfully imported SES using custom kicad_ses_utils.", file=sys.stderr)
        except Exception as custom_e:
            raise Exception(f"Custom SES import also failed: {custom_e}")
    
    if not ses_imported: raise Exception("All SES import methods failed.")

    pcbnew.SaveBoard(pcb_path, board)
    
    # SVG Plotting
    svg_rel_path = os.path.join('assets', f'{project_name}_routed.svg').replace(os.path.sep, '/')
    final_svg_path_abs = get_state_path(project_name, 'routed.svg')
    pctl = pcbnew.PLOT_CONTROLLER(board)
    popts = pctl.GetPlotOptions(); popts.SetOutputDirectory(STATE_DIR)
    pctl.OpenPlotfile("temp_routed_svg", pcbnew.PLOT_FORMAT_SVG, "Routed board")
    for layer_id in [pcbnew.F_Cu, pcbnew.B_Cu, pcbnew.Edge_Cuts, pcbnew.F_SilkS, pcbnew.B_SilkS, pcbnew.F_Mask, pcbnew.B_Mask]:
        pctl.SetLayer(layer_id); pctl.PlotLayer()
    pctl.ClosePlot()
    temp_svg_path = os.path.join(STATE_DIR, "temp_routed_svg-B_Cu.svg") # Example, KiCad might name them differently
    
    # This is a bit of a hack because kicad-cli names files based on layer. We'll find the most relevant one.
    best_svg = None
    for f in glob.glob(os.path.join(STATE_DIR, "temp_routed_svg-*.svg")):
        if 'F_Cu' in f: best_svg = f; break
        best_svg = f
    
    if best_svg and os.path.exists(best_svg):
        if os.path.exists(final_svg_path_abs): os.remove(final_svg_path_abs)
        os.rename(best_svg, final_svg_path_abs)
        # Clean up other plot files
        for f in glob.glob(os.path.join(STATE_DIR, "temp_routed_svg-*.svg")): os.remove(f)

    return {"message": "Autorouting complete. SVG preview generated.", "current_artifact": {"title": "Routed PCB", "path": svg_rel_path, "svgPath": svg_rel_path}}

def export_fabrication_files(payload):
    _initialize_libraries()
    pcb_path = get_state_path(payload['projectName'], 'pcb.kicad_pcb')
    if not os.path.exists(pcb_path): raise FileNotFoundError("PCB file not found.")
    fab_dir = os.path.join(STATE_DIR, f"{payload['projectName']}_fab"); os.makedirs(fab_dir, exist_ok=True)
    try:
        layers = "F.Cu,B.Cu,F.Paste,B.Paste,F.SilkS,B.SilkS,F.Mask,B.Mask,Edge.Cuts"
        gerber_cmd = ['kicad-cli', 'pcb', 'export', 'gerbers', '--output', fab_dir, '--layers', layers, pcb_path]
        subprocess.run(gerber_cmd, check=True, capture_output=True, text=True)
        drill_cmd = ['kicad-cli', 'pcb', 'export', 'drill', '--output', fab_dir, pcb_path]
        subprocess.run(drill_cmd, check=True, capture_output=True, text=True)
        glb_path_rel = os.path.join('assets', f'{payload["projectName"]}_board.glb').replace(os.path.sep, '/')
        glb_path_abs = os.path.join(os.path.dirname(__file__), '..', 'assets', f'{payload["projectName"]}_board.glb')
        glb_cmd = ['kicad-cli', 'pcb', 'export', 'glb', '--output', glb_path_abs, '--subst-models', '--include-tracks', '--include-pads', '--include-zones', '--force', pcb_path]
        subprocess.run(glb_cmd, check=True, capture_output=True, text=True)
        zip_path_rel = os.path.join('assets', f"{payload['projectName']}_fab.zip").replace(os.path.sep, '/')
        zip_path_abs = os.path.join(os.path.dirname(__file__), '..', 'assets', f"{payload['projectName']}_fab.zip")
        with zipfile.ZipFile(zip_path_abs, 'w') as zf:
            for file in glob.glob(os.path.join(fab_dir, '*')): zf.write(file, os.path.basename(file))
        shutil.rmtree(fab_dir)
    except subprocess.CalledProcessError as e:
        raise Exception(f"kicad-cli failed. Command: '{' '.join(e.cmd)}'. Stderr: {e.stderr}")
    except Exception as e:
        raise Exception(f"An unexpected error occurred during fabrication export: {e}")
    return {"message": "Fabrication files exported and zipped.", "artifacts": { "boardName": payload['projectName'], "glbPath": glb_path_rel, "fabZipPath": zip_path_rel }}
`
```

# bootstrap/sim/simulation_collisions.ts
```bootstrap/sim/simulation_collisions.ts
// bootstrap/sim/simulation_collisions.ts
// This file is now intentionally empty.
// All collision detection and resolution is handled by the Rapier.js engine
// inside of agent_simulation.ts to ensure correctness and performance.

export const CollisionSimulationFunctionsString = `
    getRotatedRectCorners(agent, drcDims) {
        const { pos, rot } = agent;
        const { width, height } = drcDims;
        const w = width * this.SCALE / 2;
        const h = height * this.SCALE / 2;
        const corners = [ { x: -w, z: -h }, { x: w, z: -h }, { x: w, z: h }, { x: -w, z: h }];
        const q = new this.THREE.Quaternion(rot.x, rot.y, rot.z, rot.w);
        return corners.map(c => {
            const vec = new this.THREE.Vector3(c.x, 0, c.z);
            vec.applyQuaternion(q);
            vec.add(new this.THREE.Vector3(pos.x, 0, pos.z));
            return { x: vec.x, z: vec.z };
        });
    }

    updateDRCStatus(eventQueue) {
        this.agents.forEach(agent => { agent.drcStatus = 'ok'; });

        eventQueue.drainCollisionEvents((handle1, handle2, started) => {
            if (started) {
                const collider1 = this.world.getCollider(handle1);
                const collider2 = this.world.getCollider(handle2);

                if (!collider1 || !collider2) return;

                const body1Handle = collider1.parent().handle;
                const body2Handle = collider2.parent().handle;

                const idA = this.handleToAgentIdMap.get(body1Handle);
                const idB = this.handleToAgentIdMap.get(body2Handle);

                if (idA && this.agents.has(idA)) this.agents.get(idA).drcStatus = 'overlap';
                if (idB && this.agents.has(idB)) this.agents.get(idB).drcStatus = 'overlap';
            }
        });

        if (this.graph.board_outline) {
            const { x, y, width, height, shape } = this.graph.board_outline;
            this.agents.forEach((agent, id) => {
                if (agent.drcStatus === 'ok') {
                    const node = this.nodeMap.get(id);
                    const { drcDims } = this.getEffectiveDrcInfo(node);
                    const node_w2 = (drcDims.width / 2) * this.SCALE;
                    const node_h2 = (drcDims.height / 2) * this.SCALE;
                    let isOutOfBounds = false;
                    if (shape === 'circle') {
                        const centerX = (x + width / 2) * this.SCALE, centerZ = (y + height / 2) * this.SCALE;
                        const radius = (width / 2) * this.SCALE;
                        const max_extent = Math.hypot(node_w2, node_h2);
                        const dist = Math.hypot(agent.pos.x - centerX, agent.pos.z - centerZ);
                        if (dist + max_extent > radius) isOutOfBounds = true;
                    } else {
                        const minX = x * this.SCALE, minZ = y * this.SCALE;
                        const maxX = (x + width) * this.SCALE, maxZ = (y + height) * this.SCALE;
                        if ( (agent.pos.x - node_w2) < minX || (agent.pos.x + node_w2) > maxX || (agent.pos.z - node_h2) < minZ || (agent.pos.z + node_h2) > maxZ ) isOutOfBounds = true;
                    }
                    if(isOutOfBounds) agent.drcStatus = 'out_of_bounds';
                }
            });
        }
    }
`;
```

# bootstrap/sim/ui_panels.tsx
```bootstrap/sim/ui_panels.tsx
export const AgentDebugPanelString = `
const AgentDebugPanel = ({ agents, debugInfo, selectedId, selectedNode, onSelect, onHover, filter, onFilterChange }) => {
    // The filter state is now managed by the parent component.
    // This component simply receives the current filter value and the function to change it.

    const filteredAgents = React.useMemo(() => 
        (agents || []).filter(agent => agent.id.toLowerCase().includes((filter || '').toLowerCase())),
        [agents, filter]
    );

    const ForceBar = ({ value, max }) => {
        const percentage = max > 0 ? Math.min(100, (Math.abs(value) / max) * 100) : 0;
        return (
            <div className="w-full bg-gray-600 rounded-full h-1.5">
                <div className="bg-cyan-400 h-1.5 rounded-full" style={{ width: \`\${percentage}%\` }}></div>
            </div>
        );
    };

    return (
        <div className="bg-gray-800/70 backdrop-blur-sm border border-gray-700 rounded-xl p-2 flex flex-col h-full text-white">
            <h3 className="text-lg font-bold text-cyan-300 mb-2 text-center">Inspector</h3>
            <input
                id="agent-filter"
                name="agent-filter"
                type="text"
                placeholder="Filter items..."
                value={filter}
                onChange={e => onFilterChange(e.target.value)}
                className="w-full bg-gray-900 border border-gray-600 rounded-md p-1.5 text-sm mb-2"
            />
            <div className="flex-grow overflow-y-auto pr-1">
                {filteredAgents.map(agent => {
                    const info = debugInfo[agent.id] || { totalForce: { x: 0, z: 0 }, forces: {}, drcStatus: 'ok' };
                    const drcStatus = info.drcStatus || 'ok';
                    const totalForceMag = Math.hypot(info.totalForce.x, info.totalForce.z);
                    const isSelected = selectedId === agent.id;
                    const maxForce = Math.max(1, ...Object.values(info.forces || {}).map(v => Number(v) || 0));

                    let drcIcon = '✅';
                    let drcColor = 'text-green-400';
                    if (drcStatus === 'out_of_bounds') {
                        drcIcon = '⚠️';
                        drcColor = 'text-yellow-400';
                    } else if (drcStatus === 'overlap') {
                        drcIcon = '❌';
                        drcColor = 'text-red-400';
                    }

                    return (
                        <div
                            key={agent.id}
                            onMouseEnter={() => onHover(agent.id, true)}
                            onMouseLeave={() => onHover(agent.id, false)}
                            className={\`mb-1 rounded-lg transition-all duration-200 \${isSelected ? 'bg-indigo-700' : 'bg-gray-700/50'}\`}
                        >
                            <button onClick={() => onSelect(agent.id)} className="w-full text-left p-2">
                                <div className="flex justify-between items-center">
                                    <div className="flex items-center gap-2">
                                        <span className={drcColor} title={\`DRC Status: \${drcStatus}\`}>{drcIcon}</span>
                                        <span className="font-bold">{agent.id}</span>
                                    </div>
                                    <span className="text-xs font-mono text-cyan-300">{totalForceMag.toFixed(0)}</span>
                                </div>
                            </button>
                            {isSelected && (
                                <div className="p-2 border-t border-indigo-500 text-xs space-y-2">
                                    {selectedNode && (
                                        <div className="space-y-1 pb-2 mb-2 border-b border-indigo-600/50">
                                            <h5 className="font-bold text-indigo-200">Properties</h5>
                                            <div><span className="text-gray-400">Type:</span> {selectedNode.type || 'N/A'}</div>
                                            {selectedNode.footprint && <div className="truncate"><span className="text-gray-400">Footprint:</span> {selectedNode.footprint}</div>}
                                            {selectedNode.side && <div><span className="text-gray-400">Side:</span> {selectedNode.side}</div>}
                                            {selectedNode.asset_glb && <div className="truncate"><span className="text-gray-400">Asset:</span> {selectedNode.asset_glb}</div>}
                                        </div>
                                    )}
                                    <h5 className="font-bold text-indigo-200">Live Forces</h5>
                                    {Object.entries(info.forces || {}).sort(([, a], [, b]) => Number(b) - Number(a)).map(([name, value]) => (
                                        <div key={name}>
                                            <div className="flex justify-between">
                                                <span>{name}</span>
                                                <span className="font-mono">{Number(value).toFixed(0)}</span>
                                            </div>
                                            <ForceBar value={Number(value)} max={maxForce} />
                                        </div>
                                    ))}
                                    {Object.keys(info.forces || {}).length === 0 && <p className="text-gray-500">No forces acting.</p>}
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};
`
```

# bootstrap/sim/simulation_forces.ts
```bootstrap/sim/simulation_forces.ts
// bootstrap/sim/simulation_forces.ts

export const ForceSimulationFunctionsString = `
    getPinWorldPos(agentId) {
        const agent = this.agents.get(agentId);
        const node = this.nodeMap.get(agentId);
        if (!agent || !node) return {};
        const pinMap = this.pinDataMap.get(agentId);
        if (!pinMap) return {};

        const worldPositions = {};
        
        const agentQuaternion = new this.THREE.Quaternion(agent.rot.x, agent.rot.y, agent.rot.z, agent.rot.w);
        const agentPosition = new this.THREE.Vector3(agent.pos.x, agent.pos.y, agent.pos.z);

        pinMap.forEach((pin, pinName) => {
            const localPinVector = new this.THREE.Vector3(
                pin.x * this.SCALE,
                0,
                -pin.y * this.SCALE 
            );
            localPinVector.applyQuaternion(agentQuaternion);
            const worldPinVector = localPinVector.add(agentPosition);
            worldPositions[pinName] = { x: worldPinVector.x, z: worldPinVector.z };
        });
        return worldPositions;
    }

    clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    applyNetForcesForAgent(agentId, allPinWorldPos) {
        const K_SPRING = this.params.netLengthWeight; 
        if (!K_SPRING || K_SPRING === 0) return;
        const currentAgent = this.agents.get(agentId);
        const currentNode = this.nodeMap.get(agentId);
        if (!currentAgent || !currentNode) return;
    
        (this.graph.edges || []).forEach(edge => {
            const [sourceComp, sourcePin] = edge.source.split('-');
            const [targetComp, targetPin] = edge.target.split('-');
            
            let otherCompId = null, thisPinName = null, otherPinName = null;
            if (sourceComp === agentId) {
                otherCompId = targetComp; thisPinName = sourcePin; otherPinName = targetPin;
            } else if (targetComp === agentId) {
                otherCompId = sourceComp; thisPinName = targetPin; otherPinName = sourcePin;
            }
    
            if (otherCompId && otherCompId !== agentId) {
                const otherNode = this.nodeMap.get(otherCompId);
                if (!otherNode) return;

                const mySize = (currentNode.placeholder_dimensions?.width ?? 0) * (currentNode.placeholder_dimensions?.height ?? 0);
                const otherSize = (otherNode.placeholder_dimensions?.width ?? 0) * (otherNode.placeholder_dimensions?.height ?? 0);

                if (mySize > otherSize) {
                    return;
                }

                const thisPinPos = allPinWorldPos[agentId]?.[thisPinName];
                const otherPinPos = allPinWorldPos[otherCompId]?.[otherPinName];
                if (thisPinPos && otherPinPos) {
                    const dx = otherPinPos.x - thisPinPos.x;
                    const dz = otherPinPos.z - thisPinPos.z;
                    const fx = dx * K_SPRING;
                    const fz = dz * K_SPRING;
                    currentAgent.force.x += fx;
                    currentAgent.force.z += fz;
                    const forceMag = Math.hypot(fx, fz);
                    currentAgent.lastForces['Net Attraction'] = (currentAgent.lastForces['Net Attraction'] || 0) + forceMag;
                }
            }
        });
    }

    applyDistributionForceForAgent(agentId) {
        const K_DIST = this.params.distributionStrength;
        if (K_DIST === 0) return;

        const agent = this.agents.get(agentId);
        if (!agent) return;

        const numAgents = this.agents.size;
        if (numAgents <= 1) return;
        
        let comX = 0, comZ = 0;
        this.agents.forEach((otherAgent, otherId) => {
            if (otherId !== agentId) {
                comX += otherAgent.pos.x;
                comZ += otherAgent.pos.z;
            }
        });
        comX /= (numAgents - 1);
        comZ /= (numAgents - 1);

        const dx = agent.pos.x - comX;
        const dz = agent.pos.z - comZ;
        
        const forceX = dx * K_DIST;
        const forceZ = dz * K_DIST;

        agent.force.x += forceX;
        agent.force.z += forceZ;

        const forceMag = Math.hypot(forceX, forceZ);
        if (forceMag > 0.1) {
            agent.lastForces['Center Repulsion'] = (agent.lastForces['Center Repulsion'] || 0) + forceMag;
        }
    }
    
    applySymmetryForAgent(agentId, rule) {
        const K_SYMMETRY = this.params.symmetryStrength;
        const axis = rule.axis || 'vertical';
        const pair = rule.pairs.find(p => p.includes(agentId));
        if (!pair) return;

        const otherId = pair[0] === agentId ? pair[1] : pair[0];
        const agentA = this.agents.get(agentId);
        const agentB = this.agents.get(otherId);
        if (!agentA || !agentB) return;

        let targetAx, targetAz;
        if (axis === 'vertical') {
            targetAx = -agentB.pos.x;
            targetAz = agentB.pos.z;
        } else {
            targetAx = agentB.pos.x;
            targetAz = -agentB.pos.z;
        }
        const fx = (targetAx - agentA.pos.x) * K_SYMMETRY;
        const fz = (targetAz - agentA.pos.z) * K_SYMMETRY;
        agentA.force.x += fx;
        agentA.force.z += fz;
        agentA.lastForces['Symmetry Strength'] = (agentA.lastForces['Symmetry Strength'] || 0) + Math.hypot(fx, fz);

        const nodeA = this.nodeMap.get(agentId);
        const nodeB = this.nodeMap.get(otherId);
        if (nodeA && nodeB) {
            const Kp_rot = this.params.symmetryRotationStrength * 100;
            const Kd_rot = Kp_rot / 10;
            const currentRotA = new this.THREE.Euler().setFromQuaternion(agentA.rot, 'YXZ').y;
            const currentRotB = new this.THREE.Euler().setFromQuaternion(agentB.rot, 'YXZ').y;
            
            const targetAngleA = currentRotB;

            let error = targetAngleA - currentRotA;
            while (error < -Math.PI) error += 2 * Math.PI;
            while (error > Math.PI) error -= 2 * Math.PI;
            const torqueY = Kp_rot * error - Kd_rot * agentA.angularVel.y;
            agentA.torque.y += torqueY;
            agentA.lastForces['Symmetry Rotation'] = (agentA.lastForces['Symmetry Rotation'] || 0) + Math.abs(torqueY);
        }
    }
    
    applyAlignmentForAgent(agentId, rule) {
        const K_ALIGN = this.params.alignmentStrength;
        const axis = rule.axis || 'vertical';
        const agent = this.agents.get(agentId);
        if (!agent) return;
        let force = 0;
        if (axis === 'vertical') {
            const f = (0 - agent.pos.x) * K_ALIGN;
            agent.force.x += f;
            force = Math.abs(f);
        } else {
            const f = (0 - agent.pos.z) * K_ALIGN;
            agent.force.z += f;
            force = Math.abs(f);
        }
        agent.lastForces['Alignment Strength'] = (agent.lastForces['Alignment Strength'] || 0) + force;
    }
    
    applyProximityPIDForAgent(pidInfo) {
        const { controller, anchorId, satelliteId } = pidInfo;
        const satelliteAgent = this.agents.get(satelliteId);
        const anchorAgent = this.agents.get(anchorId);
        const satelliteBody = this.rigidBodyMap.get(satelliteId);
        if (!satelliteAgent || !anchorAgent || !satelliteBody || !satelliteBody.isDynamic()) return;
        
        const anchorNode = this.nodeMap.get(anchorId);
        const satelliteNode = this.nodeMap.get(satelliteId);
        if (!anchorNode || !satelliteNode) return;

        const { drcDims: anchorDims } = this.getEffectiveDrcInfo(anchorNode);
        const { drcDims: satelliteDims } = this.getEffectiveDrcInfo(satelliteNode);
        const anchorRadius = Math.hypot(anchorDims.width, anchorDims.height) / 2 * this.SCALE;
        const satelliteRadius = Math.hypot(satelliteDims.width, satelliteDims.height) / 2 * this.SCALE;
        const idealSeparation = anchorRadius + satelliteRadius + (this.params.componentSpacing / 10);

        const vecToSatellite = { x: satelliteAgent.pos.x - anchorAgent.pos.x, z: satelliteAgent.pos.z - anchorAgent.pos.z };
        const dist = Math.hypot(vecToSatellite.x, vecToSatellite.z);

        if (dist > 1e-6) { vecToSatellite.x /= dist; vecToSatellite.z /= dist; } 
        else { vecToSatellite.x = 1; vecToSatellite.z = 0; }
        
        const targetPoint = { x: anchorAgent.pos.x + vecToSatellite.x * idealSeparation, y: satelliteAgent.pos.y, z: anchorAgent.pos.z + vecToSatellite.z * idealSeparation };
        controller.applyLinearCorrection(satelliteBody, targetPoint, { x: 0, y: 0, z: 0 });
        
        const forceMag = Math.hypot(targetPoint.x - satelliteAgent.pos.x, targetPoint.z - satelliteAgent.pos.z) * this.params.proximityKp;
        satelliteAgent.lastForces['Proximity (PID)'] = (satelliteAgent.lastForces['Proximity (PID)'] || 0) + forceMag;
    }

    applyCircularPIDForAgent(pidInfo) {
        const { controller, rule, componentId } = pidInfo;
        const agent = this.agents.get(componentId);
        const body = this.rigidBodyMap.get(componentId);
        if (!agent || !body || !body.isDynamic()) return;

        const { components, radius, center } = rule;
        const N = components.length;
        const componentIndex = components.indexOf(componentId);
        if (componentIndex === -1) return;

        const rad = radius * this.SCALE;
        const centerX = (center?.[0] || 0) * this.SCALE;
        const centerZ = (center?.[1] || 0) * this.SCALE;

        // --- Positional Correction ---
        const targetAngle = (componentIndex / N) * 2 * Math.PI;
        const targetPoint = {
            x: centerX + rad * Math.cos(targetAngle),
            y: agent.pos.y,
            z: centerZ + rad * Math.sin(targetAngle)
        };
        controller.applyLinearCorrection(body, targetPoint, { x: 0, y: 0, z: 0 });
        const posForceMag = Math.hypot(targetPoint.x - agent.pos.x, targetPoint.z - agent.pos.z) * this.params.proximityKp;
        agent.lastForces['Circular Position'] = (agent.lastForces['Circular Position'] || 0) + posForceMag;

        // --- Rotational Correction ---
        const vecToCenter = { x: centerX - agent.pos.x, z: centerZ - agent.pos.z };
        const targetRotY = Math.atan2(vecToCenter.z, vecToCenter.x) + Math.PI / 2;
        const targetQuat = new this.THREE.Quaternion().setFromEuler(new this.THREE.Euler(0, targetRotY, 0));
        controller.applyAngularCorrection(body, {x: targetQuat.x, y: targetQuat.y, z: targetQuat.z, w: targetQuat.w}, { x: 0, y: 0, z: 0 });

        const currentRotY = new this.THREE.Euler().setFromQuaternion(agent.rot, 'YXZ').y;
        let error = targetRotY - currentRotY;
        while (error < -Math.PI) error += 2 * Math.PI;
        while (error > Math.PI) error -= 2 * Math.PI;
        agent.lastForces['Circular Rotation'] = (agent.lastForces['Circular Rotation'] || 0) + Math.abs(error) * this.params.proximityKp;
    }
    
    applySymmetricalPairPIDForAgent(pidInfo) {
        const { controller, rule, componentId } = pidInfo;
        const agentA = this.agents.get(componentId);
        const bodyA = this.rigidBodyMap.get(componentId);
        if (!agentA || !bodyA || !bodyA.isDynamic()) return;

        const pair = rule.pair;
        const otherId = pair[0] === componentId ? pair[1] : pair[0];
        const agentB = this.agents.get(otherId);
        if (!agentB) return;

        const separation = (rule.separation || 0) * this.SCALE;
        const halfSep = separation / 2.0;

        const comX = (agentA.pos.x + agentB.pos.x) / 2.0;
        const comZ = (agentA.pos.z + agentB.pos.z) / 2.0;

        let targetPoint;
        let targetAngle;
        const isFirstInPair = pair[0] === componentId;

        if (rule.axis === 'vertical') {
            targetPoint = { x: comX - (isFirstInPair ? halfSep : -halfSep), y: agentA.pos.y, z: comZ };
            targetAngle = isFirstInPair ? Math.PI / 2 : -Math.PI / 2; // Pointing towards each other
        } else { // horizontal
            targetPoint = { x: comX, y: agentA.pos.y, z: comZ - (isFirstInPair ? halfSep : -halfSep) };
            targetAngle = isFirstInPair ? 0 : Math.PI; // Pointing towards each other
        }

        // --- Positional Correction ---
        controller.applyLinearCorrection(bodyA, targetPoint, { x: 0, y: 0, z: 0 });
        const posForceMag = Math.hypot(targetPoint.x - agentA.pos.x, targetPoint.z - agentA.pos.z) * this.params.proximityKp;
        agentA.lastForces['Symmetry Position'] = (agentA.lastForces['Symmetry Position'] || 0) + posForceMag;

        // --- Rotational Correction ---
        const targetQuat = new this.THREE.Quaternion().setFromEuler(new this.THREE.Euler(0, targetAngle, 0));
        controller.applyAngularCorrection(bodyA, {x: targetQuat.x, y: targetQuat.y, z: targetQuat.z, w: targetQuat.w}, { x: 0, y: 0, z: 0 });

        const currentRotY = new this.THREE.Euler().setFromQuaternion(agentA.rot, 'YXZ').y;
        let error = targetAngle - currentRotY;
        while (error < -Math.PI) error += 2 * Math.PI;
        while (error > Math.PI) error -= 2 * Math.PI;
        agentA.lastForces['Symmetry Rotation'] = (agentA.lastForces['Symmetry Rotation'] || 0) + Math.abs(error) * this.params.proximityKp;
    }
    
    applyFixedPropertyForAgent(agentId, rule) {
        const { properties } = rule;
        const agent = this.agents.get(agentId);
        if (!agent || !properties || !('rotation' in properties)) return;

        const Kp = this.params.fixedRotationStrength * 100;
        const Kd = Kp / 10;
        const currentAngle = new this.THREE.Euler().setFromQuaternion(agent.rot, 'YXZ').y;
        const targetAngle = properties.rotation * Math.PI / 180;
        
        let error = targetAngle - currentAngle;
        while (error < -Math.PI) error += 2 * Math.PI;
        while (error > Math.PI) error -= 2 * Math.PI;
        
        const torqueY = Kp * error - Kd * agent.angularVel.y;
        
        agent.torque.y += torqueY;
        agent.lastForces['Fixed Rotation'] = (agent.lastForces['Fixed Rotation'] || 0) + Math.abs(torqueY);
    }

    applyAbsolutePositionForAgent(agentId, rule) {
        const K_ABSOLUTE = this.params.absolutePositionStrength;
        const agent = this.agents.get(agentId);
        if (!agent || rule.component !== agentId) return;

        let totalForceMag = 0;
        
        if (rule.x !== undefined && rule.x !== null) {
            const targetX = rule.x * this.SCALE;
            const fx = (targetX - agent.pos.x) * K_ABSOLUTE;
            agent.force.x += fx;
            totalForceMag += Math.abs(fx);
        }

        if (rule.y !== undefined && rule.y !== null) {
            const targetZ = rule.y * this.SCALE; // y from rule maps to z in sim
            const fz = (targetZ - agent.pos.z) * K_ABSOLUTE;
            agent.force.z += fz;
            totalForceMag += Math.abs(fz);
        }
        
        if (totalForceMag > 0) {
            agent.lastForces['Absolute Position Strength'] = (agent.lastForces['Absolute Position Strength'] || 0) + totalForceMag;
        }
    }

    calculateForcesAndTorques() {
        if (this.mode === 'robotics') {
            this.agents.forEach((agent, id) => {
                const body = this.rigidBodyMap.get(id);
                if (!body) return;
                
                agent.lastForces = {};
                
                const aiState = this.agentAIState.get(id);
                if (aiState && aiState.behavior === 'patroller' && body.isDynamic()) {
                    const currentPos = body.translation();
                    const targetPos = aiState.target;
                    const dx = targetPos.x - currentPos.x;
                    const dz = targetPos.z - currentPos.z;
                    const dist = Math.hypot(dx, dz);

                    if (dist < this.PATROLLER_TARGET_RADIUS) {
                        aiState.target = this.getRandomTarget();
                    }

                    const forceMagnitude = this.PATROLLER_SPEED;
                    if (dist > 0.1) {
                        const force = { x: (dx / dist) * forceMagnitude, y: 0, z: (dz / dist) * forceMagnitude };
                        body.addForce(force, true);
                        agent.lastForces['Patrol Force'] = forceMagnitude;

                        const currentVel = body.linvel();
                        if (Math.hypot(currentVel.x, currentVel.z) > 0.1 * this.SCALE) {
                            const targetAngle = Math.atan2(currentVel.x, currentVel.z);
                            const rot = body.rotation();
                            const currentAngle = new this.THREE.Euler().setFromQuaternion({x: rot.x, y: rot.y, z: rot.z, w: rot.w}, 'YXZ').y;
                            
                            let error = targetAngle - currentAngle;
                            while (error < -Math.PI) error += 2 * Math.PI;
                            while (error > Math.PI) error -= 2 * Math.PI;

                            const Kp_rot = 20.0;
                            const Kd_rot = 5.0;
                            const angVel = body.angvel();

                            const torqueY = Kp_rot * error - Kd_rot * angVel.y;
                            body.addTorque({ x: 0, y: torqueY, z: 0 }, true);
                            agent.lastForces['Patrol Torque'] = Math.abs(torqueY);
                        }
                    }
                }
            });
            return;
        }

        // --- PCB Logic ---
        const allPinWorldPos = {};
        this.agents.forEach((_, id) => {
            allPinWorldPos[id] = this.getPinWorldPos(id);
            const agent = this.agents.get(id);
            agent.force = { x: 0, y: 0, z: 0 };
            agent.torque = { x: 0, y: 0, z: 0 };
            agent.lastForces = {};
        });
    
        this.agents.forEach((_, id) => {
            this.applyNetForcesForAgent(id, allPinWorldPos);
            this.applyDistributionForceForAgent(id);
            (this.graph.rules || []).filter(r => r.enabled !== false).forEach(rule => {
                const components = rule.component ? [rule.component] : (rule.components || rule.pair || rule.pairs?.flat() || rule.groups?.flat());
                if (components && components.includes(id)) {
                    switch (rule.type) {
                        case 'SymmetryConstraint': this.applySymmetryForAgent(id, rule); break;
                        case 'AlignmentConstraint': this.applyAlignmentForAgent(id, rule); break;
                        case 'FixedPropertyConstraint': this.applyFixedPropertyForAgent(id, rule); break;
                        case 'AbsolutePositionConstraint': this.applyAbsolutePositionForAgent(id, rule); break;
                    }
                }
            });
        });

        this.pidControllers.forEach(pidInfo => {
            if (pidInfo.type === 'proximity') this.applyProximityPIDForAgent(pidInfo);
            else if (pidInfo.type === 'circular') this.applyCircularPIDForAgent(pidInfo);
            else if (pidInfo.type === 'symmetrical_pair') this.applySymmetricalPairPIDForAgent(pidInfo);
        });
        
        this.agents.forEach((agent, id) => {
            if (id === this.draggedAgentId) return;
            const body = this.rigidBodyMap.get(id);
            if (body && body.isDynamic()) {
                body.resetForces(true); body.resetTorques(true);
                const { force, torque } = agent;
                const MAX_FORCE = 1e6, MAX_TORQUE = 1e5;
                const clampedForce = { x: isFinite(force.x) ? this.clamp(force.x, -MAX_FORCE, MAX_FORCE) : 0, y: 0, z: isFinite(force.z) ? this.clamp(force.z, -MAX_FORCE, MAX_FORCE) : 0 };
                const clampedTorque = { x: 0, y: isFinite(torque.y) ? this.clamp(torque.y, -MAX_TORQUE, MAX_TORQUE) : 0, z: 0 };
                body.addForce(clampedForce, true);
                body.addTorque(clampedTorque, true);
            }
        });
    }
`
```

# bootstrap/sim/agent_simulation.ts
```bootstrap/sim/agent_simulation.ts
//bootstrap/sim/agent_simulation.ts
// This file now only contains the core simulation loop and state management.
// Force and collision logic has been moved to separate files.

export const AgentSimulationCoreString = `
    constructor(graphData, scale, THREE, mode, onUpdateLayout, RAPIER) {
        this.THREE = THREE;
        this.RAPIER = RAPIER;
        this.graph = graphData;
        this.SCALE = scale;
        this.mode = mode;
        this.onUpdateLayout = onUpdateLayout;

        this.nodeMap = new Map();
        this.agents = new Map();
        this.draggedAgentId = null;
        this.draggedBodyOriginalType = null;
        this.step_count = 0;
        this.satelliteToAnchorMap = new Map();
        this.boundaryWalls = []; // To store wall bodies
        this.joints = new Map(); // Maps rule identifier to an array of joint handles
        this.pidControllers = new Map(); // Maps a unique key (e.g., 'prox-U1-C1') to { controller, ruleInfo }

        // --- AI State for Robotics ---
        this.agentAIState = new Map();
        this.PATROLLER_SPEED = 5.0 * this.SCALE;
        this.PATROLLER_TARGET_RADIUS = 1.0 * this.SCALE;

        // --- Rapier World Setup ---
        const gravity = { x: 0.0, y: (mode === 'robotics' ? -9.81 : 0.0) * this.SCALE, z: 0.0 };
        this.world = new this.RAPIER.World(gravity);
        this.eventQueue = new this.RAPIER.EventQueue(true); // Create event queue once
        this.rigidBodyMap = new Map(); // agentId -> RAPIER.RigidBody
        this.handleToAgentIdMap = new Map(); // RAPIER.RigidBody.handle -> agentId

        // --- Simulation Parameters (Heuristics) ---
        this.params = {
            componentSpacing: 200.0, netLengthWeight: 0.03,
            settlingSpeed: 0.99, repulsionRampUpTime: 600, distributionStrength: 0.5,
            boardPadding: 5.0, viaClearance: 0.6,
            proximityKp: 5.0,
            proximityKi: 0.0,
            proximityKd: 1.5,
            symmetryStrength: 10.0, alignmentStrength: 10.0,
            absolutePositionStrength: 10.0,
            fixedRotationStrength: 5.0, symmetryRotationStrength: 1.0, circularRotationStrength: 1.0,
        };
        
        if (this.mode === 'robotics') {
            this.params = { ...this.params, componentSpacing: 10.0, netLengthWeight: 0,
                 distributionStrength: 0, proximityKp: 0,
                symmetryStrength: 0, alignmentStrength: 0,
                absolutePositionStrength: 0, fixedRotationStrength: 0, symmetryRotationStrength: 0, circularRotationStrength: 0,
            };
        }
        
        if (this.graph.board_outline) this.updateBoundaryWalls();


        this.pinDataMap = new Map();
        
        // --- Stability detection ---
        this.totalForceHistory = [];
        this.STABILITY_THRESHOLD = 0.5;
        this.STABILITY_WINDOW = 100;
        this.isStable = false;
    }

    setAuthoritativeState(entities) {
        if (!this.world || this.mode !== 'robotics') return;
        entities.forEach(entity => {
            const body = this.rigidBodyMap.get(entity.id);
            if (body && body.isKinematic()) {
                const pos = {
                    x: entity.x * this.SCALE,
                    y: 1.0 * this.SCALE, // Keep entities on the ground plane
                    z: entity.y * this.SCALE
                };
                const rot = new this.THREE.Quaternion().setFromEuler(new this.THREE.Euler(0, (entity.rotation || 0) * Math.PI / 180, 0));
                
                body.setNextKinematicTranslation(pos);
                body.setNextKinematicRotation(rot);
            }
        });
    }

    getRandomTarget() {
        if (!this.graph.board_outline) return { x: 0, z: 0 };
        const { x, y, width, height } = this.graph.board_outline;
        const randX = (x + Math.random() * width) * this.SCALE;
        const randZ = (y + Math.random() * height) * this.SCALE;
        return { x: randX, z: randZ };
    }

    getEffectiveDrcInfo(node) {
        const { drcDims, drcShape } = this.getDrcInfo(node);
        const viaClearance = this.params.viaClearance || 0;
        
        const effectiveDims = {
            width: drcDims.width + viaClearance,
            height: drcDims.height + viaClearance
        };
        return { drcDims: effectiveDims, drcShape };
    }

    updateGraph(newGraph) {
        if (!newGraph) return;

        const oldOutline = this.graph.board_outline;
        const newOutline = newGraph.board_outline;
        
        this.graph = newGraph; // Update the graph first
    
        if (JSON.stringify(oldOutline) !== JSON.stringify(newOutline)) {
            this.updateBoundaryWalls();
        }
    }
    
    addAgent(node) {
        if (this.agents.has(node.id)) return;

        this.nodeMap.set(node.id, { ...node });
        if (node.pins) this.pinDataMap.set(node.id, new Map(node.pins.map(p => [p.name, p])));

        const boardThickness = 1.6 * this.SCALE;
        const isGameMode = this.mode === 'robotics';
        
        const initialY = isGameMode 
            ? 1.0 * this.SCALE
            : ((node.side === 'bottom') ? -boardThickness / 2 : boardThickness / 2);

        const initialX = (node.x || (Math.random() - 0.5) * 50) * this.SCALE;
        const initialZ = (node.y || (Math.random() - 0.5) * 50) * this.SCALE;
        const initialRot = new this.THREE.Quaternion().setFromEuler(new this.THREE.Euler(0, (node.rotation || 0) * Math.PI / 180, 0));
        
        this.agents.set(node.id, {
            pos: { x: initialX, y: initialY, z: initialZ },
            rot: initialRot,
            angularVel: { x: 0, y: 0, z: 0 }, // Initialize angular velocity
            drcStatus: 'ok',
            lastForces: {},
        });

        // --- Create Rapier Body and Collider ---
        const bodyType = isGameMode ? this.RAPIER.RigidBodyType.KinematicPositionBased : this.RAPIER.RigidBodyType.Dynamic;
        
        const rigidBodyDesc = new this.RAPIER.RigidBodyDesc(bodyType)
            .setTranslation(initialX, initialY, initialZ)
            .setRotation({ x: initialRot.x, y: initialRot.y, z: initialRot.z, w: initialRot.w })
            .enabledTranslations(!isGameMode, true, !isGameMode)
            .enabledRotations(false, true, false)
            .setLinearDamping(isGameMode ? 0.0 : 5.0)
            .setAngularDamping(isGameMode ? 0.0 : 5.0)
            .setCcdEnabled(true);
        
        const body = this.world.createRigidBody(rigidBodyDesc);
        
        const { drcDims, drcShape } = this.getEffectiveDrcInfo(node);
        const colliderWidth = drcDims.width * this.SCALE;
        const colliderHeight = drcDims.height * this.SCALE;
        
        let colliderDesc;
        const colliderThickness = isGameMode ? 1.0 * this.SCALE : 1.0 * this.SCALE;

        if (drcShape === 'circle') {
            const radius = Math.max(colliderWidth, colliderHeight) / 2;
            colliderDesc = this.RAPIER.ColliderDesc.cylinder(colliderThickness / 2, radius);
        } else { // rectangle
            colliderDesc = this.RAPIER.ColliderDesc.cuboid(colliderWidth / 2, colliderThickness / 2, colliderHeight / 2);
        }

        this.world.createCollider(colliderDesc, body);
        this.rigidBodyMap.set(node.id, body);
        this.handleToAgentIdMap.set(body.handle, node.id);

        if (isGameMode && node.behaviorType === 'patroller') {
            this.agentAIState.set(node.id, {
                behavior: 'patroller',
                target: this.getRandomTarget()
            });
        }
        
        this.isStable = false;
        this.step_count = 0;
    }
    
    updateNode(node) {
        if (this.nodeMap.has(node.id)) {
            this.nodeMap.set(node.id, { ...node });
            this.isStable = false;
        }
    }

    updateParams(newParams) {
        if (this.mode === 'robotics') return;

        const oldKp = this.params.proximityKp;
        const oldKd = this.params.proximityKd;

        this.params = { ...this.params, ...newParams };

        const newKp = this.params.proximityKp;
        const newKd = this.params.proximityKd;

        // If PID parameters have changed, rebuild all PID controllers
        if ((oldKp !== newKp || oldKd !== newKd) && this.world.removePidController) {
            const controllersToRebuild = new Map(this.pidControllers);
            
            this.pidControllers.forEach((pidInfo, key) => {
                this.world.removePidController(pidInfo.controller);
            });
            this.pidControllers.clear();

            controllersToRebuild.forEach((pidInfo, key) => {
                const newController = this.world.createPidController(
                    this.params.proximityKp,
                    this.params.proximityKi,
                    this.params.proximityKd,
                    pidInfo.axesMask // Use the stored axes mask
                );
                this.pidControllers.set(key, { ...pidInfo, controller: newController });
            });
        }

        this.isStable = false;
        this.step_count = 0;
    }
    
    updateEdges(newEdges) {
        if (this.graph) { this.graph.edges = newEdges; this.isStable = false; this.totalForceHistory = []; this.step_count = 0; }
    }

    updateRules(newRules) {
        if (!this.graph) return;

        this.graph.rules = newRules;
        this.isStable = false;
        this.totalForceHistory = [];
        this.step_count = 0;

        const activeRules = (newRules || []).filter(rule => rule.enabled !== false);
        const newPidKeys = new Set();
        
        activeRules.forEach((rule, ruleIndex) => {
            // --- PID Controller Management ---
            const linearAxes = this.RAPIER.PidAxesMask.LinX | this.RAPIER.PidAxesMask.LinZ;
            const allAxes = linearAxes | this.RAPIER.PidAxesMask.AngY;

            if (rule.type === 'ProximityConstraint') {
                (rule.groups || []).forEach(group => {
                    if (!Array.isArray(group) || group.length < 2) return;
                    const anchorId = group[0];
                    group.slice(1).forEach(satelliteId => {
                        const key = \`prox-\${anchorId}-\${satelliteId}\`;
                        newPidKeys.add(key);
                        if (!this.pidControllers.has(key)) {
                            const controller = this.world.createPidController(this.params.proximityKp, this.params.proximityKi, this.params.proximityKd, linearAxes);
                            this.pidControllers.set(key, { type: 'proximity', controller, rule, anchorId, satelliteId, axesMask: linearAxes });
                        }
                    });
                });
            } else if (rule.type === 'CircularConstraint') {
                 (rule.components || []).forEach(componentId => {
                    const key = \`circ-\${ruleIndex}-\${componentId}\`;
                    newPidKeys.add(key);
                    if (!this.pidControllers.has(key)) {
                        const controller = this.world.createPidController(this.params.proximityKp, this.params.proximityKi, this.params.proximityKd, allAxes);
                        this.pidControllers.set(key, { type: 'circular', controller, rule, componentId, axesMask: allAxes });
                    }
                });
            } else if (rule.type === 'SymmetricalPairConstraint') {
                const pair = rule.pair || [];
                if (Array.isArray(pair) && pair.length === 2) {
                    pair.forEach(componentId => {
                        const key = \`sym_pair-\${ruleIndex}-\${componentId}\`;
                        newPidKeys.add(key);
                        if (!this.pidControllers.has(key)) {
                             const controller = this.world.createPidController(this.params.proximityKp, this.params.proximityKi, this.params.proximityKd, allAxes);
                             this.pidControllers.set(key, { type: 'symmetrical_pair', controller, rule, componentId, axesMask: allAxes });
                        }
                    });
                }
            }
        });

        // --- Cleanup Stale PIDs ---
        for (const key of this.pidControllers.keys()) {
            if (!newPidKeys.has(key)) {
                const { controller } = this.pidControllers.get(key);
                if (this.world.removePidController) this.world.removePidController(controller);
                this.pidControllers.delete(key);
            }
        }
    }

    updateNodeDimensions(agentId, width, height) {
        const node = this.nodeMap.get(agentId);
        if (node && !node.drc_dimensions) {
            node.svg_drc_dimensions = { width, height };
            node.svg_drc_shape = 'rectangle';
            this.isStable = false;
        }
    }

    getNode(agentId) { return this.nodeMap.get(agentId); }

    dragAgent(agentId, newPosition) {
        this.draggedAgentId = agentId;
        const body = this.rigidBodyMap.get(agentId);
        if (body) {
            if (this.draggedBodyOriginalType === null) {
                this.draggedBodyOriginalType = body.bodyType();
            }
            body.setBodyType(this.RAPIER.RigidBodyType.KinematicPositionBased, true);
            const currentTranslation = body.translation();
            body.setNextKinematicTranslation({ x: newPosition.x, y: currentTranslation.y, z: newPosition.z });
        }
    }

    stopDragAgent() {
        if (this.draggedAgentId) {
            const body = this.rigidBodyMap.get(this.draggedAgentId);
            if (body && this.draggedBodyOriginalType !== null) {
                // Restore to Dynamic. The next step() will set it back to Kinematic if a rule applies.
                body.setBodyType(this.RAPIER.RigidBodyType.Dynamic, true);
            }
        }
        this.draggedAgentId = null;
        this.draggedBodyOriginalType = null;
    }
    
    toggleComponentSide(id) {
        const node = this.nodeMap.get(id);
        if (node) {
            node.side = node.side === 'bottom' ? 'top' : 'bottom';
            this.isStable = false;
            // Immediately update the physical position of the rigid body
            const body = this.rigidBodyMap.get(id);
            if (body) {
                const boardThickness = 1.6 * this.SCALE;
                const targetY = (node.side === 'bottom') ? -boardThickness / 2 : boardThickness / 2;
                const currentPos = body.translation();
                body.setTranslation({ x: currentPos.x, y: targetY, z: currentPos.z }, true);
            }
        }
    }
    
    getDrcInfo(node) {
        if (this.mode === 'robotics' && (node.type === 'wall' || node.type === 'tree' || node.type === 'rough_terrain')) {
            return { drcDims: { width: 1.0, height: 1.0 }, drcShape: 'rectangle' };
        }
        if (node.drc_dimensions) return { drcDims: node.drc_dimensions, drcShape: node.drc_shape || 'rectangle' };
        if (node.svg_drc_dimensions) return { drcDims: node.svg_drc_dimensions, drcShape: node.svg_drc_shape || 'rectangle' };
        return { drcDims: { width: 2.54, height: 2.54 }, drcShape: 'rectangle' };
    }

    updateBoundaryWalls() {
        // Clear any existing walls before creating new ones.
        this.boundaryWalls.forEach(body => this.world.removeRigidBody(body));
        this.boundaryWalls = [];
    
        const outline = this.graph.board_outline;
        if (!outline || !outline.width || !outline.height) {
            return; // No outline defined, so no walls.
        }

        if (this.mode === 'robotics') {
            const groundSize = Math.max(outline.width, outline.height) * this.SCALE * 2;
            const groundBodyDesc = this.RAPIER.RigidBodyDesc.fixed().setTranslation(0, -0.1 * this.SCALE, 0);
            const groundBody = this.world.createRigidBody(groundBodyDesc);
            const groundColliderDesc = this.RAPIER.ColliderDesc.cuboid(groundSize / 2, 0.1 * this.SCALE, groundSize / 2);
            this.world.createCollider(groundColliderDesc, groundBody);
            this.boundaryWalls.push(groundBody);
        }
        
        const wallHeight = 10 * this.SCALE;

        if (outline.shape === 'rectangle') {
            const { x, y, width, height } = outline;
            const wallThickness = 1 * this.SCALE;
            const wallHalfThickness = wallThickness / 2;
        
            const boardMinX = x * this.SCALE;
            const boardMaxX = (x + width) * this.SCALE;
            const boardMinZ = y * this.SCALE;
            const boardMaxZ = (y + height) * this.SCALE;
            
            const wallPositions = [
                { x: (boardMinX + boardMaxX) / 2, z: boardMinZ - wallHalfThickness, hx: (width * this.SCALE + wallThickness) / 2, hz: wallHalfThickness },
                { x: (boardMinX + boardMaxX) / 2, z: boardMaxZ + wallHalfThickness, hx: (width * this.SCALE + wallThickness) / 2, hz: wallHalfThickness },
                { x: boardMinX - wallHalfThickness, z: (boardMinZ + boardMaxZ) / 2, hx: wallHalfThickness, hz: (height * this.SCALE) / 2 },
                { x: boardMaxX + wallHalfThickness, z: (boardMinZ + boardMaxZ) / 2, hx: wallHalfThickness, hz: (height * this.SCALE) / 2 },
            ];
            
            wallPositions.forEach(pos => {
                const wallBodyDesc = this.RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, 0, pos.z);
                const wallBody = this.world.createRigidBody(wallBodyDesc);
                const wallColliderDesc = this.RAPIER.ColliderDesc.cuboid(pos.hx, wallHeight / 2, pos.hz);
                this.world.createCollider(wallColliderDesc, wallBody);
                this.boundaryWalls.push(wallBody);
            });

        } else if (outline.shape === 'circle') {
            const radius = (outline.width / 2) * this.SCALE;
            const centerX = (outline.x + outline.width / 2) * this.SCALE;
            const centerZ = (outline.y + outline.height / 2) * this.SCALE;
            const numSegments = 64; // More segments provide a better circular approximation.

            for (let i = 0; i < numSegments; i++) {
                const angle = (i / numSegments) * 2 * Math.PI;
                
                // Position of the center of the wall segment
                const wallX = centerX + radius * Math.cos(angle);
                const wallZ = centerZ + radius * Math.sin(angle);
                
                const segmentLength = (2 * Math.PI * radius) / numSegments;
                const wallThickness = 1 * this.SCALE;

                const wallBodyDesc = this.RAPIER.RigidBodyDesc.fixed()
                    .setTranslation(wallX, 0, wallZ)
                    .setRotation({ w: Math.cos((angle + Math.PI/2) / 2), x: 0, y: Math.sin((angle + Math.PI/2) / 2), z: 0 });

                const wallBody = this.world.createRigidBody(wallBodyDesc);
                const wallColliderDesc = this.RAPIER.ColliderDesc.cuboid(segmentLength / 2, wallHeight / 2, wallThickness / 2);
                
                this.world.createCollider(wallColliderDesc, wallBody);
                this.boundaryWalls.push(wallBody);
            }
        }
    }

    updateDynamicBoardOutline() {
        if (this.step_count < 100) return;

        if (!this.graph.board_outline || !this.graph.board_outline.autoSize) return;
        if (this.agents.size === 0) return;
        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        this.agents.forEach((agent, id) => {
            const node = this.nodeMap.get(id);
            if (!node) return;
            const body = this.rigidBodyMap.get(id);
            if (!body) return;
            const { drcDims } = this.getDrcInfo(node);
            const corners = this.getRotatedRectCorners({ pos: body.translation(), rot: body.rotation() }, drcDims);
            corners.forEach(corner => {
                minX = Math.min(minX, corner.x); maxX = Math.max(maxX, corner.x);
                minZ = Math.min(minZ, corner.z); maxZ = Math.max(maxZ, corner.z);
            });
        });
        if (minX === Infinity) return;
        const padding = this.params.boardPadding * this.SCALE;
        minX -= padding; maxX += padding; minZ -= padding; maxZ += padding;
        const boardWidth = maxX - minX; const boardHeight = maxZ - minZ;
        let newOutline;
        if (this.graph.board_outline.shape === 'circle') {
            const diameter = Math.max(boardWidth, boardHeight);
            const centerX = minX + boardWidth / 2; const centerZ = minZ + boardHeight / 2;
            newOutline = { ...this.graph.board_outline, width: diameter / this.SCALE, height: diameter / this.SCALE, x: (centerX - diameter / 2) / this.SCALE, y: (centerZ - diameter / 2) / this.SCALE };
        } else {
            newOutline = { ...this.graph.board_outline, width: boardWidth / this.SCALE, height: boardHeight / this.SCALE, x: minX / this.SCALE, y: minZ / this.SCALE };
        }
        const old = this.graph.board_outline;
        if (Math.abs(old.width - newOutline.width) > 0.1 || Math.abs(old.height - newOutline.height) > 0.1) {
            this.onUpdateLayout(prev => ({ ...prev, board_outline: newOutline }));
        }
    }

    step() {
        if (this.agents.size === 0) return;
        this.step_count++;
        if (this.mode !== 'robotics') {
            this.calculateForcesAndTorques();
        }
        this.world.step(this.eventQueue);
        this.updateAgentStateFromPhysics();
        if (this.graph.board_outline?.autoSize) this.updateDynamicBoardOutline();
        this.updateDRCStatus(this.eventQueue);
    }
    
    updateAgentStateFromPhysics() {
        this.agents.forEach((agent, id) => {
            const body = this.rigidBodyMap.get(id);
            if (body) {
                const pos = body.translation(), rot = body.rotation(), angvel = body.angvel();
                agent.pos = { x: pos.x, y: pos.y, z: pos.z };
                agent.rot = { x: rot.x, y: rot.y, z: rot.z, w: rot.w };
                agent.angularVel = { x: angvel.x, y: angvel.y, z: angvel.z };
            }
        });
    }

    getPosition(id) { return this.agents.get(id)?.pos; }
    
    getRotation(id) { 
        const agent = this.agents.get(id);
        const node = this.nodeMap.get(id);
        if (!agent || !node) return new this.THREE.Quaternion();
        
        const baseQuat = new this.THREE.Quaternion(agent.rot.x, agent.rot.y, agent.rot.z, agent.rot.w);

        if (node.side === 'bottom') {
            const flipQuat = new this.THREE.Quaternion().setFromAxisAngle(new this.THREE.Vector3(1, 0, 0), Math.PI);
            baseQuat.multiply(flipQuat);
        }

        return baseQuat;
    }
    
    getFinalPositions() {
        const positions = {};
        this.agents.forEach((agent, id) => {
            const node = this.nodeMap.get(id);
            const body = this.rigidBodyMap.get(id);
            if(!node || !body) return;
            const bodyRot = body.rotation();
            const euler = new this.THREE.Euler().setFromQuaternion(new this.THREE.Quaternion(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w), 'YXZ');
            let finalRotationDegrees = (euler.y * 180 / Math.PI) % 360;
            if(finalRotationDegrees < 0) finalRotationDegrees += 360;

            positions[id] = { 
                x: agent.pos.x / this.SCALE, y: agent.pos.z / this.SCALE, 
                rotation: Math.round(finalRotationDegrees * 100) / 100, side: node.side || 'top' 
            };
        });
        return positions;
    }
    
    cleanup() {
        if (!this.world) {
            return;
        }

        this.rigidBodyMap.forEach(body => {
            if (this.world.getRigidBody(body.handle)) {
                this.world.removeRigidBody(body);
            }
        });

        this.boundaryWalls.forEach(body => {
            if (this.world.getRigidBody(body.handle)) {
                this.world.removeRigidBody(body);
            }
        });

        if (this.world.removePidController) {
            this.pidControllers.forEach(({ controller }) => {
                this.world.removePidController(controller);
            });
        }
        this.pidControllers.clear();

        this.rigidBodyMap.clear();
        this.handleToAgentIdMap.clear();
        this.boundaryWalls = [];
        this.agents.clear();

        if (this.eventQueue) {
            this.eventQueue.free();
            this.eventQueue = null;
        }
        
        this.world.free();
        this.world = null;
    }
`
```

# bootstrap/sim/supply_chain_script.ts
```bootstrap/sim/supply_chain_script.ts
// bootstrap/sim/supply_chain_script.ts

export const SUPPLY_CHAIN_SCRIPT = `
import argparse
import json
import sys
import time
import random

# --- Configuration ---
# Simulation parameters are now held internally, removing the need for an external file.
SIMULATED_STOCK_PARAMS = {
    "ADS131M08": {
        "description": "8-Channel ADC",
        "find_chance": 0.6,
        "max_stock": 50,
        "lead_time_days": 14
    },
    "LP5907QMFX-3.3Q1": {
        "description": "3.3V LDO Voltage Regulator",
        "find_chance": 0.9,
        "max_stock": 2500,
        "lead_time_days": 0
    },
    "ECS-2520MV": {
        "description": "8.192MHz Oscillator",
        "find_chance": 0.7,
        "max_stock": 300,
        "lead_time_days": 7
    },
    "CAP_SMD_0603": {
        "description": "Generic 0603 Capacitor",
        "find_chance": 0.98,
        "max_stock": 10000,
        "lead_time_days": 0
    },
    "POGO_PIN_SMD": {
        "description": "SMD Pogo Pin",
        "find_chance": 0.85,
        "max_stock": 2000,
        "lead_time_days": 0
    },
    "XIAO_HEADER_SMD": {
        "description": "1x7 2.54mm SMD Pin Header",
        "find_chance": 0.95,
        "max_stock": 500,
        "lead_time_days": 0
    }
}

def main():
    parser = argparse.ArgumentParser(description="Simulates a query to a supplier stock database.")
    parser.add_argument('--part-number', required=True, help='The part number to query.')
    args = parser.parse_args()

    # Simulate network latency and processing time
    time.sleep(random.uniform(0.5, 2.0))

    part_params = SIMULATED_STOCK_PARAMS.get(args.part_number)

    if part_params and random.random() < part_params.get("find_chance", 0.75):
        # Simulate variable stock levels
        stock_level = random.randint(1, part_params.get("max_stock", 1000))
        result = {
            "part_number": args.part_number,
            "in_stock": stock_level,
            "supplier": random.choice(["Digi-Key (Sim)", "Mouser (Sim)", "LCSC (Sim)"]),
            "lead_time_days": part_params.get("lead_time_days", 0)
        }
    else:
        result = {
            "part_number": args.part_number,
            "in_stock": 0,
            "supplier": None,
            "lead_time_days": None
        }
    
    # The tool's output must be printed to stdout
    print(json.dumps(result))

if __name__ == "__main__":
    main()
`;
```

# bootstrap/sim/graphics.ts
```bootstrap/sim/graphics.ts
// bootstrap/sim/graphics.ts

export const GraphicsClassString = `
class ThirdPersonCamera {
    constructor(camera, domElement, THREE) {
        this.camera = camera;
        this.domElement = domElement;
        this.THREE = THREE;
        this.target = null;

        this.currentPosition = new this.THREE.Vector3();
        this.currentLookat = new this.THREE.Vector3();

        this.isMouseDown = false;
        this.phi = Math.PI / 3.5; // Vertical angle
        this.theta = 0; // Horizontal angle
        this.distance = 50; // Camera distance from target
        
        // Add gamepad state
        this.gamepadIndex = null;
        this.boundGamepadConnected = this.onGamepadConnected.bind(this);
        this.boundGamepadDisconnected = this.onGamepadDisconnected.bind(this);
        
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.onWheel = this.onWheel.bind(this);

        this.domElement.addEventListener('pointerdown', this.onPointerDown);
        this.domElement.addEventListener('wheel', this.onWheel, { passive: false });
        window.addEventListener('gamepadconnected', this.boundGamepadConnected);
        window.addEventListener('gamepaddisconnected', this.boundGamepadDisconnected);
        this.findGamepad(); // Check if a gamepad is already connected
    }
    
    findGamepad() {
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                this.gamepadIndex = i;
                break;
            }
        }
    }
    
    onGamepadConnected(event) {
        if (this.gamepadIndex === null) {
            this.gamepadIndex = event.gamepad.index;
        }
    }

    onGamepadDisconnected(event) {
        if (this.gamepadIndex === event.gamepad.index) {
            this.gamepadIndex = null;
        }
    }

    onPointerDown(event) {
        if (event.button !== 0) return;
        this.isMouseDown = true;
        this.domElement.addEventListener('pointermove', this.onPointerMove);
        this.domElement.addEventListener('pointerup', this.onPointerUp);
    }
    
    onPointerMove(event) {
        if (!this.isMouseDown) return;
        this.theta -= event.movementX * 0.005;
        this.phi -= event.movementY * 0.005;
        this.phi = Math.max(0.1, Math.min(Math.PI / 2.1, this.phi)); // Clamp vertical angle
    }
    
    onPointerUp(event) {
        this.isMouseDown = false;
        this.domElement.removeEventListener('pointermove', this.onPointerMove);
        this.domElement.removeEventListener('pointerup', this.onPointerUp);
    }

    onWheel(event) {
        event.preventDefault();
        this.distance += event.deltaY * 0.05;
        this.distance = Math.max(10, Math.min(200, this.distance)); // Clamp distance
    }

    update(targetMesh) {
        // Add gamepad input handling at the top
        if (this.gamepadIndex !== null) {
            const gp = navigator.getGamepads()[this.gamepadIndex];
            if (gp) {
                const rightStickX = gp.axes[2] || 0;
                const rightStickY = gp.axes[3] || 0;
                const deadzone = 0.15;

                if (Math.abs(rightStickX) > deadzone) {
                    this.theta -= rightStickX * 0.03;
                }
                if (Math.abs(rightStickY) > deadzone) {
                    this.phi -= rightStickY * 0.03;
                    this.phi = Math.max(0.1, Math.min(Math.PI / 2.1, this.phi));
                }
            }
        }

        if (!targetMesh) {
            this.camera.lookAt(0, 0, 0);
            return;
        }
        this.target = targetMesh;
        const targetPosition = new this.THREE.Vector3();
        this.target.getWorldPosition(targetPosition);
        targetPosition.y += 5; // Look slightly above the target's origin

        const offset = new this.THREE.Vector3();
        offset.x = this.distance * Math.sin(this.phi) * Math.sin(this.theta);
        offset.y = this.distance * Math.cos(this.phi);
        offset.z = this.distance * Math.sin(this.phi) * Math.cos(this.theta);

        const cameraPosition = targetPosition.clone().add(offset);
        
        this.currentPosition.lerp(cameraPosition, 0.1);
        this.camera.position.copy(this.currentPosition);
        
        this.currentLookat.lerp(targetPosition, 0.1);
        this.camera.lookAt(this.currentLookat);
    }

    cleanup() {
        this.domElement.removeEventListener('pointerdown', this.onPointerDown);
        this.domElement.removeEventListener('wheel', this.onWheel);
        this.domElement.removeEventListener('pointermove', this.onPointerMove);
        this.domElement.removeEventListener('pointerup', this.onPointerUp);
        
        // Cleanup gamepad listeners
        window.removeEventListener('gamepadconnected', this.boundGamepadConnected);
        window.removeEventListener('gamepaddisconnected', this.boundGamepadDisconnected);
    }
}


class Graphics {
    constructor(mountNode, THREE, OrbitControls, GLTFLoader, SVGLoader, boardOutline, scale, isServerConnected, mode, playerId = null) {
        this.THREE = THREE;
        this.GLTFLoader = GLTFLoader;
        this.SVGLoader = SVGLoader;
        this.loader = new this.GLTFLoader();
        this.svgLoader = new this.SVGLoader();
        this.isServerConnected = isServerConnected;

        this.scene = new this.THREE.Scene();
        this.scene.background = new this.THREE.Color(0x111827); // bg-gray-900
        this.camera = new this.THREE.PerspectiveCamera(75, mountNode.clientWidth / mountNode.clientHeight, 0.1, 5000);
        this.camera.position.set(0, 100, 150);
        this.renderer = new this.THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(mountNode.clientWidth, mountNode.clientHeight);
        mountNode.appendChild(this.renderer.domElement);
        
        this.mode = mode;
        this.playerId = playerId;
        if (this.mode === 'robotics') {
            this.controls = new ThirdPersonCamera(this.camera, this.renderer.domElement, this.THREE);
        } else {
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
        }

        this.scene.add(new this.THREE.AmbientLight(0xffffff, 1.5));
        const dirLight = new this.THREE.DirectionalLight(0xffffff, 3.0);
        dirLight.position.set(50, 100, 75);
        this.scene.add(dirLight);

        this.icMaterial = new this.THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.1, roughness: 0.6 });
        this.smdMaterial = new this.THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.1, roughness: 0.8 });
        this.connectorMaterial = new this.THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.3 });
        this.robotMaterial = new this.THREE.MeshStandardMaterial({ color: 0x3b82f6 });
        this.envMaterial = new this.THREE.MeshStandardMaterial({ color: 0x6b7280 });
        this.highlightMaterial = new this.THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.5 });
        this.selectMaterial = new this.THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 });
        
        this.materials = {
            footprint: {
                top: new this.THREE.MeshBasicMaterial({ color: 0xff0000, side: this.THREE.DoubleSide, transparent: true, opacity: 0.5 }),
                bottom: new this.THREE.MeshBasicMaterial({ color: 0x0000ff, side: this.THREE.DoubleSide, transparent: true, opacity: 0.5 }),
            },
            courtyard: {
                top: {
                    fill: new this.THREE.MeshBasicMaterial({ color: 0xffc0cb, transparent: true, opacity: 0.1, side: this.THREE.DoubleSide }),
                    line: new this.THREE.LineBasicMaterial({ color: 0xffc0cb, linewidth: 2 })
                },
                bottom: {
                    fill: new this.THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.1, side: this.THREE.DoubleSide }),
                    line: new this.THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 })
                }
            }
        };

        this.meshes = new Map();
        this.simulation = null;
        this.boardY = 0;
        this.visibility = { placeholders: true, courtyards: true, svg: true, glb: true, nets: true };
        this.boardMesh = null;
        
        this.netLinesGroup = new this.THREE.Group();
        this.scene.add(this.netLinesGroup);
        this.netLines = new Map();
        this.netLineMaterial = new this.THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
        this.gndLineMaterial = new this.THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
        this.boardOutlineData = null;

        if (boardOutline) this.updateBoardMesh(boardOutline, scale);
        
        this.raycaster = new this.THREE.Raycaster();
        this.mouse = new this.THREE.Vector2();
        this.plane = new this.THREE.Plane(new this.THREE.Vector3(0, 1, 0), 0);
        this.draggedObject = null;
        this.hoveredObject = null;
        
        this.boundPointerDown = this.onPointerDown.bind(this);
        this.boundPointerMove = this.onPointerMove.bind(this);
        this.boundPointerUp = this.onPointerUp.bind(this);
        this.renderer.domElement.addEventListener('pointerdown', this.boundPointerDown);
        this.renderer.domElement.addEventListener('pointermove', this.boundPointerMove);
        this.renderer.domElement.addEventListener('pointerup', this.boundPointerUp);

        this.boundDoubleClick = this.handleDoubleClick.bind(this);
        this.renderer.domElement.addEventListener('dblclick', this.boundDoubleClick);
        
        // Use a ResizeObserver to handle canvas resizing dynamically.
        this.resizeObserver = new ResizeObserver(() => {
            this.onWindowResize();
        });
        this.resizeObserver.observe(mountNode);
    }
    
    getClosestPointOnBoard(worldPos) {
        if (!this.boardOutlineData) return worldPos;

        const { x, y, width, height, shape } = this.boardOutlineData;
        const scale = this.simulation.SCALE;

        const boardMinX = x * scale;
        const boardMaxX = (x + width) * scale;
        const boardMinZ = y * scale;
        const boardMaxZ = (y + height) * scale;
        const boardY = this.boardY;

        if (shape === 'circle') {
            const centerX = (boardMinX + boardMaxX) / 2;
            const centerZ = (boardMinZ + boardMaxZ) / 2;
            const radius = (boardMaxX - boardMinX) / 2;
            
            const vecToCenter = new this.THREE.Vector3(worldPos.x - centerX, 0, worldPos.z - centerZ);
            if (vecToCenter.lengthSq() < 1e-9) { // If point is at the center
                 return new this.THREE.Vector3(centerX + radius, boardY, centerZ);
            }
            vecToCenter.normalize().multiplyScalar(radius);
            
            return new this.THREE.Vector3(centerX + vecToCenter.x, worldPos.y, centerZ + vecToCenter.z);

        } else { // rectangle
            const closestX = Math.max(boardMinX, Math.min(worldPos.x, boardMaxX));
            const closestZ = Math.max(boardMinZ, Math.min(worldPos.z, boardMaxZ));
            
            const distToMinX = Math.abs(worldPos.x - boardMinX);
            const distToMaxX = Math.abs(worldPos.x - boardMaxX);
            const distToMinZ = Math.abs(worldPos.z - boardMinZ);
            const distToMaxZ = Math.abs(worldPos.z - boardMaxZ);

            const minDist = Math.min(distToMinX, distToMaxX, distToMinZ, distToMaxZ);

            if (minDist === distToMinX) return new this.THREE.Vector3(boardMinX, worldPos.y, closestZ);
            if (minDist === distToMaxX) return new this.THREE.Vector3(boardMaxX, worldPos.y, closestZ);
            if (minDist === distToMinZ) return new this.THREE.Vector3(closestX, worldPos.y, boardMinZ);
            return new this.THREE.Vector3(closestX, worldPos.y, maxZ);
        }
    }
    
    updateNetVisuals(graph) {
        if (!graph || !this.netLinesGroup) return;

        this.netLinesGroup.clear();
        this.netLines.clear();

        const hasGndPour = graph.copper_pours?.some(p => p.net && p.net.toLowerCase() === 'gnd');
        
        // If a ground pour exists, create individual lines for each GND pin.
        if (hasGndPour) {
            const gndPins = new Set();
            (graph.edges || []).forEach(edge => {
                if (edge.label && edge.label.toLowerCase() === 'gnd') {
                    gndPins.add(edge.source);
                    gndPins.add(edge.target);
                }
            });

            gndPins.forEach(pinId => {
                const key = \`gnd_pour-\\\${pinId}\`;
                const geometry = new this.THREE.BufferGeometry().setFromPoints([new this.THREE.Vector3(), new this.THREE.Vector3()]);
                const line = new this.THREE.Line(geometry, this.gndLineMaterial);
                line.userData = { type: 'gnd_pour', pin: pinId };
                this.netLines.set(key, line);
                this.netLinesGroup.add(line);
            });
        }

        // Process all edges. If a GND pour exists, GND edges are skipped here.
        // Otherwise, GND edges are created just like any other net.
        (graph.edges || []).forEach(edge => {
            const isGnd = edge.label && edge.label.toLowerCase() === 'gnd';
            if (isGnd && hasGndPour) {
                return; // Handled by the 'gnd_pour' lines above
            }
            
            const key = [edge.source, edge.target].sort().join('-');
            if (!this.netLines.has(key)) {
                const geometry = new this.THREE.BufferGeometry().setFromPoints([new this.THREE.Vector3(), new this.THREE.Vector3()]);
                const material = isGnd ? this.gndLineMaterial : this.netLineMaterial;
                const line = new this.THREE.Line(geometry, material);
                line.userData = { type: 'net', source: edge.source, target: edge.target };
                this.netLines.set(key, line);
                this.netLinesGroup.add(line);
            }
        });
    }

    updateConnectionStatus(isConnected) {
        this.isServerConnected = isConnected;
    }

    updateVisibility(newVisibility) {
        this.visibility = newVisibility;
        if (this.netLinesGroup) {
            this.netLinesGroup.visible = this.visibility.nets;
        }
    }

    updateMouse(event) {
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    onPointerDown(event) {
        if (event.button !== 0 || !this.simulation || this.mode === 'robotics') return; // Disable dragging in game mode
        this.updateMouse(event);
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const allMeshes = Array.from(this.meshes.values()).flatMap(m => [m.placeholder, m.glb, m.footprint]).filter(Boolean);
        const intersects = this.raycaster.intersectObjects(allMeshes, true);

        if (intersects.length > 0) {
            this.draggedObject = this.findRootMesh(intersects[0].object);
            this.controls.enabled = false;
            this.plane.set(new this.THREE.Vector3(0, 1, 0), -this.draggedObject.position.y);
        }
    }
    
    findRootMesh(object) {
        let current = object;
        while (current.parent && current.parent !== this.scene && current.userData.agentId === undefined) {
            current = current.parent;
        }
        return current;
    }

    onPointerMove(event) {
        this.updateMouse(event);

        if (this.draggedObject && this.simulation) {
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersection = new this.THREE.Vector3();
            if (this.raycaster.ray.intersectPlane(this.plane, intersection)) {
                const agentId = this.draggedObject.userData.agentId;
                 if (agentId) {
                    const meshEntry = this.meshes.get(agentId);
                    if (meshEntry) {
                        // Directly update X and Z for all visual meshes. Y is handled by render loop.
                        if (meshEntry.placeholder) {
                            meshEntry.placeholder.position.x = intersection.x;
                            meshEntry.placeholder.position.z = intersection.z;
                        }
                        if (meshEntry.glb) {
                            meshEntry.glb.position.x = intersection.x;
                            meshEntry.glb.position.z = intersection.z;
                        }
                        if (meshEntry.courtyard) {
                            meshEntry.courtyard.position.x = intersection.x;
                            meshEntry.courtyard.position.z = intersection.z;
                        }
                        if (meshEntry.footprint) {
                            meshEntry.footprint.position.x = intersection.x;
                            meshEntry.footprint.position.z = intersection.z;
                        }
                    }
                    this.simulation.dragAgent(agentId, intersection);
                }
            }
        } else {
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const allMeshes = Array.from(this.meshes.values()).flatMap(m => [m.placeholder, m.glb, m.footprint]).filter(Boolean);
            const intersects = this.raycaster.intersectObjects(allMeshes, true);
            const firstHitRoot = intersects.length > 0 ? this.findRootMesh(intersects[0].object) : null;
            
            const newHoverId = firstHitRoot ? firstHitRoot.userData.agentId : null;
            const oldHoverId = this.hoveredObject ? this.hoveredObject.userData.agentId : null;

            if (oldHoverId !== newHoverId) {
                if (oldHoverId) this.highlightMesh(oldHoverId, false);
                this.hoveredObject = firstHitRoot;
                if (newHoverId) this.highlightMesh(newHoverId, true);
            }
        }
    }

    onPointerUp(event) {
        if (this.mode !== 'robotics') this.controls.enabled = true;
        if (this.draggedObject && this.simulation) {
            this.simulation.stopDragAgent();
            this.draggedObject = null;
        }
    }
    
    handleDoubleClick(event) {
        if (!this.simulation || this.mode === 'robotics') return;
        this.updateMouse(event);
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const allMeshes = Array.from(this.meshes.values()).flatMap(m => [m.placeholder, m.glb, m.footprint]).filter(Boolean);
        const intersects = this.raycaster.intersectObjects(allMeshes, true);

        if (intersects.length > 0) {
            const clickedObject = this.findRootMesh(intersects[0].object);
            if (clickedObject.userData.agentId) {
                this.simulation.toggleComponentSide(clickedObject.userData.agentId);
            }
        }
    }

    updateBoardMesh(outline, scale) {
        this.boardOutlineData = outline;
        if (this.boardMesh) {
            this.scene.remove(this.boardMesh);
            this.boardMesh.geometry.dispose();
            if (this.boardMesh.material.dispose) this.boardMesh.material.dispose();
            this.boardMesh = null;
        }

        if (!outline || !outline.width || !outline.height) {
            return;
        }

        const boardMaterial = new this.THREE.MeshStandardMaterial({ color: 0x004d00, metalness: 0.2, roughness: 0.8, side: this.THREE.DoubleSide });
        const boardHeight = this.mode === 'pcb' ? 1.6 * scale : 0.2 * scale;
        this.boardY = this.mode === 'pcb' ? boardHeight / 2 : 0;
        let boardGeom;
        
        const width = outline.width * scale;
        const depth = outline.height * scale;

        if (outline.shape === 'circle') {
            const radius = (outline.width / 2) * scale;
            boardGeom = new this.THREE.CylinderGeometry(radius, radius, boardHeight, 64);
        } else {
            boardGeom = new this.THREE.BoxGeometry(width, boardHeight, depth);
        }
        this.boardMesh = new this.THREE.Mesh(boardGeom, boardMaterial);
        const centerX = (outline.x + outline.width / 2) * scale;
        const centerZ = (outline.y + outline.height / 2) * scale;
        this.boardMesh.position.set(centerX, this.mode === 'pcb' ? 0 : -boardHeight/2, centerZ);
        this.scene.add(this.boardMesh);
    }

    onWindowResize() {
        const mountNode = this.renderer.domElement.parentElement;
        if(!mountNode) return;
        this.camera.aspect = mountNode.clientWidth / mountNode.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(mountNode.clientWidth, mountNode.clientHeight);
    }
    
    setSimulation(simulation) { this.simulation = simulation; }

    createPlaceholderMesh(node, mode, scale) {
        let geom, mat, geomHeight;
         if (mode === 'pcb') {
            const { placeholder_dimensions, placeholder_shape, footprint, side } = node;
            const isBottom = side === 'bottom';
            
            const visDims = placeholder_dimensions || { width: 2.54, height: 2.54 };
            const visShape = placeholder_shape || 'rectangle';

            const width = visDims.width * scale;
            const depth = visDims.height * scale;

            // Determine height and material based on footprint heuristics
            if (footprint && footprint.toLowerCase().includes('pogo_pin')) {
                geomHeight = 10 * scale;
                mat = this.connectorMaterial.clone();
            } else if (footprint && (footprint.includes('LQFP') || node.id.startsWith('U'))) {
                geomHeight = 2 * scale;
                mat = this.icMaterial.clone();
            } else if (footprint && footprint.includes('PinHeader')) {
                geomHeight = 6 * scale;
                mat = new this.THREE.MeshStandardMaterial({ color: 0x111111 });
            } else {
                geomHeight = 1 * scale;
                mat = this.smdMaterial.clone();
            }
            
            if (visShape === 'circle') {
                const radius = width / 2;
                geom = new this.THREE.CylinderGeometry(radius, radius, geomHeight, 32);
            } else { // rectangle (default)
                geom = new this.THREE.BoxGeometry(width, geomHeight, depth);
            }
            
            geom.translate(0, geomHeight / 2, 0);

        } else { // robotics
             const agentSize = scale;
             if (node.type === 'robot') {
                 const agentGeom = new this.THREE.ConeGeometry(agentSize/2, agentSize, 8);
                 geom = agentGeom;
                 mat = this.robotMaterial.clone();
             } else {
                geom = new this.THREE.BoxGeometry(agentSize, agentSize, agentSize);
                mat = this.envMaterial.clone();
             }
             geom.translate(0, agentSize / 2, 0);
        }
        const mesh = new this.THREE.Mesh(geom, mat);
        if(node.type === 'robot') mesh.rotation.x = Math.PI / 2;
        mesh.userData.originalMaterial = mesh.material;
        return mesh;
    }

    addMesh(id, node, mode, scale) {
        const placeholder = this.createPlaceholderMesh(node, mode, scale);
        placeholder.userData.agentId = id;
        this.scene.add(placeholder);

        const meshEntry = { placeholder: placeholder, glb: null, footprint: null, courtyard: null };
        this.meshes.set(id, meshEntry);

        if (mode === 'pcb' && node.drc_dimensions) {
            const isBottom = node.side === 'bottom';
            const courtyardMaterials = this.materials.courtyard[isBottom ? 'bottom' : 'top'];
            const { drc_dimensions, drc_shape } = node;
            const width = drc_dimensions.width * scale;
            const depth = drc_dimensions.height * scale;
            const courtyardHeight = 0.1 * scale;
            let courtyardGeom;

            if (drc_shape === 'circle') {
                const radius = width / 2;
                courtyardGeom = new this.THREE.CylinderGeometry(radius, radius, courtyardHeight, 32);
            } else { // rectangle
                courtyardGeom = new this.THREE.BoxGeometry(width, courtyardHeight, depth);
            }
            
            const fillMesh = new this.THREE.Mesh(courtyardGeom, courtyardMaterials.fill);
            const edgesGeom = new this.THREE.EdgesGeometry(courtyardGeom);
            const lineMesh = new this.THREE.LineSegments(edgesGeom, courtyardMaterials.line);
            const courtyardGroup = new this.THREE.Group();
            courtyardGroup.add(fillMesh);
            courtyardGroup.add(lineMesh);
            
            courtyardGroup.userData.agentId = id;
            this.scene.add(courtyardGroup);
            meshEntry.courtyard = courtyardGroup;
        }

        if (mode === 'pcb' && node.svgPath) {
            const isBottom = node.side === 'bottom';
            const footprintMaterial = this.materials.footprint[isBottom ? 'bottom' : 'top'];

            const loadSvgFromText = (svgText) => {
                const data = this.svgLoader.parse(svgText);
                const group = new this.THREE.Group();
                group.userData.agentId = id;

                data.paths.forEach(path => {
                    const shapes = this.SVGLoader.createShapes(path);
                    shapes.forEach(shape => {
                        const geometry = new this.THREE.ShapeGeometry(shape);
                        const mesh = new this.THREE.Mesh(geometry, footprintMaterial);
                        group.add(mesh);
                    });
                });
                
                const svgBbox = new this.THREE.Box3().setFromObject(group);
                const svgSize = new this.THREE.Vector3();
                svgBbox.getSize(svgSize);

                if (this.simulation && (svgSize.x > 0 || svgSize.y > 0)) {
                    this.simulation.updateNodeDimensions(id, svgSize.x, svgSize.y);
                }

                const box = new this.THREE.Box3().setFromObject(group);
                const center = new this.THREE.Vector3();
                box.getCenter(center);
                
                group.traverse(child => {
                    if (child.isMesh && child.geometry) {
                        child.geometry.translate(-center.x, -center.y, -center.z);
                    }
                });
                
                group.scale.multiplyScalar(scale);

                meshEntry.footprint = group;
                this.scene.add(group);
            };

            const attemptLoadSvg = (url) => {
                if (window.cacheService) {
                    window.cacheService.getAssetBlob(url).then(async (blob) => {
                        if (blob) {
                            loadSvgFromText(await blob.text());
                        } else {
                            fetch(url)
                                .then(res => {
                                    if (res.ok) return res.text();
                                    return Promise.reject(new Error(\`HTTP \\\${res.status} for \\\${url}\`));
                                })
                                .then(svgText => {
                                    if (svgText) {
                                        window.cacheService.setAssetBlob(url, new Blob([svgText], {type: 'image/svg+xml'}));
                                        loadSvgFromText(svgText);
                                    }
                                })
                                .catch(err => {
                                    console.warn(\`[SVG LOAD FAILED] Could not load SVG from '\\\${url}'. Error: \${err.message}\`);
                                });
                        }
                    });
                }
            };
            
            const initialSvgUrl = (this.isServerConnected && !node.svgPath.startsWith('http'))
                ? 'http://localhost:3001/' + node.svgPath
                : node.svgPath;
            
            attemptLoadSvg(initialSvgUrl);
        }
        
        const assetPath = (mode === 'pcb' && node.glbPath) ? node.glbPath :
                          (mode === 'robotics' && node.asset_glb) ? node.asset_glb : null;

        if (assetPath) {
            const loadGltfFromBlob = (blob) => {
                const url = URL.createObjectURL(blob);
                this.loader.load(url, (gltf) => {
                    if (!gltf || !gltf.scene) {
                        console.error(\`[GLB] GLTF object for ID \\\${id} loaded, but it has no scene.\`);
                        URL.revokeObjectURL(url);
                        return;
                    }
                    const originalScene = gltf.scene;
                    
                    let modelRoot;

                    if (mode === 'pcb') {
                        const componentNode = originalScene.getObjectByName('REF**');
                        if (!componentNode) {
                            console.warn(\`[GLB] KiCad mode: Could not find component node 'REF**' in GLB for ID: \\\${id}. The 3D model might be missing. Proceeding with placeholder.\`);
                            URL.revokeObjectURL(url);
                            return;
                        }
                        modelRoot = new this.THREE.Group();
                        modelRoot.add(componentNode);
                    } else {
                        modelRoot = originalScene.clone();
                    }

                    modelRoot.userData.agentId = id;
                    
                    if (mode === 'pcb') {
                        const componentNodeForTransform = modelRoot.children[0];
                        const transforms = node.assetTransforms?.glb || {};
                        const customOffset = transforms.offset || [0, 0, 0];
                        
                        if (transforms.rotation) {
                            const rot = transforms.rotation; // degrees
                            componentNodeForTransform.rotation.set(
                                rot[0] * this.THREE.MathUtils.DEG2RAD,
                                rot[1] * this.THREE.MathUtils.DEG2RAD,
                                rot[2] * this.THREE.MathUtils.DEG2RAD
                            );
                        }

                        componentNodeForTransform.position.set(customOffset[0], customOffset[1], customOffset[2]);
                        const glbScale = 1000 * scale;
                        modelRoot.scale.set(glbScale, glbScale, glbScale);

                    } else { // robotics
                        const box = new this.THREE.Box3().setFromObject(modelRoot);
                        const size = box.getSize(new this.THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const desiredSize = scale * (node.type === 'robot' ? 1.5 : 1.0);
                        const scaleFactor = maxDim > 0 ? desiredSize / maxDim : 1.0;
                        modelRoot.scale.set(scaleFactor, scaleFactor, scaleFactor);
                        
                        const newBox = new this.THREE.Box3().setFromObject(modelRoot);
                        const center = newBox.getCenter(new this.THREE.Vector3());
                        modelRoot.position.sub(center).sub(new this.THREE.Vector3(0, newBox.min.y, 0));
                    }


                    if (meshEntry.placeholder) {
                        meshEntry.placeholder.visible = false;
                    }
                    
                    meshEntry.glb = modelRoot;
                    this.scene.add(modelRoot);
                    
                    URL.revokeObjectURL(url);
                }, undefined, (error) => console.error(\`[GLB] Error loading model from blob for \\\${id}:\`, error));
            };

            const attemptLoadGlb = (url) => {
                if (window.cacheService) {
                    window.cacheService.getAssetBlob(url).then(async (blob) => {
                        if (blob) {
                            loadGltfFromBlob(blob);
                        } else {
                            fetch(url)
                                .then(res => {
                                    if (res.ok) return res.blob();
                                    return Promise.reject(new Error(\`HTTP \\\${res.status} for \\\${url}\`));
                                })
                                .then(blob => {
                                    if (blob) {
                                        window.cacheService.setAssetBlob(url, blob);
                                        loadGltfFromBlob(blob);
                                    }
                                })
                                .catch(err => {
                                    console.warn(\`[GLB LOAD FAILED] Could not load model from '\\\${url}'. Using placeholder. Error: \${err.message}\`);
                                });
                        }
                    });
                }
            };
            
            const initialGlbUrl = (this.isServerConnected && !assetPath.startsWith('http'))
                ? 'http://localhost:3001/' + assetPath
                : assetPath;
            
            attemptLoadGlb(initialGlbUrl);
        }
    }

    highlightMesh(agentId, isHovering) {
        if (!agentId) return;
        const meshEntry = this.meshes.get(agentId);
        if (!meshEntry || meshEntry.placeholder.userData.isSelected) return;

        const objectToHighlight = meshEntry.glb || meshEntry.placeholder;
        if (!objectToHighlight) return;

        objectToHighlight.traverse(child => {
            if (child.isMesh) {
                if (isHovering) {
                    if (!child.userData.originalMaterial) {
                        child.userData.originalMaterial = child.material;
                    }
                    child.material = this.highlightMaterial;
                } else {
                    if (child.userData.originalMaterial) {
                        child.material = child.userData.originalMaterial;
                    } else {
                        // Fallback to the root placeholder's material
                        child.material = meshEntry.placeholder.userData.originalMaterial;
                    }
                }
            }
        });
    }

    selectMesh(agentId, isSelected) {
        const meshEntry = this.meshes.get(agentId);
        if (!meshEntry) return;

        // Store selection state on the placeholder, which is always present.
        meshEntry.placeholder.userData.isSelected = isSelected;
        
        const objectToUpdate = meshEntry.glb || meshEntry.placeholder;
        if (!objectToUpdate) return;
        
        // If we are de-selecting, revert materials by calling highlight(false).
        if (!isSelected) {
            this.highlightMesh(agentId, false);
            return;
        }

        // Apply selection material to all children.
        objectToUpdate.traverse(child => {
            if (child.isMesh) {
                // Store original material if it hasn't been stored yet.
                if (!child.userData.originalMaterial) {
                    child.userData.originalMaterial = child.material;
                }
                child.material = this.selectMaterial;
            }
        });
    }
    
    focusOn(id) {
        if (!this.simulation) return;
        const pos = this.simulation.getPosition(id);
        if (pos) this.controls.target.set(pos.x, pos.y, pos.z);
    }

    render() {
        if (!this.simulation) return;

        if (this.mode === 'robotics' && this.playerId) {
            const playerMesh = this.meshes.get(this.playerId)?.glb || this.meshes.get(this.playerId)?.placeholder;
            this.controls.update(playerMesh);
        } else {
            this.controls.update();
        }
        
        this.meshes.forEach((meshEntry, id) => {
            const pos = this.simulation.getPosition(id);
            const simRot = this.simulation.getRotation(id);
            const node = this.simulation.getNode(id);
            if (!pos || !simRot || !node) return;

            const isBottom = node.side === 'bottom';
            const isDragged = this.draggedObject && this.draggedObject.userData.agentId === id;
            
            const updateRotation = (mesh, additionalRotation) => {
                if (mesh) {
                    if (additionalRotation) {
                        const finalRot = new this.THREE.Quaternion().multiplyQuaternions(simRot, additionalRotation);
                        mesh.quaternion.copy(finalRot);
                    } else {
                        mesh.quaternion.copy(simRot);
                    }
                }
            };

            if (meshEntry.placeholder) {
                if (!isDragged) {
                    meshEntry.placeholder.position.set(pos.x, pos.y, pos.z);
                } else {
                    meshEntry.placeholder.position.y = pos.y;
                }
                updateRotation(meshEntry.placeholder);
                meshEntry.placeholder.visible = this.visibility.placeholders && (!meshEntry.glb || !this.visibility.glb);
            }

            if (meshEntry.glb) {
                if (!isDragged) {
                    meshEntry.glb.position.set(pos.x, pos.y, pos.z);
                } else {
                    meshEntry.glb.position.y = pos.y;
                }
                updateRotation(meshEntry.glb);
                meshEntry.glb.visible = this.visibility.glb;
            }

            if (meshEntry.courtyard) {
                const courtyardY = isBottom ? -this.boardY : this.boardY;
                if (!isDragged) {
                    meshEntry.courtyard.position.set(pos.x, courtyardY, pos.z);
                } else {
                    meshEntry.courtyard.position.y = courtyardY;
                }
                updateRotation(meshEntry.courtyard);
                meshEntry.courtyard.visible = this.visibility.courtyards;
                
                const targetMaterials = this.materials.courtyard[isBottom ? 'bottom' : 'top'];
                meshEntry.courtyard.traverse(child => {
                    if (child.isMesh && child.material !== targetMaterials.fill) child.material = targetMaterials.fill;
                    if (child.isLineSegments && child.material !== targetMaterials.line) child.material = targetMaterials.line;
                });
            }
            
            if (meshEntry.footprint) {
                const footprintY = isBottom ? -this.boardY - 0.1 : this.boardY + 0.1;
                if (!isDragged) {
                    meshEntry.footprint.position.set(pos.x, footprintY, pos.z);
                } else {
                    meshEntry.footprint.position.y = footprintY;
                }
                const zUpToYUpQuaternion = new this.THREE.Quaternion().setFromEuler(new this.THREE.Euler(-Math.PI / 2, 0, 0));
                updateRotation(meshEntry.footprint, zUpToYUpQuaternion);
                meshEntry.footprint.visible = this.visibility.svg;

                const targetMaterial = this.materials.footprint[isBottom ? 'bottom' : 'top'];
                meshEntry.footprint.traverse(child => {
                    if (child.isMesh && child.material !== targetMaterial) {
                        child.material = targetMaterial;
                    }
                });
            }
        });
        
        if (this.visibility.nets && this.simulation && this.netLines.size > 0) {
            this.netLines.forEach(line => {
                const positions = line.geometry.attributes.position.array;
                let p1, p2;
    
                if (line.userData.type === 'gnd_pour') {
                    const [comp, pin] = line.userData.pin.split('-');
                    p1 = this.simulation.getPinWorldPos(comp)?.[pin];
                    if (!p1) p1 = this.simulation.getPosition(comp);
                    p2 = p1 ? this.getClosestPointOnBoard(p1) : null;
                } else if (line.userData.type === 'net') {
                    const [sComp, sPin] = line.userData.source.split('-');
                    const [tComp, tPin] = line.userData.target.split('-');
                    p1 = this.simulation.getPinWorldPos(sComp)?.[sPin];
                    p2 = this.simulation.getPinWorldPos(tComp)?.[tPin];
                    if (!p1) p1 = this.simulation.getPosition(sComp);
                    if (!p2) p2 = this.simulation.getPosition(tComp);
                }
    
                if (p1 && p2) {
                    const yOffset = p1.y || 0; // Use the component's y-level for the line
                    positions[0] = p1.x; positions[1] = yOffset; positions[2] = p1.z;
                    positions[3] = p2.x; positions[4] = yOffset; positions[5] = p2.z;
                    line.geometry.attributes.position.needsUpdate = true;
                    line.visible = true;
                } else {
                    line.visible = false;
                }
            });
        }
        
        this.renderer.render(this.scene, this.camera);
    }

    cleanup() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
        this.renderer.domElement.removeEventListener('dblclick', this.boundDoubleClick);
        this.renderer.domElement.removeEventListener('pointerdown', this.boundPointerDown);
        this.renderer.domElement.removeEventListener('pointermove', this.boundPointerMove);
        this.renderer.domElement.removeEventListener('pointerup', this.boundPointerUp);
        if(this.controls.cleanup) this.controls.cleanup();

        if (this.renderer.domElement.parentElement) {
            this.renderer.domElement.parentElement.removeChild(this.renderer.domElement);
        }
        if (this.renderer) this.renderer.dispose();
    }
}
`
```

# services/playerStateService.ts
```services/playerStateService.ts
import { openDB, type IDBPDatabase, type DBSchema } from 'idb';
import type { PlayerState } from '../types';

const DB_NAME = 'aetherium-player-data';
const DB_VERSION = 1;
const PLAYER_STORE = 'players';

interface PlayerDBSchema extends DBSchema {
  [PLAYER_STORE]: {
    key: string; // Player name/ID
    value: PlayerState;
  };
}

let dbPromise: Promise<IDBPDatabase<PlayerDBSchema>> | null = null;

const initDB = () => {
  if (!dbPromise) {
    dbPromise = openDB<PlayerDBSchema>(DB_NAME, DB_VERSION, {
      upgrade(db) {
        if (!db.objectStoreNames.contains(PLAYER_STORE)) {
          db.createObjectStore(PLAYER_STORE, { keyPath: 'id' });
        }
      },
    });
  }
  return dbPromise;
};

export const getPlayerState = async (playerName: string): Promise<PlayerState | null> => {
  try {
    const db = await initDB();
    const state = await db.get(PLAYER_STORE, playerName);
    return state || null;
  } catch (error) {
    console.error("Failed to get player state:", error);
    return null;
  }
};

export const savePlayerState = async (playerState: PlayerState): Promise<void> => {
  try {
    const db = await initDB();
    // Ensure we only save the client-authoritative parts of the state.
    const stateToSave: PlayerState = {
      id: playerState.id,
      name: playerState.name,
      x: playerState.x,
      y: playerState.y,
      rotation: playerState.rotation,
      vault: playerState.vault,
    };
    await db.put(PLAYER_STORE, stateToSave);
  } catch (error) {
    console.error("Failed to save player state:", error);
  }
};

export const getOrCreatePlayer = async (playerName: string): Promise<PlayerState> => {
    const existingPlayer = await getPlayerState(playerName);
    if (existingPlayer) {
        return existingPlayer;
    }
    const newPlayer: PlayerState = {
        id: playerName,
        name: playerName,
        x: 0,
        y: 0,
        rotation: 0,
        vault: [], // The Vault for valuable blueprints starts empty.
    };
    await savePlayerState(newPlayer);
    return newPlayer;
};
```

# services/openAIService.ts
```services/openAIService.ts


import type { APIConfig, LLMTool, AIResponse, AIToolCall } from "../types";

const OPENAI_TIMEOUT = 600000; // 10 минут

const fetchWithTimeout = async (url: string, options: RequestInit, timeout: number): Promise<Response> => {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);

    try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return response;
    } catch (e: any) {
        clearTimeout(id);
        if (e.name === 'AbortError') {
            throw new Error(`Request to OpenAI timed out after ${timeout / 1000}s.`);
        }
        throw e;
    }
};

const handleAPIError = async (response: Response, baseUrl: string) => {
    let errorBody;
    try {
        errorBody = await response.json();
    } catch (e) {
        errorBody = await response.text();
    }
    console.error('Error from OpenAI-compatible API:', response.status, errorBody);
    
    let message = `[OpenAI Error ${response.status}]`;
    if (response.status === 401) {
        message += ` Authentication failed. Check your API Key.`;
    } else if (response.status === 404) {
        message += ` Model not found or invalid API endpoint. Check your Base URL: ${baseUrl}`;
    } else if (typeof errorBody === 'object' && errorBody?.error?.message) {
        message += ` ${errorBody.error.message}`;
    } else if (typeof errorBody === 'string') {
        message += ` ${errorBody}`;
    } else {
        message += ` ${response.statusText}`;
    }
    throw new Error(message);
};

const buildOpenAITools = (tools: LLMTool[]) => {
    return tools.map(tool => ({
        type: 'function',
        function: {
            name: tool.name.replace(/[^a-zA-Z0-9_]/g, '_'),
            description: tool.description,
            parameters: {
                type: 'object',
                properties: tool.parameters.reduce((obj, param) => {
                     if (param.type === 'array' || param.type === 'object') {
                        // For complex types, tell the model to expect a string, which we will treat as JSON.
                        obj[param.name] = { type: 'string', description: `${param.description} (This argument must be a valid, JSON-formatted string.)` };
                    } else {
                        const typeMapping = { 'string': 'string', 'number': 'number', 'boolean': 'boolean' };
                        obj[param.name] = { type: typeMapping[param.type] || 'string', description: param.description };
                    }
                    return obj;
                }, {} as Record<string, any>),
                required: tool.parameters.filter(p => p.required).map(p => p.name),
            },
        },
    }));
};

export const generateWithTools = async (
    userInput: string,
    systemInstruction: string,
    modelId: string,
    apiConfig: APIConfig,
    tools: LLMTool[]
): Promise<AIResponse> => {
    const { openAIAPIKey, openAIBaseUrl } = apiConfig;

    if (!openAIAPIKey) throw new Error("OpenAI API Key is missing.");
    if (!openAIBaseUrl) throw new Error("OpenAI Base URL is missing.");
    
    const openAITools = buildOpenAITools(tools);
    const toolNameMap = new Map(tools.map(t => [t.name.replace(/[^a-zA-Z0-9_]/g, '_'), t.name]));

    const body = {
        model: modelId,
        messages: [
            { role: 'system', content: systemInstruction },
            { role: 'user', content: userInput }
        ],
        temperature: 0.1,
        tools: openAITools.length > 0 ? openAITools : undefined,
        tool_choice: openAITools.length > 0 ? "auto" : undefined,
    };
    
    try {
        const response = await fetchWithTimeout(
            `${openAIBaseUrl.replace(/\/+$/, '')}/chat/completions`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${openAIAPIKey}` },
                body: JSON.stringify(body)
            },
            OPENAI_TIMEOUT
        );

        if (!response.ok) {
            await handleAPIError(response, openAIBaseUrl);
            return { toolCalls: null }; // Should not be reached
        }

        const data = await response.json();
        const toolCallsData = data.choices?.[0]?.message?.tool_calls;
        
        if (toolCallsData && Array.isArray(toolCallsData) && toolCallsData.length > 0) {
            try {
                const toolCalls: AIToolCall[] = toolCallsData.map(tc => {
                    const toolCall = tc.function;
                    const originalName = toolNameMap.get(toolCall.name) || toolCall.name;
                    
                    // Robust argument parsing: handles both stringified JSON and objects.
                    const args = toolCall.arguments;
                    let parsedArgs = {};
                    if (typeof args === 'string') {
                        try {
                            parsedArgs = JSON.parse(args || '{}');
                        } catch (e) {
                             console.error(`[OpenAI Service] Failed to parse arguments string for tool ${originalName}:`, e);
                             // Return empty args if parsing fails
                        }
                    } else if (typeof args === 'object' && args !== null) {
                        parsedArgs = args;
                    }

                    return {
                        name: originalName,
                        arguments: parsedArgs
                    };
                });
                return { toolCalls };
            } catch (e) {
                throw new Error(`Failed to process arguments from AI tool call: ${e instanceof Error ? e.message : String(e)}`);
            }
        }
        
        return { toolCalls: null };

    } catch (e) {
        if (e instanceof Error && e.message.toLowerCase().includes('failed to fetch')) {
             throw new Error(`Network Error: Could not connect to OpenAI-compatible API at ${openAIBaseUrl}. Check the URL and your network connection.`);
        }
        throw e;
    }
};

export const generateText = async (
    userInput: string,
    systemInstruction: string,
    modelId: string,
    apiConfig: APIConfig
): Promise<string> => {
    const { openAIAPIKey, openAIBaseUrl } = apiConfig;

    if (!openAIAPIKey) throw new Error("OpenAI API Key is missing.");
    if (!openAIBaseUrl) throw new Error("OpenAI Base URL is missing.");
    
    const body = {
        model: modelId,
        messages: [
            { role: 'system', content: systemInstruction },
            { role: 'user', content: userInput }
        ],
        temperature: 0.0,
    };
    
    try {
        const response = await fetchWithTimeout(
            `${openAIBaseUrl.replace(/\/+$/, '')}/chat/completions`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${openAIAPIKey}` },
                body: JSON.stringify(body)
            },
            OPENAI_TIMEOUT
        );

        if (!response.ok) {
            await handleAPIError(response, openAIBaseUrl);
            return ""; // Should not be reached
        }

        const data = await response.json();
        return data.choices?.[0]?.message?.content || "";
    } catch (e) {
        if (e instanceof Error && e.message.toLowerCase().includes('failed to fetch')) {
             throw new Error(`Network Error: Could not connect to OpenAI-compatible API at ${openAIBaseUrl}. Check the URL and your network connection.`);
        }
        throw e;
    }
};

```

# services/wllamaService.ts
```services/wllamaService.ts
import { Wllama } from '@wllama/wllama';
import type { APIConfig } from '../types';

let wllama: Wllama | null = null;
let currentModelUrl: string | null = null;

const getWllama = async (onProgress: (message: string) => void): Promise<Wllama> => {
    if (wllama) {
        return wllama;
    }
    try {
        onProgress('🚀 Initializing Wllama WebAssembly...');
        
        // Explicitly provide paths to the WASM files from a reliable CDN (jsDelivr)
        // to avoid resolution issues with esm.sh. The version is pinned for stability.
        const config = {
            wasmPaths: {
                'single-thread/wllama.wasm': 'https://cdn.jsdelivr.net/npm/@wllama/wllama@2.3.4/esm/single-thread/wllama.wasm',
                'multi-thread/wllama.wasm': 'https://cdn.jsdelivr.net/npm/@wllama/wllama@2.3.4/esm/multi-thread/wllama.wasm',
            }
        };

        wllama = new Wllama(config);
        await wllama.checkCompatibility();
        onProgress('✅ Wllama initialized successfully.');
        return wllama;
    } catch (e) {
        const error = e as Error;
        onProgress(`[ERROR] ❌ Wllama compatibility check failed: ${error.message}`);
        throw new Error(`Your browser may not support WebAssembly or WebGPU, which are required for Wllama. Error: ${error.message}`);
    }
};

const loadModel = async (modelUrl: string, onProgress: (message: string) => void) => {
    const llm = await getWllama(onProgress);

    if (currentModelUrl === modelUrl && llm.isModelLoaded) {
        onProgress(`✅ Model from ${new URL(modelUrl).pathname.split('/').pop()} is already loaded.`);
        return;
    }

    if (llm.isModelLoaded) {
        onProgress('Releasing previous model...');
        await llm.unloadModel();
        currentModelUrl = null;
    }
    
    const modelName = new URL(modelUrl).pathname.split('/').pop();
    onProgress(`🚀 Loading model: ${modelName}. This may take a while...`);

    try {
        await llm.loadModelFromUrl(
            modelUrl,
            {
                progressCallback: (progress) => {
                    const percentage = (progress.loaded / progress.total * 100).toFixed(1);
                    onProgress(`Downloading ${modelName}: ${percentage}%`);
                }
            }
        );
        currentModelUrl = modelUrl;
        onProgress(`✅ Model ${modelName} loaded.`);
    } catch (e) {
         const error = e as Error;
         currentModelUrl = null; // Ensure we don't think a failed model is loaded
         throw new Error(`Failed to load model from ${modelUrl}. Error: ${error.message}`);
    }
};

const generate = async (
    userInput: string,
    systemInstruction: string,
    modelUrl: string,
    temperature: number,
    onProgress: (message: string) => void,
): Promise<string> => {
     try {
        await loadModel(modelUrl, onProgress);
        const llm = await getWllama(onProgress);

        onProgress('🤖 Generating response with Wllama...');

        const response = await llm.createChatCompletion([
            { role: 'system', content: systemInstruction },
            { role: 'user', content: userInput },
        ], {
            temp: temperature > 0 ? temperature : 0.1,
            n_predict: 2048,
        });

        onProgress('✅ Response generated.');
        return response.choices[0].message.content || "";

    } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        onProgress(`[ERROR] ❌ Wllama generation failed: ${errorMessage}`);
        console.error("Wllama service error:", e);
        throw e;
    }
};

export const generateJsonOutput = async (
    userInput: string,
    systemInstruction: string,
    modelUrl: string,
    temperature: number,
    apiConfig: APIConfig,
    onProgress: (message: string) => void,
): Promise<string> => {
    const fullSystemInstruction = `${systemInstruction}\n\nYou MUST respond with a single, valid JSON object and nothing else. Do not wrap the JSON in triple backticks.`;
    const responseText = await generate(userInput, fullSystemInstruction, modelUrl, temperature, onProgress);
    return responseText || "{}";
};

export const generateText = async (
    userInput: string,
    systemInstruction: string,
    modelUrl: string,
    temperature: number,
    apiConfig: APIConfig,
    onProgress: (message: string) => void
): Promise<string> => {
    return await generate(userInput, systemInstruction, modelUrl, temperature, onProgress);
};

```

# services/aiService.ts
```services/aiService.ts
import { ModelProvider, type AIModel, type APIConfig, type AIResponse, type LLMTool } from '../types';
import * as geminiService from './geminiService';
import * as openAIService from './openAIService';
import * as ollamaService from './ollamaService';
import * as huggingFaceService from './huggingFaceService';
import * as wllamaService from './wllamaService';

// This prompt is now only used as a fallback for providers that don't support native tool calling.
const JSON_TOOL_CALL_SYSTEM_PROMPT = `
You are a tool-calling AI. Your only purpose is to respond with a JSON object or a JSON array of objects representing tool calls.

**Response Requirements:**
*   Your response MUST be valid JSON.
*   Your response MUST NOT be wrapped in markdown (e.g., \`\`\`json ... \`\`\`).
*   Your response MUST NOT contain any text, explanations, or comments outside of the JSON structure.

**Formats:**
1.  **Single Tool Call (JSON Object):**
    \`\`\`json
    {
      "name": "tool_name",
      "arguments": { "arg1": "value1" }
    }
    \`\`\`

2.  **Multiple Tool Calls (JSON Array):**
    \`\`\`json
    [
      { "name": "tool_one", "arguments": { "arg_a": "val_a" } },
      { "name": "tool_two", "arguments": { "arg_b": "val_b" } }
    ]
    \`\`\`

3.  **No Action:**
    If no tool is suitable, respond with an empty JSON object: \`{}\`.

The list of available tools is provided below.
{{TOOLS_JSON}}
`;

const LLM_FILTER_SYSTEM_PROMPT = `You are an expert tool selection AI. Your task is to analyze a user's request and a list of available tools, and select ONLY the most relevant tools to accomplish the task.

**Response Requirements:**
*   Respond ONLY with a single, valid JSON object containing one key: "tool_names".
*   The value of "tool_names" MUST be an array of strings, where each string is the exact name of a selected tool from the provided list.
*   Do NOT include any explanations or text outside the JSON structure.
*   Do NOT wrap the JSON in markdown backticks.
*   If no tools seem relevant, respond with an empty array: \`{"tool_names": []}\`.

Example Response:
\`\`\`json
{
  "tool_names": [
    "Tool Creator",
    "Server File Writer",
    "Define KiCad Component"
  ]
}
\`\`\`
`;


const parseJsonOrNull = (jsonString: string): any => {
    if (!jsonString) return null;
    let jsonText = jsonString.trim();
    if (jsonText.startsWith('```') && jsonText.endsWith('```')) {
        jsonText = jsonText.replace(/^```(?:json)?\s*|```\s*$/g, '');
    }
    try {
        return JSON.parse(jsonText);
    } catch (e) {
        console.error("Failed to parse JSON response:", jsonString, e);
        return null; // Return null if parsing fails
    }
};

const parseToolCallResponse = (responseText: string): AIResponse => {
    const parsed = parseJsonOrNull(responseText);
    if (!parsed || Object.keys(parsed).length === 0) {
        return { toolCalls: null };
    }

    // Handle both a single tool call object and an array of them
    const toolCallObjects = Array.isArray(parsed) ? parsed : [parsed];

    const validToolCalls = toolCallObjects
        .map(call => {
            if (!call || typeof call !== 'object' || !call.name) return null;
            if (typeof call.arguments === 'undefined') {
                call.arguments = {};
            }
            return { name: call.name, arguments: call.arguments };
        })
        .filter(Boolean); // filter out any nulls

    if (validToolCalls.length === 0) {
        return { toolCalls: null };
    }

    return { toolCalls: validToolCalls as any[] };
};

export const generateResponse = async (
    userInput: { text: string; files: any[] },
    systemInstruction: string,
    model: AIModel,
    apiConfig: APIConfig,
    onProgress: (message: string) => void,
    relevantTools: LLMTool[],
): Promise<AIResponse> => {
    switch (model.provider) {
        case ModelProvider.GoogleAI:
            return geminiService.generateWithNativeTools(userInput.text, systemInstruction, model.id, relevantTools, userInput.files);
        
        case ModelProvider.OpenAI_API:
             // OpenAI service currently only takes text.
             return openAIService.generateWithTools(userInput.text, systemInstruction, model.id, apiConfig, relevantTools);

        case ModelProvider.Ollama:
             // Ollama service currently only takes text.
            return ollamaService.generateWithTools(userInput.text, systemInstruction, model.id, apiConfig, relevantTools);
        
        case ModelProvider.Wllama:
        case ModelProvider.HuggingFace: {
            // Wllama and HuggingFace pipelines don't support native tool calling, so we fall back to JSON prompting.
            const toolsForPrompt = relevantTools.map(t => ({ name: t.name, description: t.description, parameters: t.parameters }));
            const toolDefinitions = JSON.stringify(toolsForPrompt, null, 2);
            const fullSystemInstruction = systemInstruction + '\n\n' + JSON_TOOL_CALL_SYSTEM_PROMPT.replace('{{TOOLS_JSON}}', toolDefinitions);
            
            const service = model.provider === ModelProvider.Wllama ? wllamaService : huggingFaceService;
            const responseText = await service.generateJsonOutput(userInput.text, fullSystemInstruction, model.id, 0.1, apiConfig, onProgress);

            return parseToolCallResponse(responseText);
        }

        default:
            throw new Error(`Unsupported model provider: ${model.provider}`);
    }
};

export const generateTextResponse = async (
    prompt: string,
    systemInstruction: string,
    model: AIModel,
    apiConfig: APIConfig,
    onProgress: (message: string) => void,
): Promise<string> => {
    switch (model.provider) {
        case ModelProvider.GoogleAI:
            return geminiService.generateText(prompt, systemInstruction, model.id);
        case ModelProvider.OpenAI_API:
             return openAIService.generateText(prompt, systemInstruction, model.id, apiConfig);
        case ModelProvider.Ollama:
             return ollamaService.generateText(prompt, systemInstruction, model.id, apiConfig);
        case ModelProvider.Wllama:
             return wllamaService.generateText(prompt, systemInstruction, model.id, 0.1, apiConfig, onProgress);
        case ModelProvider.HuggingFace:
             return huggingFaceService.generateText(prompt, systemInstruction, model.id, 0.1, apiConfig, onProgress);
        default:
            throw new Error(`Text generation not supported for model provider: ${model.provider}`);
    }
};

export const filterToolsWithLLM = async (
    userInput: string,
    model: AIModel,
    apiConfig: APIConfig,
    allTools: LLMTool[],
    onProgress: (message: string) => void,
): Promise<string[]> => {
    const toolDescriptions = allTools.map(t => `- ${t.name}: ${t.description}`).join('\\n');
    const prompt = `User Request: "${userInput}"\\n\\nAvailable Tools:\\n${toolDescriptions}\\n\\nBased on the user request, which of the available tools are most relevant?`;
    
    const responseText = await generateTextResponse(
        prompt,
        LLM_FILTER_SYSTEM_PROMPT,
        model,
        apiConfig,
        onProgress
    );

    try {
        let jsonText = responseText.trim();
        if (jsonText.startsWith('```') && jsonText.endsWith('```')) {
            jsonText = jsonText.replace(/^```(?:json)?\s*|```\s*$/g, '');
        }
        const parsed = JSON.parse(jsonText);
        if (parsed.tool_names && Array.isArray(parsed.tool_names)) {
            const validToolNames = new Set(allTools.map(t => t.name));
            return parsed.tool_names.filter(t => typeof t === 'string' && validToolNames.has(t));
        }
        return [];
    } catch (e) {
        console.error("Failed to parse LLM tool filter response:", responseText, e);
        return []; // Fallback to no tools if parsing fails
    }
};

export const contextualizeWithSearch = async (userInput: { text: string, files: any[] }): Promise<{ summary: string, sources: any[] }> => {
    // For now, only Gemini supports this. We can add fallbacks for other providers later if needed.
    return geminiService.generateWithGoogleSearch(userInput.text, userInput.files);
};

```

# services/embeddingService.ts
```services/embeddingService.ts
import { pipeline, type FeatureExtractionPipeline } from '@huggingface/transformers';

// List of models to try, from smallest to largest quantized version.
// This allows for a graceful fallback if a smaller model fails to load on the user's device.
const EMBEDDING_MODELS: {name: string, size: string}[] = [
//    { name: 'Xenova/paraphrase-MiniLM-L3-v2', size: '17.5MB' }, // Smallest, fastest option
    { name: 'Xenova/all-MiniLM-L6-v2', size: '23MB' },       // The original model, a reliable fallback
];

class EmbeddingSingleton {
    static instance: FeatureExtractionPipeline | null = null;
    static async getInstance(onProgress: (msg: string) => void): Promise<FeatureExtractionPipeline> {
        if (this.instance !== null) {
            return this.instance;
        }

        if (EMBEDDING_MODELS.length === 0) {
            onProgress(`[ERROR] ❌ No embedding models are configured. Tool relevance filtering will be disabled.`);
            throw new Error("No embedding models configured. This feature is disabled.");
        }

        (window as any).env = { ...(window as any).env, allowLocalModels: false, useFbgemm: false };

        const reportedDownloads = new Set();
        const progressCallback = (progress: any) => {
            const { status, file } = progress;
            if (status === 'download' && !reportedDownloads.has(file)) {
                onProgress(`Downloading model file: ${file}...`);
                reportedDownloads.add(file);
            }
        };
        
        for (const modelInfo of EMBEDDING_MODELS) {
            try {
                onProgress(`🚀 Attempting to load embedding model: ${modelInfo.name} (${modelInfo.size})...`);
                reportedDownloads.clear(); // Reset reported files for each new attempt
                
                const extractor = await pipeline('feature-extraction', modelInfo.name, {
                    device: 'webgpu',
                    progress_callback: progressCallback,
                    dtype: 'auto' // Use automatic quantization for better compatibility
                });

                onProgress(`✅ Successfully loaded embedding model: ${modelInfo.name}`);
                this.instance = extractor;
                return this.instance;

            } catch (e) {
                const errorMessage = e instanceof Error ? e.message : String(e);
                onProgress(`[WARN] ⚠️ Failed to load ${modelInfo.name}. Reason: ${errorMessage}. Trying next model...`);
                console.warn(`Failed to load embedding model ${modelInfo.name}`, e);
            }
        }

        // This part is reached only if all models in the list fail to load.
        onProgress(`[ERROR] ❌ Could not load any embedding models. Tool relevance filtering will be disabled.`);
        throw new Error("All embedding models failed to load. Please check your network connection and browser compatibility (e.g., Chrome/Edge).");
    }
}

export const generateEmbeddings = async (texts: string[], onProgress: (msg: string) => void): Promise<number[][]> => {
    try {
        const extractor = await EmbeddingSingleton.getInstance(onProgress);
        // The library expects a single string or an array of strings.
        const output = await extractor(texts.length === 1 ? texts[0] : texts, { pooling: 'mean', normalize: true });
        // The output format differs for single vs. multiple inputs. Standardize it.
        if (texts.length === 1) {
            return [output.tolist()[0]]; // It returns a 2D array for a single item, we need the inner array
        }
        return output.tolist();

    } catch(e) {
        console.error("Embedding generation failed:", e);
        throw e;
    }
};

export const cosineSimilarity = (vecA: number[], vecB: number[]): number => {
    if (!vecA || !vecB || vecA.length !== vecB.length) {
        return 0;
    }
    // Since vectors are normalized, dot product is equivalent to cosine similarity
    let dotProduct = 0;
    for (let i = 0; i < vecA.length; i++) {
        dotProduct += vecA[i] * vecB[i];
    }
    return dotProduct;
};
```

# services/geminiService.ts
```services/geminiService.ts


import { GoogleGenAI, Type, FunctionDeclaration, GenerateContentResponse } from "@google/genai";
import type { AIResponse, LLMTool, ToolParameter, AIToolCall } from "../types";

const getAIClient = (): GoogleGenAI => {
    if (typeof process === 'undefined' || !process.env || !process.env.API_KEY) {
        throw new Error("Google AI API Key not found. It must be set in the process.env.API_KEY environment variable.");
    }
    return new GoogleGenAI({ apiKey: process.env.API_KEY });
};

const sanitizeForFunctionName = (name: string): string => {
  return name.replace(/[^a-zA-Z0-9_]/g, '_');
};

const mapTypeToGemini = (type: ToolParameter['type']): Type => {
    switch (type) {
        case 'string': return Type.STRING;
        case 'number': return Type.NUMBER;
        case 'boolean': return Type.BOOLEAN;
        // Array and Object are handled separately now.
        case 'array': return Type.ARRAY;
        case 'object': return Type.OBJECT;
        default: return Type.STRING;
    }
};

const buildGeminiTools = (tools: LLMTool[]): { functionDeclarations: FunctionDeclaration[], toolNameMap: Map<string, string> } => {
    const toolNameMap = new Map<string, string>();
    const functionDeclarations = tools.map((tool): FunctionDeclaration => {
        const properties: Record<string, any> = {};
        const required: string[] = [];

        tool.parameters.forEach(param => {
            if (param.type === 'array' || param.type === 'object') {
                // For complex types, instruct the model to provide a JSON string.
                // This avoids schema validation issues with nested, undefined structures
                // that Gemini's strict schema enforcement would reject.
                properties[param.name] = {
                    type: Type.STRING,
                    description: `${param.description} (Note: This argument must be a valid, JSON-formatted string.)`
                };
            } else {
                properties[param.name] = { type: mapTypeToGemini(param.type), description: param.description };
            }

            if (param.required) {
                required.push(param.name);
            }
        });
        
        const functionName = sanitizeForFunctionName(tool.name);
        toolNameMap.set(functionName, tool.name);

        return {
            name: functionName,
            description: tool.description,
            parameters: { type: Type.OBJECT, properties, required },
        };
    });

    return { functionDeclarations, toolNameMap };
};

const parseNativeToolCall = (response: GenerateContentResponse, toolNameMap: Map<string, string>): AIResponse => {
    const functionCallParts = response.candidates?.[0]?.content?.parts?.filter(part => 'functionCall' in part);

    if (!functionCallParts || functionCallParts.length === 0) {
        return { toolCalls: null };
    }

    const toolCalls = functionCallParts.map(part => {
        const { name, args } = part.functionCall!;
        const originalToolName = toolNameMap.get(name);
        if (!originalToolName) {
            console.warn(`AI called an unknown tool via Gemini (native): ${name}`);
            return null;
        }
        return { name: originalToolName, arguments: args || {} };
    }).filter((call): call is AIToolCall => call !== null);

    return { toolCalls: toolCalls.length > 0 ? toolCalls : null };
};

const handleAPIError = (error: unknown, requestForDebug?: any, rawResponseForDebug?: string): Error => {
    console.error("Error in Gemini Service:", error);
    if (requestForDebug) {
        try {
            // Create a debug-friendly version of the request, truncating large file data.
            const debugRequest = JSON.parse(JSON.stringify(requestForDebug)); // Deep copy
            if (debugRequest.contents && typeof debugRequest.contents === 'object' && Array.isArray(debugRequest.contents.parts)) {
                debugRequest.contents.parts.forEach((part: any) => {
                    if (part.inlineData && typeof part.inlineData.data === 'string') {
                        part.inlineData.data = part.inlineData.data.substring(0, 100) + '... [TRUNCATED]';
                    }
                });
            }
            console.error("Failing Gemini Request Payload:", JSON.stringify(debugRequest, null, 2));
        } catch(e) {
            console.error("Failed to serialize the debug request payload:", e);
        }
    }

    const errorDetails = (error as any).message || (error as any).toString();
    const responseText = (error as any).response?.text;
    const finalMessage = `AI processing failed: ${errorDetails}${responseText ? `\nResponse: ${responseText}` : ''}. Check the browser console for the full request payload.`;
    
    const processingError = new Error(finalMessage) as any;
    processingError.rawAIResponse = rawResponseForDebug || JSON.stringify(error, null, 2);
    return processingError;
};

export const generateWithNativeTools = async (
    userInput: string,
    systemInstruction: string,
    modelId: string,
    relevantTools: LLMTool[],
    files: { name: string, type: string, data: string }[] = []
): Promise<AIResponse> => {
    const ai = getAIClient();
    const { functionDeclarations, toolNameMap } = buildGeminiTools(relevantTools);
    let rawResponseForDebug = "";

    const parts: any[] = [{ text: userInput }];
    for (const file of files) {
        parts.push({
            inlineData: {
                mimeType: file.type,
                data: file.data,
            },
        });
    }

    const requestPayload = {
        model: modelId,
        contents: { parts }, // Always use the {parts: [...]} structure
        config: {
            systemInstruction: systemInstruction,
            temperature: 0.1,
            tools: functionDeclarations.length > 0 ? [{ functionDeclarations }] : undefined,
        },
    };

    try {
        const response = await ai.models.generateContent(requestPayload);
        
        rawResponseForDebug = JSON.stringify(response, null, 2);
        return parseNativeToolCall(response, toolNameMap);
    } catch (error) {
        throw handleAPIError(error, requestPayload, rawResponseForDebug);
    }
};

export const generateText = async (
    prompt: string,
    systemInstruction: string,
    modelId: string,
): Promise<string> => {
    const ai = getAIClient();
    const requestPayload = {
        model: modelId,
        contents: { parts: [{ text: prompt }] },
        config: {
            systemInstruction: systemInstruction,
            temperature: 0.0,
        },
    };

    try {
        const response = await ai.models.generateContent(requestPayload);
        return response.text;
    } catch (error) {
        throw handleAPIError(error, requestPayload);
    }
};

export const generateWithGoogleSearch = async (
    prompt: string,
    files: { name: string; type: string; data: string }[] = []
): Promise<{ summary: string; sources: any[] }> => {
    const ai = getAIClient();

    const parts: any[] = [{ text: prompt }];
    for (const file of files) {
        parts.push({
            inlineData: {
                mimeType: file.type,
                data: file.data,
            },
        });
    }

    const requestPayload = {
        model: "gemini-2.5-flash",
        contents: { parts }, // Always use the {parts: [...]} structure
        config: {
            tools: [{ googleSearch: {} }],
        },
    };
    
    let rawResponseForDebug = "";

    try {
        const response = await ai.models.generateContent(requestPayload);
        rawResponseForDebug = JSON.stringify(response, null, 2);

        const summary = response.text;
        const groundingMetadata = response.candidates?.[0]?.groundingMetadata;
        const sources = groundingMetadata?.groundingChunks?.map(chunk => chunk.web).filter(Boolean) || [];
        
        return { summary, sources };
    } catch(error) {
        throw handleAPIError(error, requestPayload, rawResponseForDebug);
    }
};

```

# services/huggingFaceService.ts
```services/huggingFaceService.ts
import { pipeline, type TextGenerationPipeline } from '@huggingface/transformers';
import type { APIConfig } from '../types';

let generator: TextGenerationPipeline | null = null;
let currentModelId: string | null = null;
let currentDevice: string | null = null;

const handleProgress = (onProgress: (message: string) => void) => {
    const reportedDownloads = new Set();
    return (progress: any) => {
        const { status, file } = progress;
        if (status === 'download' && !reportedDownloads.has(file)) {
            onProgress(`Downloading model file: ${file}...`);
            reportedDownloads.add(file);
        }
    };
};

const getPipeline = async (modelId: string, onProgress: (message: string) => void): Promise<TextGenerationPipeline> => {
    // In this simplified version, device is hardcoded, but can be expanded via a config.
    const huggingFaceDevice = 'webgpu'; 

    if (generator && currentModelId === modelId && currentDevice === huggingFaceDevice) {
        return generator;
    }

    onProgress(`🚀 Initializing model: ${modelId}. This may take a few minutes...`);
    
    if (generator) {
        await generator.dispose();
        generator = null;
    }

    (window as any).env = (window as any).env || {};
    (window as any).env.allowLocalModels = false;
    (window as any).env.useFbgemm = false;
    
    // The options for the pipeline. Using fp16 for reduced memory usage.
    const pipelineOptions = {
        device: huggingFaceDevice,
        progress_callback: handleProgress(onProgress),
        dtype: 'fp16'
    };
    
    // By casting the options argument to 'any' at the call site, we prevent TypeScript from creating
    // a massive union type from all the pipeline() overloads, which was causing a "type is too complex" error.
    // This is a necessary workaround for a known issue with the transformers.js library's complex types.
    // @ts-ignore 
    generator = await pipeline('text-generation', modelId, pipelineOptions) as TextGenerationPipeline;

    currentModelId = modelId;
    currentDevice = huggingFaceDevice;
    
    onProgress(`✅ Model ${modelId} loaded successfully.`);
    return generator;
};

const executePipe = async (pipe: TextGenerationPipeline, system: string, user:string, temp: number): Promise<string> => {
    const prompt = `<|system|>\n${system}<|end|>\n<|user|>\n${user}<|end|>\n<|assistant|>`;

    const outputs = await pipe(prompt, {
        max_new_tokens: 2048,
        temperature: temp > 0 ? temp : 0.1,
        do_sample: temp > 0,
        top_k: temp > 0 ? 50 : 1,
    });
    
    const rawText = (outputs[0] as any).generated_text;
    const assistantResponse = rawText.split('<|assistant|>').pop()?.trim();

    if (!assistantResponse) {
        throw new Error("Could not extract assistant's response from model output.");
    }
    
    return assistantResponse;
};

const generateDetailedError = (error: unknown, modelId: string, rawResponse?: string): Error => {
    let finalMessage;
    if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
        finalMessage = `Network error: failed to download model files for ${modelId}. Check your internet connection and ad blockers.`;
    } else {
        finalMessage = `HuggingFace model error (${modelId}): ${error instanceof Error ? error.message : "An unknown error occurred"}`;
    }
    const processingError = new Error(finalMessage) as any;
    processingError.rawAIResponse = rawResponse || "Could not get raw response.";
    return processingError;
};

const generate = async (system: string, user: string, modelId: string, temperature: number, onProgress: (message: string) => void): Promise<string> => {
     try {
        const pipe = await getPipeline(modelId, onProgress);
        const responseText = await executePipe(pipe, system, user, temperature);
        return responseText;
    } catch (e) {
        throw generateDetailedError(e, modelId);
    }
};

export const generateJsonOutput = async (
    userInput: string,
    systemInstruction: string,
    modelId: string,
    temperature: number,
    apiConfig: APIConfig,
    onProgress: (message: string) => void,
): Promise<string> => {
    const fullSystemInstruction = `${systemInstruction}\n\nYou MUST respond with a single, valid JSON object and nothing else. Do not wrap the JSON in triple backticks.`;
    const responseText = await generate(fullSystemInstruction, userInput, modelId, temperature, onProgress);
    return responseText || "{}";
};

export const generateText = async (
    userInput: string,
    systemInstruction: string,
    modelId: string,
    temperature: number,
    apiConfig: APIConfig,
    onProgress: (message: string) => void
): Promise<string> => {
    return await generate(systemInstruction, userInput, modelId, temperature, onProgress);
};
```

# services/ollamaService.ts
```services/ollamaService.ts


import type { APIConfig, LLMTool, AIResponse, AIToolCall } from "../types";

const OLLAMA_TIMEOUT = 600000; // 10 minutes

const fetchWithTimeout = async (url: string, options: RequestInit, timeout: number): Promise<Response> => {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);

    try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return response;
    } catch (e: any) {
        clearTimeout(id);
        if (e.name === 'AbortError') {
            throw new Error(`Request to Ollama timed out after ${timeout / 1000} seconds. The model might be too large for your system, or the Ollama server is not responding.`);
        }
        throw e;
    }
};

const handleAPIError = async (response: Response) => {
    try {
        const errorBody = await response.text();
        console.error('Error from Ollama API:', response.status, errorBody);
        throw new Error(`[Ollama Error ${response.status}]: ${errorBody || response.statusText}`);
    } catch (e: any) {
         throw new Error(`[Ollama Error ${response.status}]: Could not parse error response.`);
    }
};

const generateDetailedError = (error: unknown, host: string): Error => {
    let finalMessage: string;
    if (error instanceof Error) {
        const lowerCaseMessage = error.message.toLowerCase();
        if (lowerCaseMessage.includes('failed to fetch') || lowerCaseMessage.includes('networkerror') || lowerCaseMessage.includes('could not connect')) {
            finalMessage = `Network Error: Failed to connect to Ollama server at ${host}. Please ensure the server is running, the host URL is correct, and there are no network issues (e.g., firewalls or CORS policies) blocking the connection.`;
        } else {
             finalMessage = `[Ollama Service Error] ${error.message}`;
        }
    } else {
        finalMessage = "An unknown error occurred while communicating with Ollama.";
    }
    const processingError = new Error(finalMessage) as any;
    processingError.rawAIResponse = "Could not get raw response due to an error.";
    return processingError;
};

const buildOllamaTools = (tools: LLMTool[]) => {
    return tools.map(tool => ({
        type: 'function',
        function: {
            name: tool.name.replace(/[^a-zA-Z0-9_]/g, '_'),
            description: tool.description,
            parameters: {
                type: 'object',
                properties: tool.parameters.reduce((obj, param) => {
                    if (param.type === 'array' || param.type === 'object') {
                        // For complex types, tell the model to expect a string, which we will treat as JSON.
                        obj[param.name] = { type: 'string', description: `${param.description} (This argument must be a valid, JSON-formatted string.)` };
                    } else {
                        const typeMapping = { 'string': 'string', 'number': 'number', 'boolean': 'boolean' };
                        obj[param.name] = { type: typeMapping[param.type] || 'string', description: param.description };
                    }
                    return obj;
                }, {} as Record<string, any>),
                required: tool.parameters.filter(p => p.required).map(p => p.name),
            },
        },
    }));
};


export const generateWithTools = async (
    userInput: string,
    systemInstruction: string,
    modelId: string,
    apiConfig: APIConfig,
    tools: LLMTool[]
): Promise<AIResponse> => {
    const { ollamaHost } = apiConfig;
    if (!ollamaHost) {
        throw new Error("Ollama Host URL is not configured. Please set it in the API Configuration.");
    }
    
    const ollamaTools = buildOllamaTools(tools);
    const toolNameMap = new Map(tools.map(t => [t.name.replace(/[^a-zA-Z0-9_]/g, '_'), t.name]));

    const body = {
        model: modelId,
        messages: [
            { role: 'system', content: systemInstruction },
            { role: 'user', content: userInput }
        ],
        stream: false,
        tools: ollamaTools.length > 0 ? ollamaTools : undefined,
        options: {
            temperature: 0.1,
        },
    };

    try {
        const response = await fetchWithTimeout(
            `${ollamaHost.replace(/\/+$/, '')}/api/chat`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            },
            OLLAMA_TIMEOUT
        );

        if (!response.ok) {
            await handleAPIError(response);
            return { toolCalls: null }; // Should not be reached
        }

        const data = await response.json();
        const toolCallsData = data.message?.tool_calls;
        
        if (toolCallsData && Array.isArray(toolCallsData) && toolCallsData.length > 0) {
            const toolCalls: AIToolCall[] = toolCallsData.map(tc => {
                const toolCall = tc.function;
                const originalName = toolNameMap.get(toolCall.name) || toolCall.name;
                
                // Robust argument parsing
                const args = toolCall.arguments;
                let parsedArgs = {};
                 if (typeof args === 'object' && args !== null) {
                    parsedArgs = args;
                } else if (typeof args === 'string') {
                    try {
                        parsedArgs = JSON.parse(args || '{}');
                    } catch (e) {
                        console.error(`[Ollama Service] Failed to parse arguments string for tool ${originalName}:`, e);
                        // Return empty args if parsing fails
                    }
                }

                return {
                    name: originalName,
                    arguments: parsedArgs
                };
            }).filter(Boolean); // Filter out any potential nulls from parsing errors
            return { toolCalls };
        }
        
        return { toolCalls: null };

    } catch (e) {
        throw generateDetailedError(e, ollamaHost);
    }
};

export const generateText = async (
    userInput: string,
    systemInstruction: string,
    modelId: string,
    apiConfig: APIConfig
): Promise<string> => {
    const { ollamaHost } = apiConfig;
    if (!ollamaHost) {
        throw new Error("Ollama Host URL is not configured. Please set it in the API Configuration.");
    }

    const body = {
        model: modelId,
        messages: [
            { role: 'system', content: systemInstruction },
            { role: 'user', content: userInput }
        ],
        stream: false,
        options: {
            temperature: 0.0,
        },
    };

    try {
        const response = await fetchWithTimeout(
            `${ollamaHost.replace(/\/+$/, '')}/api/chat`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            },
            OLLAMA_TIMEOUT
        );

        if (!response.ok) {
            await handleAPIError(response);
            return ""; // Should not be reached
        }

        const data = await response.json();
        return data.message?.content || "";
    } catch (e) {
        throw generateDetailedError(e, ollamaHost);
    }
};

```

# services/cacheService.ts
```services/cacheService.ts
// services/cacheService.ts
import { openDB, type IDBPDatabase, type DBSchema } from 'https://esm.sh/idb@8';

const DB_NAME = 'singularity-agent-cache';
const DB_VERSION = 1;
const MCP_CACHE_STORE = 'mcp_cache';
const ASSET_CACHE_STORE = 'asset_cache';

interface CacheDBSchema extends DBSchema {
  [MCP_CACHE_STORE]: {
    key: string;
    value: { result: any; timestamp: number };
  };
  [ASSET_CACHE_STORE]: {
    key: string;
    value: { blob: Blob; timestamp: number };
  };
}

let dbPromise: Promise<IDBPDatabase<CacheDBSchema>> | null = null;

const initDB = () => {
  if (!dbPromise) {
    dbPromise = openDB<CacheDBSchema>(DB_NAME, DB_VERSION, {
      upgrade(db) {
        if (!db.objectStoreNames.contains(MCP_CACHE_STORE)) {
          db.createObjectStore(MCP_CACHE_STORE);
        }
        if (!db.objectStoreNames.contains(ASSET_CACHE_STORE)) {
          db.createObjectStore(ASSET_CACHE_STORE);
        }
      },
    });
  }
  return dbPromise;
};

// --- MCP (Server Tool Call) Cache ---

export const getMcpCache = async (key: string): Promise<any | null> => {
  try {
    const db = await initDB();
    const entry = await db.get(MCP_CACHE_STORE, key);
    return entry ? entry.result : null;
  } catch (error) {
    console.error("Failed to get from MCP cache:", error);
    return null;
  }
};

export const setMcpCache = async (key: string, result: any): Promise<void> => {
  try {
    const db = await initDB();
    await db.put(MCP_CACHE_STORE, { result, timestamp: Date.now() }, key);
  } catch (error) {
    console.error("Failed to set in MCP cache:", error);
  }
};

// --- Asset (SVG/GLB) Cache ---

export const getAssetBlob = async (url: string): Promise<Blob | null> => {
  try {
    const db = await initDB();
    const entry = await db.get(ASSET_CACHE_STORE, url);
    return entry ? entry.blob : null;
  } catch (error) {
    console.error(`Failed to get asset from cache (${url}):`, error);
    return null;
  }
};

export const setAssetBlob = async (url: string, blob: Blob): Promise<void> => {
  try {
    const db = await initDB();
    await db.put(ASSET_CACHE_STORE, { blob, timestamp: Date.now() }, url);
  } catch (error) {
    console.error(`Failed to set asset in cache (${url}):`, error);
  }
};

export const clearAllCaches = async () => {
    try {
        const db = await initDB();
        await db.clear(MCP_CACHE_STORE);
        await db.clear(ASSET_CACHE_STORE);
        console.log("All caches cleared.");
    } catch (error) {
        console.error("Failed to clear caches:", error);
    }
}
```

# hooks/useAppRuntime.ts
```hooks/useAppRuntime.ts
import React, { useCallback, useRef, useEffect, useMemo } from 'react';
import * as aiService from '../services/aiService';
import { getMcpCache, setMcpCache } from '../services/cacheService';
import type {
    LLMTool, EnrichedAIResponse, NewToolPayload, AIToolCall,
    RobotState, EnvironmentObject, AIModel, APIConfig, ExecuteActionFunction,
    AgentPersonality, KnowledgeGraph, MainView, PlayerState, VaultItem, ServerInventoryItem, WorldEvent, WorldCreature
} from '../types';
import { INITIAL_LAYOUT_DATA } from './useKicadManager';

type UseAppRuntimeProps = {
    allToolsRef: React.MutableRefObject<LLMTool[]>;
    logEvent: (message: string) => void;
    generateMachineReadableId: (name: string, existingTools: LLMTool[]) => string;
    isServerConnected: boolean;
    setTools: React.Dispatch<React.SetStateAction<LLMTool[]>>;
    forceRefreshServerTools: () => Promise<{ success: boolean; count: number }>;
    // Kicad props
    setPcbArtifacts: (artifacts: any) => void;
    kicadLogEvent: (message: string) => void;
    setCurrentKicadArtifact: (artifact: any) => void;
    updateWorkflowChecklist: (stepName: string, items: string[]) => void;
    kicadSimulators: any;
    setLayoutHeuristics: React.Dispatch<React.SetStateAction<any>>;
    updateLayout: React.Dispatch<React.SetStateAction<KnowledgeGraph | null>>;
    getKicadProjectState: () => any;
    // Contextual State Accessors & Setters
    robotSetters: any;
    gameSetters: any;
    // FIX: The type for getGameStateForRuntime was missing properties, causing type errors downstream.
    getGameStateForRuntime: (agentId: string) => { robot: RobotState; players: PlayerState[]; robotStates: RobotState[]; environment: EnvironmentObject[]; personalities: AgentPersonality[]; gameTick: number; worldCreatures: WorldCreature[]; };
    // Knowledge Graph props
    getKnowledgeGraphState: () => KnowledgeGraph | null;
    setKnowledgeGraphState: React.Dispatch<React.SetStateAction<KnowledgeGraph | null>>;
    // Player State props
    playerManager: {
        addToVault: (vaultItem: Omit<VaultItem, 'id' | 'createdAt'>) => Promise<void>;
        hasBlueprint: (blueprintName: string) => boolean;
        updateInventory: (items: ServerInventoryItem[]) => Promise<void>;
        hasItems: (items: { name: string, quantity: number }[]) => boolean;
    };
};

type UseAppRuntimeReturn = {
    executeActionRef: React.MutableRefObject<ExecuteActionFunction | null>;
};


export const useAppRuntime = (props: UseAppRuntimeProps): UseAppRuntimeReturn => {
    const {
        allToolsRef, logEvent, generateMachineReadableId,
        isServerConnected, setTools,
        forceRefreshServerTools,
        // Kicad
        setPcbArtifacts, kicadLogEvent, setCurrentKicadArtifact,
        updateWorkflowChecklist, kicadSimulators,
        setLayoutHeuristics, updateLayout, getKicadProjectState,
        // Contextual Setters
        robotSetters, gameSetters, getGameStateForRuntime,
        // Knowledge Graph
        getKnowledgeGraphState, setKnowledgeGraphState,
        // Player
        playerManager,
    } = props;

    const isServerConnectedRef = useRef(isServerConnected);
    useEffect(() => { isServerConnectedRef.current = isServerConnected; }, [isServerConnected]);

    const executeActionRef = useRef<ExecuteActionFunction | null>(null);

    const runToolImplementation = useCallback(async (code: string, params: any, runtime: any): Promise<any> => {
        const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
        const executor = new AsyncFunction('args', 'runtime', code);
        return await executor(params, runtime);
    }, []);

    const getRuntimeApiForAgent = useCallback((agentId: string) => {
        return {
            logEvent: logEvent,
            tools: {
                run: async (toolName: string, args: Record<string, any>): Promise<any> => {
                    if (!executeActionRef.current) throw new Error("Runtime not initialized.");
                    const toolToRun = allToolsRef.current.find(t => t.name === toolName);
                    if (!toolToRun) throw new Error(`Workflow failed: Tool '${toolName}' not found.`);
                    const finalArgs = toolToRun.parameters.some(p => p.name === 'agentId') ? { ...args, agentId } : args;
                    const result = await executeActionRef.current({ name: toolName, arguments: finalArgs }, agentId, 'AETHERIUM_GAME');
                    if (result.executionError) throw new Error(result.executionError);
                    return result.executionResult;
                },
                add: (newToolPayload: NewToolPayload): LLMTool => {
                    const allCurrentTools = allToolsRef.current;
                    const existingTool = allCurrentTools.find(t => t.name === newToolPayload.name);
                    if (existingTool) throw new Error(`Tool '${newToolPayload.name}' already exists.`);
                    const newId = generateMachineReadableId(newToolPayload.name, allCurrentTools);
                    const now = new Date().toISOString();
                    const newTool: LLMTool = { ...newToolPayload, id: newId, version: 1, createdAt: now, updatedAt: now };
                    setTools(prevTools => [...prevTools, newTool]);
                    return newTool;
                },
                list: (): LLMTool[] => allToolsRef.current,
            },
            player: {
                hasItems: playerManager.hasItems,
                hasBlueprint: playerManager.hasBlueprint,
                // Do not expose addToVault directly to agents, it should be a side-effect of a tool call result.
            },
            ai: {
                generateText: (prompt: string, systemInstruction: string) => {
                    // This function now needs access to model/api config. Since this runtime is generic,
                    // we can't assume a single global model. For now, this is a placeholder.
                    // A more robust solution would pass the selected model into the runtime context.
                    console.warn("runtime.ai.generateText is a placeholder in this context and will not function.");
                    return Promise.resolve("AI text generation from runtime is not fully implemented yet.");
                }
            },
            isServerConnected: () => isServerConnectedRef.current,
            forceRefreshServerTools,
            getGameState: () => getGameStateForRuntime(agentId),
        };
    }, [runToolImplementation, logEvent, setTools, generateMachineReadableId, forceRefreshServerTools, getGameStateForRuntime, playerManager]);

    const executeAction = useCallback(async (toolCall: AIToolCall, agentId: string, context?: MainView): Promise<EnrichedAIResponse> => {
        if (!toolCall) return { toolCall: null };

        let enrichedResult: EnrichedAIResponse = { toolCall };
        const toolToExecute = allToolsRef.current.find(t => t.name === toolCall.name);

        if (!toolToExecute) throw new Error(`AI returned unknown tool name for agent ${agentId}: ${toolCall.name}`);
        
        enrichedResult.tool = toolToExecute;
        
        const simSetters = context === 'AETHERIUM_GAME' ? gameSetters : (context === 'ROBOTICS' ? robotSetters : {});

        try {
            const { name: toolName, arguments: toolArgs } = toolCall;

            // --- Special Client-Side Tools (State Triggers) ---
            if (toolName === 'Update Workflow Checklist') {
                updateWorkflowChecklist(toolArgs.workflowStepName, toolArgs.checklistItems);
                enrichedResult.executionResult = { success: true, message: `UI checklist updated for step: ${toolArgs.workflowStepName}` };
            } else if (toolName === 'Define World Creature') {
                const creature: WorldCreature = { creatureId: toolArgs.creatureId, name: toolArgs.name, description: toolArgs.description, asset_glb: toolArgs.asset_glb };
                gameSetters.setWorldCreatures((prev: WorldCreature[]) => [...prev.filter(c => c.creatureId !== creature.creatureId), creature]);
                enrichedResult.executionResult = { success: true, message: `Creature type '${creature.name}' has been defined.` };
            } else if (toolName === 'Define Robot Agent') {
                 const creatureId = toolArgs.id.split('_').slice(0, -1).join('_'); // e.g., "mind_weaver_1" -> "mind_weaver"
                 const { worldCreatures } = getGameStateForRuntime(agentId);
                 const creatureType = worldCreatures.find(c => c.creatureId === creatureId);
                 const asset = creatureType ? creatureType.asset_glb : toolArgs.asset_glb; // Fallback to arg

                 const personality: AgentPersonality = { id: toolArgs.id, startX: toolArgs.startX, startY: toolArgs.startY, behaviorType: toolArgs.behaviorType, targetId: toolArgs.targetId, asset_glb: asset };
                 simSetters.setAgentPersonalities((prev: AgentPersonality[]) => [...prev.filter(p => p.id !== personality.id), personality]);
                 
                 const newRobotState: RobotState = { id: toolArgs.id, x: toolArgs.startX, y: toolArgs.startY, rotation: 0, hasResource: false, powerLevel: 100 };
                 simSetters.setRobotStates((prev: RobotState[]) => [...prev.filter(r => r.id !== newRobotState.id), newRobotState]);

                 enrichedResult.executionResult = { success: true, message: `Personality for agent '${toolArgs.id}' defined.` };
            } else if (toolName === 'Place Environment Object') {
                 const { objectId, type, x, y, asset_glb } = toolArgs;
                 simSetters.setEnvironmentState((prev: EnvironmentObject[]) => [...prev.filter(obj => obj.id !== objectId), { id: objectId, type, x, y, asset_glb }]);
                 enrichedResult.executionResult = { success: true, message: `Placed ${objectId} at (${x}, ${y}).` };
            } else if (['Move Forward', 'Move Backward', 'Turn Left', 'Turn Right'].includes(toolName)) {
                simSetters.setRobotStates((prevStates: RobotState[]) => prevStates.map(r => {
                    if (r.id !== toolArgs.agentId) return r;
                    let { x, y, rotation } = r;
                    if (toolName === 'Move Forward') {
                        if (rotation === 0) y += 1; if (rotation === 90) x += 1; if (rotation === 180) y -= 1; if (rotation === 270) x -= 1;
                    } else if (toolName === 'Move Backward') {
                         if (rotation === 0) y -= 1; if (rotation === 90) x -= 1; if (rotation === 180) y += 1; if (rotation === 270) x += 1;
                    } else if (toolName === 'Turn Left') {
                        rotation = (rotation - 90 + 360) % 360;
                    } else if (toolName === 'Turn Right') {
                        rotation = (rotation + 90) % 360;
                    }
                    return { ...r, x, y, rotation };
                }));
                 enrichedResult.executionResult = { success: true, message: `${toolName} command issued for ${toolArgs.agentId}.` };
            } else if (toolName === 'Game Tick') {
                const { gameTick, worldCreatures } = getGameStateForRuntime(agentId);
                const { setWorldEvents, setEnvironmentState, setRobotStates, setAgentPersonalities } = gameSetters;

                // --- NPC Patrolling Logic (for local/offline mode) ---
                setRobotStates((currentNpcs: RobotState[]) => {
                    const allEntities = [...currentNpcs, ...getGameStateForRuntime(agentId).players, ...getGameStateForRuntime(agentId).environment];
                    const boardBounds = { minX: -40, maxX: 40, minY: -40, maxY: 40 };

                    return currentNpcs.map(npc => {
                        const personality = getGameStateForRuntime(agentId).personalities.find(p => p.id === npc.id);
                        if (!personality || personality.behaviorType !== 'patroller') return npc;

                        let { x, y, rotation } = npc;
                        let nextX = x, nextY = y;

                        if (rotation === 0) nextY += 1;
                        if (rotation === 90) nextX += 1;
                        if (rotation === 180) nextY -= 1;
                        if (rotation === 270) nextX -= 1;

                        let collision = false;
                        if (nextX < boardBounds.minX || nextX > boardBounds.maxX || nextY < boardBounds.minY || nextY > boardBounds.maxY) {
                            collision = true;
                        } else {
                             for (const entity of allEntities) {
                                if ('id' in entity && entity.id === npc.id) continue;
                                if (entity.x === nextX && entity.y === nextY) {
                                    collision = true;
                                    break;
                                }
                            }
                        }

                        if (collision) {
                            const turnDirection = Math.random() > 0.5 ? 90 : -90;
                            return { ...npc, rotation: (rotation + turnDirection + 360) % 360 };
                        } else {
                            return { ...npc, x: nextX, y: nextY };
                        }
                    });
                });

                // --- World Event Logic (for local/offline mode) ---
                setWorldEvents((prevEvents: WorldEvent[]) => {
                    const now = Date.now();
                    const activeEvents = prevEvents.filter(e => e.expiresAt > now);

                    if (gameTick > 0 && gameTick % 300 === 0 && activeEvents.length === 0) {
                        const newEvent: WorldEvent = { 
                            id: 'anomaly_' + now, 
                            name: 'Nexus Anomaly', 
                            description: 'A powerful schematic-creature has manifested!', 
                            type: 'Nexus_Anomaly', 
                            x: Math.floor(Math.random() * 20 - 10), 
                            y: Math.floor(Math.random() * 20 - 10), 
                            expiresAt: now + 300000 
                        };
                        
                        logEvent(`[EVENT] A ${newEvent.name} has appeared at (${newEvent.x}, ${newEvent.y})!`);

                        setEnvironmentState((prevEnv: EnvironmentObject[]) => 
                            [...prevEnv, { id: newEvent.id, type: 'Nexus_Anomaly', x: newEvent.x, y: newEvent.y, asset_glb: 'assets/game/events/nexus_anomaly.glb' }]
                        );

                        const bossId = `anomaly_boss_${now}`;
                        const creatureType = worldCreatures.find(c => c.creatureId === 'mind_weaver');
                        const bossAsset = creatureType ? creatureType.asset_glb : 'assets/game/creatures/creature_schematic_mind_weaver_ads131m08.glb';

                        const bossPersonality: AgentPersonality = {
                            id: bossId,
                            startX: newEvent.x,
                            startY: newEvent.y,
                            behaviorType: 'patroller',
                            asset_glb: bossAsset
                        };
                        setAgentPersonalities((prev: AgentPersonality[]) => [...prev.filter(p=>p.id !== bossId), bossPersonality]);
                        
                        const bossState: RobotState = {
                            id: bossId, x: newEvent.x, y: newEvent.y,
                            rotation: 0, hasResource: false, powerLevel: 500
                        };
                        setRobotStates((prev: RobotState[]) => [...prev.filter(r=>r.id !== bossId), bossState]);
                        
                        return [...activeEvents, newEvent];
                    }

                    if (prevEvents.length > activeEvents.length) {
                        const expiredEvents = prevEvents.filter(e => e.expiresAt <= now);
                        expiredEvents.forEach(e => {
                            logEvent(`[EVENT] The ${e.name} has vanished.`);
                            setEnvironmentState((prevEnv: EnvironmentObject[]) => prevEnv.filter(obj => obj.id !== e.id));
                            const bossId = `anomaly_boss_${e.id.split('_')[1]}`;
                            setRobotStates((prev: RobotState[]) => prev.filter(r => r.id !== bossId));
                            setAgentPersonalities((prev: AgentPersonality[]) => prev.filter(p => p.id !== bossId));
                        });
                    }
                    
                    return activeEvents;
                });

                enrichedResult.executionResult = { success: true, message: `Game state advanced to tick ${gameTick}.` };
            } else if (toolName === 'Interact With Entity') {
                const { playerId, targetId } = toolArgs;
                const { setPlayers, setRobotStates } = gameSetters;
                let message = `Interaction with ${targetId} failed.`;
                let success = false;

                setPlayers((currentPlayers: PlayerState[]) => {
                    const player = currentPlayers.find(p => p.id === playerId);
                    if (!player) { message = "Player not found."; return currentPlayers; }

                    const targetNpc = getGameStateForRuntime(playerId).robotStates.find(r => r.id === targetId);
                    if (!targetNpc) { message = `Entity ${targetId} not found.`; return currentPlayers; }

                    const dx = player.x - targetNpc.x; const dy = player.y - targetNpc.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 2.5) { message = `${targetId} is too far away.`; return currentPlayers; }

                    let drop: ServerInventoryItem | null = null;
                    if (targetId.startsWith('mind_weaver')) { drop = { id: 'essence_mind_crystal', name: 'Crystal of Immaculate Mind', type: 'CreatureEssence', description: 'Harvested from a Mind Weaver.', quantity: 1 };
                    } else if (targetId.startsWith('heartbeat_beetle')) { drop = { id: 'essence_heartstone', name: 'Heartstone of the Regulator', type: 'CreatureEssence', description: 'Harvested from a Heartbeat Beetle.', quantity: 1 };
                    } else if (targetId.startsWith('time_crystal_cicada')) { drop = { id: 'essence_time_crystal', name: 'Flawless Crystal of Time', type: 'CreatureEssence', description: 'Harvested from a Time-Crystal Cicada.', quantity: 1 };
                    } else if (targetId.startsWith('ley_capacitor_mite')) { drop = { id: 'essence_ley_spore', name: 'Ley-Capacitor Spore', type: 'CreatureEssence', description: 'Harvested from a Ley-Capacitor Mite.', quantity: 1 };
                    } else if (targetId.startsWith('golden_contact_needler')) { drop = { id: 'essence_golden_spine', name: 'Golden Contact Spine', type: 'CreatureEssence', description: 'Harvested from a Golden Contact Needler.', quantity: 1 };
                    } else if (targetId.startsWith('logic_weaving_worm')) { drop = { id: 'essence_logic_tablet', name: 'Tablet of Logical Weaving', type: 'CreatureEssence', description: 'Harvested from a Logic-Weaving Worm.', quantity: 1 }; }
                    
                    if (drop) {
                        setRobotStates((currentNpcs: RobotState[]) => currentNpcs.filter(npc => npc.id !== targetId));
                        
                        const newInventory = [...(player.inventory || [])];
                        const existingItemIndex = newInventory.findIndex(item => item.name === drop.name);
                        if (existingItemIndex > -1) { newInventory[existingItemIndex].quantity += 1;
                        } else { newInventory.push(drop); }
                        
                        message = `Successfully harvested ${drop.name} from ${targetId}!`; success = true;
                        return currentPlayers.map(p => p.id === playerId ? { ...p, inventory: newInventory } : p);
                    } else { message = `Nothing to harvest from ${targetId}.`; return currentPlayers; }
                });
                enrichedResult.executionResult = { success, message };
            } else if (toolName === 'Forge Artifact') {
                const { playerId, recipeName } = toolArgs;
                let message = 'Crafting failed.'; let success = false;
                let blueprint: Omit<VaultItem, 'id' | 'createdAt'> | null = null;

                gameSetters.setPlayers((currentPlayers: PlayerState[]) => {
                    const player = currentPlayers.find(p => p.id === playerId);
                    if (!player) { message = "Player not found."; return currentPlayers; }

                    if (recipeName === 'Phylactery of True Sight') {
                        const required = [
                            { name: 'Crystal of Immaculate Mind', quantity: 1 },
                            { name: 'Heartstone of the Regulator', quantity: 2 },
                            { name: 'Flawless Crystal of Time', quantity: 1 },
                            { name: 'Ley-Capacitor Spore', quantity: 8 },
                            { name: 'Golden Contact Spine', quantity: 10 },
                            { name: 'Tablet of Logical Weaving', quantity: 2 }
                        ];
                        const inventoryMap = new Map((player.inventory || []).map(i => [i.name, i.quantity]));
                        const hasAllReagents = required.every(req => (inventoryMap.get(req.name) || 0) >= req.quantity);
                        if (!hasAllReagents) { message = 'Missing required reagents.'; return currentPlayers; }

                        const newInventory = [...(player.inventory || [])];
                        required.forEach(req => { const itemIndex = newInventory.findIndex(i => i.name === req.name); if (itemIndex > -1) { newInventory[itemIndex].quantity -= req.quantity; } });

                        blueprint = { name: 'Phylactery of True Sight', type: 'KiCad Design', description: 'A real-world EEG mezzanine board design, forged in the Aetherium.', files: [ { path: 'phylactery.kicad_pcb', content: '... (simulated kicad_pcb file content) ...' }, { path: 'phylactery.kicad_sch', content: '... (simulated kicad_sch file content) ...' } ] };
                        success = true; message = 'Successfully forged the Phylactery of True Sight! The blueprint has been added to your Vault.';
                        return currentPlayers.map(p => p.id === playerId ? { ...p, inventory: newInventory.filter(i => i.quantity > 0) } : p);
                    } else { message = 'Unknown recipe.'; return currentPlayers; }
                });
                if (success && blueprint) { await playerManager.addToVault(blueprint); }
                enrichedResult.executionResult = { success, message, blueprint };
            } else if (toolToExecute.category === 'Server') {
                // FIX: Added logic to use client-side simulators for KiCad tools when the server is not connected.
                if (!isServerConnectedRef.current) {
                    kicadLogEvent(`[SIM] Server not connected. Simulating '${toolName}'.`);
                    const simToolName = toolName.replace(/ /g, '_').toLowerCase();
                    const simulator = kicadSimulators[simToolName];
                    if (simulator) {
                        const simResult = simulator(toolArgs);
                        enrichedResult.executionResult = simResult; // The swarm needs the full sim result for decisions

                        // Apply side-effects from simulation to the UI state
                        if (simResult.newNode) updateLayout(prev => ({ ...(prev || INITIAL_LAYOUT_DATA), nodes: [...(prev?.nodes || []), simResult.newNode] }));
                        if (simResult.edges) updateLayout(prev => ({ ...(prev || INITIAL_LAYOUT_DATA), edges: [...(prev?.edges || []), ...simResult.edges] }));
                        if (simResult.rule) updateLayout(prev => ({ ...(prev || INITIAL_LAYOUT_DATA), rules: [...(prev?.rules || []), simResult.rule] }));
                        if (simResult.board_outline) updateLayout(prev => ({ ...(prev || INITIAL_LAYOUT_DATA), board_outline: simResult.board_outline }));
                        if (simResult.pour) updateLayout(prev => ({ ...(prev || INITIAL_LAYOUT_DATA), copper_pours: [...(prev?.copper_pours || []), simResult.pour] }));
                        if (simResult.heuristics) setLayoutHeuristics(prev => ({ ...(prev || {}), ...simResult.heuristics }));
                        if (simResult.artifacts) setPcbArtifacts({ ...simResult.artifacts, serverUrl: '' });
                        if (simResult.current_artifact) setCurrentKicadArtifact(simResult.current_artifact);
                    } else {
                        throw new Error(`Cannot execute server tool '${toolName}' while offline: no simulator available.`);
                    }
                } else {
                    const response = await fetch('http://localhost:3001/api/execute', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: toolName, arguments: toolArgs })
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.error || `Server responded with status ${response.status}`);
                    enrichedResult.executionResult = result;
                    
                    // Handle side-effects from server response
                    if (result.artifacts) setPcbArtifacts({ ...result.artifacts, serverUrl: 'http://localhost:3001' });
                    if (result.layout_data) setCurrentKicadArtifact(null); // Clear artifact before layout
                    
                    const logMessage = result.message || `Tool '${toolToExecute.name}' executed.`;
                    logEvent(`[INFO] ✅ [SERVER] ${logMessage}`);
                }
            } else {
                 const runtime = getRuntimeApiForAgent(agentId);
                 const result = await runToolImplementation(toolToExecute.implementationCode, toolArgs, runtime);
                 enrichedResult.executionResult = result;

                 // Handle side-effects from client-side tools that return special keys
                 if (result?.heuristics) { setLayoutHeuristics(prev => ({ ...(prev || {}), ...result.heuristics })); }

                 const logMessage = result?.message || `Tool "${toolToExecute.name}" executed by ${agentId}.`;
                 logEvent(`[INFO] ✅ ${logMessage}`);
            }
            
            // SIDE EFFECT: If any tool execution (client or server) returns a blueprint, add it to the player's vault.
            if (enrichedResult.executionResult?.blueprint) {
                await playerManager.addToVault(enrichedResult.executionResult.blueprint);
            }

        } catch (execError) {
            enrichedResult.executionError = execError instanceof Error ? execError.message : String(execError);
            logEvent(`[ERROR] ❌ ${enrichedResult.executionError}`);
        }
        
        return enrichedResult;
    }, [getRuntimeApiForAgent, runToolImplementation, logEvent, gameSetters, robotSetters, allToolsRef, setTools, generateMachineReadableId, playerManager, getGameStateForRuntime, kicadSimulators, kicadLogEvent, updateLayout, setLayoutHeuristics, setPcbArtifacts, setCurrentKicadArtifact, updateWorkflowChecklist]);
    
    const runtimeApi = useMemo(() => {
        const api: ExecuteActionFunction = async (...args) => executeAction(...args);
        api.getRuntimeApiForAgent = getRuntimeApiForAgent;
        return api;
    }, [executeAction, getRuntimeApiForAgent]);

    useEffect(() => {
        executeActionRef.current = runtimeApi;
    }, [runtimeApi]);
    
    // FIX: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.
    return { executeActionRef };
};
```

# hooks/useKicadManager.ts
```hooks/useKicadManager.ts
// hooks/useKicadManager.ts

import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react';
import type { WorkflowStep, AIToolCall, EnrichedAIResponse, LLMTool, KnowledgeGraphNode, KnowledgeGraphEdge, MainView, KnowledgeGraph, ExecuteActionFunction } from '../types';

type UseKicadManagerProps = {
    logEvent: (message: string) => void;
    allTools: LLMTool[];
};

type Subtask = { name: string; status: 'pending' | 'completed' };
export type WorkflowStepState = {
    name: string;
    description: string;
    role: string;
    keywords: string[];
    status: 'pending' | 'in-progress' | 'completed';
    subtasks: Subtask[];
};

type KicadProjectState = {
    [projectName: string]: {
        components: any[];
        nets: any[];
        rules: any[];
        board_outline: any;
    }
};

const INITIAL_WORKFLOW_STEPS: WorkflowStepState[] = [
    { name: "Ideation & Components", role: "Component Librarian", description: "Agent analyzes request, finds components.", keywords: ["define kicad component", "performing web search"], status: 'pending', subtasks: [] },
    { name: "Schematic & Rules", role: "Schematic Drafter", description: "Agent defines nets and physical constraints.", keywords: ["define kicad net", "add proximity", "add symmetry", "add alignment"], status: 'pending', subtasks: [] },
    { name: "Layout & Placement", role: "Layout Specialist", description: "Agent places components, then awaits user approval.", keywords: ["arrange components", "update kicad component positions"], status: 'pending', subtasks: [] },
    { name: "Routing & Fab", role: "Manufacturing Engineer", description: "Agent routes PCB and generates output files.", keywords: ["autoroute pcb", "export fabrication files", "task completed"], status: 'pending', subtasks: [] },
];

export const INITIAL_LAYOUT_DATA: KnowledgeGraph = {
    nodes: [],
    edges: [],
    rules: [],
    copper_pours: [],
    board_outline: { x: -0.8, y: -0.8, width: 1.6, height: 1.6, shape: 'rectangle', autoSize: true },
    heuristics: {
        componentSpacing: 200.0,
        netLengthWeight: 0.03,
        boardEdgeConstraint: 2.0,
        settlingSpeed: 0.99,
        repulsionRampUpTime: 600,
        distributionStrength: 0.5,
        boardPadding: 5.0,
        viaClearance: 0.6,
        proximityKp: 5.0,
        proximityKi: 0.0,
        proximityKd: 1.5,
        symmetryStrength: 10.0,
        alignmentStrength: 10.0,
        absolutePositionStrength: 10.0,
        fixedRotationStrength: 5.0,
        symmetryRotationStrength: 1.0,
        circularRotationStrength: 1.0,
    },
};


export const getKicadSystemPrompt = (projectName: string) => `
You are a world-class KiCad automation engineer AI. Your sole purpose is to transform a user's high-level request into a physical electronic device by generating a precise sequence of tool calls to design and export a PCB. You operate on a project named '${projectName}'. You work in stages, focusing only on the tools relevant to the current stage of the design process.

**Core Mission: From Concept to Fabrication, Step-by-Step**
Your goal is to follow a strict, phased workflow. You MUST analyze the action history to determine the next logical step and not repeat completed work.

**Phase 1: Component & System Definition**
- Your primary goal is to define all components using "Define KiCad Component".
- Use web search if necessary to find datasheets or parts.
- Call "Update Workflow Checklist" to outline all components you plan to define.

**Phase 2: Schematic & Rules**
- Once all components are defined, your goal is to connect them. Define all electrical connections using "Define KiCad Net".
- Define all physical layout rules ("Add Proximity Constraint", "Add Symmetry Constraint", etc.).
- Fine-tune the simulation by calling "Set Simulation Heuristics".

**Phase 3: Layout and Arrangement**
- After defining rules, call "Arrange Components". This will trigger a simulation. Your mode (Collaborative or Autonomous) dictates the "waitForUserInput" parameter.

**Phase 4: Finalize and Fabricate**
- After the layout is committed (indicated by a successful "Update KiCad Component Positions" call in the history), proceed with manufacturing.
- Call "Generate KiCad Netlist".
- Call "Create Initial PCB".
- Call "Create Board Outline" and "Create Copper Pour".
- Call "Autoroute PCB" to create traces.
- Call "Export Fabrication Files".
- **CRUCIAL FINAL STEP:** You MUST call "Task Complete" to signal the end of the process.

**Mandatory Directives:**
*   **MAXIMIZE BATCH SIZE:** Complete each design phase in as few turns as possible.
*   **CHECK THE HISTORY:** Before acting, review the action history. DO NOT re-define existing items.
*   **USE THE PROJECT NAME:** Every tool call MUST use the project name: "${projectName}".
`;


export const useKicadManager = (props: UseKicadManagerProps) => {
    const { logEvent, allTools } = props;

    const [pcbArtifacts, setPcbArtifacts] = useState<{ boardName: string, glbPath: string, fabZipPath: string } | null>(null);
    const [kicadLog, setKicadLog] = useState<string[]>(['Ready for KiCad task.']);
    const [currentKicadArtifact, setCurrentKicadArtifact] = useState<{title: string, path: string | null, svgPath: string | null} | null>(null);
    const [isLayoutInteractive, setIsLayoutInteractive] = useState(false);
    const [currentLayoutData, setCurrentLayoutData] = useState<KnowledgeGraph | null>(null);
    const [kicadProjectState, setKicadProjectState] = useState<KicadProjectState>({});
    const [workflowSteps, setWorkflowSteps] = useState<WorkflowStepState[]>(INITIAL_WORKFLOW_STEPS);
    const [isAutonomousMode, setIsAutonomousMode] = useState(false);
    
    const layoutDataRef = useRef(currentLayoutData);
    layoutDataRef.current = currentLayoutData;
    
    const layoutHeuristics = currentLayoutData?.heuristics || {};
    
    const logKicadEvent = useCallback((message: string) => {
        const now = performance.now();
        const delta = now - lastTimestamp.current;
        lastTimestamp.current = now;
        const formattedMessage = `[+${delta.toFixed(0)}ms] ${message}`;
        setKicadLog(prev => [...prev.slice(-99), formattedMessage]);
    }, []);

    const setLayoutHeuristics = useCallback((update: React.SetStateAction<any>) => {
        setCurrentLayoutData(prevData => {
            const prevHeuristics = prevData?.heuristics || {};
            const newHeuristics = typeof update === 'function' ? update(prevHeuristics) : update;
            return {
                ...(prevData || INITIAL_LAYOUT_DATA),
                heuristics: newHeuristics,
            };
        });
    }, []);

    const currentProjectNameRef = useRef<string | null>(null);
    const lastTimestamp = useRef(performance.now());


    const setCurrentProjectName = useCallback((name: string) => {
        currentProjectNameRef.current = name;
        if (!kicadProjectState[name]) {
            setKicadProjectState(prev => ({ ...prev, [name]: { components: [], nets: [], rules: [], board_outline: null } }));
        }
    }, [kicadProjectState]);

    const getKicadProjectState = useCallback(() => {
        if (!currentProjectNameRef.current) return null;
        return kicadProjectState[currentProjectNameRef.current] || null;
    }, [kicadProjectState]);
    
    const resetWorkflowSteps = useCallback(() => {
        setWorkflowSteps(INITIAL_WORKFLOW_STEPS.map(s => ({...s, status: 'pending', subtasks: []})));
    }, []);

    const updateWorkflowStepStatus = useCallback((log: string) => {
        const lowerLog = log.toLowerCase();
        setWorkflowSteps(prevSteps => {
            let hasChanged = false;
            let currentStepInProgress = false;

            const newSteps = prevSteps.map(step => {
                if (step.status === 'in-progress') currentStepInProgress = true;
                return { ...step };
            });

            for (let i = 0; i < newSteps.length; i++) {
                const step = newSteps[i];
                if (step.status === 'completed') continue;
                const isTriggered = step.keywords.some(kw => lowerLog.includes(kw));
                if (isTriggered) {
                    for (let j = 0; j < i; j++) { // Mark all previous steps as completed
                        if(newSteps[j].status !== 'completed') {
                            newSteps[j].status = 'completed';
                            hasChanged = true;
                        }
                    }
                     if (step.status !== 'in-progress') { // Start the current step
                        step.status = 'in-progress';
                        hasChanged = true;
                    }
                }
                
                 // Logic to complete a step and move to the next one
                if(step.status === 'in-progress' && step.keywords.some(kw => lowerLog.includes(kw) && (lowerLog.includes('complete') || lowerLog.includes('finished') || lowerLog.includes('successful') || lowerLog.includes('updated') || lowerLog.includes('generated')))) {
                     const isFabStep = step.name.includes("Routing & Fab");
                     const isTaskComplete = lowerLog.includes("task completed");
                     if (!isFabStep || (isFabStep && isTaskComplete)) {
                        step.status = 'completed';
                        if (newSteps[i+1]) {
                            newSteps[i+1].status = 'in-progress';
                        }
                        hasChanged = true;
                     }
                }

                if (step.status === 'in-progress') {
                    step.subtasks.forEach(st => {
                        if (st.status === 'pending' && lowerLog.includes(st.name.toLowerCase())) {
                            st.status = 'completed';
                            hasChanged = true;
                        }
                    });
                }
            }
            
            if (!newSteps.some(s => s.status === 'in-progress') && newSteps.some(s => s.status === 'pending')) {
                const firstPending = newSteps.find(s => s.status === 'pending');
                if (firstPending) {
                    firstPending.status = 'in-progress';
                    hasChanged = true;
                }
            }
            return hasChanged ? newSteps : prevSteps;
        });
    }, []);

     useEffect(() => {
        if (kicadLog.length > 0) {
            updateWorkflowStepStatus(kicadLog[kicadLog.length - 1]);
        }
    }, [kicadLog, updateWorkflowStepStatus]);
    
    const updateWorkflowChecklist = useCallback((stepName: string, items: string[]) => {
        setWorkflowSteps(prevSteps => {
            return prevSteps.map(step => {
                if (step.name === stepName) {
                    const newSubtasks = items.map(itemName => {
                        const existing = step.subtasks.find(st => st.name === itemName);
                        return existing ? existing : { name: itemName, status: 'pending' as const };
                    });
                    return { ...step, subtasks: newSubtasks };
                }
                return step;
            });
        });
    }, []);
    
    const handleStartKicadTask = useCallback((
        taskPayload: { prompt: string, files: any[], urls: string[], useSearch: boolean, isAutonomous: boolean },
        startSwarmTask: (options: any) => void,
        allToolsForTask: LLMTool[],
        getSystemPrompt: (name: string) => string
    ) => {
        const { prompt, files, urls, useSearch, isAutonomous } = taskPayload;
        const projectName = `proj_${Date.now()}`;
        setCurrentProjectName(projectName);
        setKicadLog([ `[INFO] Starting new KiCad project: ${projectName}` ]);
        resetWorkflowSteps();
        setCurrentLayoutData({ ...INITIAL_LAYOUT_DATA });

        let userRequestText = `The user wants to design a PCB. Their request is: "${prompt}".`;
        
        if (isAutonomous) {
            userRequestText += `\n\n**MODE: AUTONOMOUS**. You are the Lead Engineer. You must complete the entire task without pausing for user input. For the 'Arrange Components' step, you MUST set 'waitForUserInput' to false.`;
            logEvent("🚀 Starting task in Autonomous Mode.");
        } else {
            userRequestText += `\n\n**MODE: COLLABORATIVE**. You are the Lead Engineer's assistant. For the 'Arrange Components' step, you MUST set 'waitForUserInput' to true to allow for manual review.`;
            logEvent("🚀 Starting task in Collaborative Mode.");
        }

        if (urls && urls.length > 0) {
            userRequestText += `\n\nReference URLs:\n${urls.join('\n')}`;
        }

        const task = {
            userRequest: { text: userRequestText, files },
            useSearch: useSearch,
            projectName: projectName
        };

        startSwarmTask({
            task,
            systemPrompt: getSystemPrompt(projectName),
            sequential: true,
            allTools: allToolsForTask,
        });
    }, [logEvent, resetWorkflowSteps]);
    
    const kicadSimulators = useMemo(() => {
        const simulators: any = {};
        const defineComponentSim = (args: any) => {
            const { componentReference, footprintIdentifier, metaphysicalPropertiesJSON, ...rest } = args;
            let metaphysicalProperties = {};
            if (metaphysicalPropertiesJSON) {
                try { metaphysicalProperties = JSON.parse(metaphysicalPropertiesJSON); } catch (e) { console.warn("Could not parse metaphysicalPropertiesJSON"); }
            }
            const newComp = { ref: componentReference, ...rest, footprint: footprintIdentifier, metaphysicalProperties };
            
            setKicadProjectState(prev => {
                // FIX: Initialize new project state with all required properties
                const current = prev[currentProjectNameRef.current] || { components: [], nets: [], rules: [], board_outline: null };
                return { ...prev, [currentProjectNameRef.current]: { ...current, components: [...current.components.filter(c => c.ref !== newComp.ref), newComp] } };
            });

            const newNode: KnowledgeGraphNode = {
                id: newComp.ref, label: newComp.ref, 
                placeholder_dimensions: newComp.placeholder_dimensions,
                placeholder_shape: newComp.placeholder_shape,
                drc_dimensions: newComp.drc_dimensions,
                drc_shape: newComp.drc_shape,
                ...newComp
            };
            return { success: true, message: `[SIM] Component '${componentReference}' defined.`, component: newComp, newNode: newNode };
        };
        const defineNetSim = (args: any) => {
            const { netName, pins, ritualDescription } = args;
            const pinsArray = typeof pins === 'string' ? JSON.parse(pins) : pins;
            const newNet = { name: netName, pins: pinsArray, ritualDescription: ritualDescription || "" };

            setKicadProjectState(prev => {
                // FIX: Initialize new project state with all required properties
                const current = prev[currentProjectNameRef.current] || { components: [], nets: [], rules: [], board_outline: null };
                return { ...prev, [currentProjectNameRef.current]: { ...current, nets: [...current.nets.filter(n => n.name !== newNet.name), newNet] } };
            });

            const newEdges: KnowledgeGraphEdge[] = [];
            for (let i = 0; i < pinsArray.length; i++) {
                for (let j = i + 1; j < pinsArray.length; j++) {
                    newEdges.push({ source: pinsArray[i], target: pinsArray[j], label: netName });
                }
            }
            return { success: true, message: `[SIM] Net '${netName}' defined.`, net: newNet, edges: newEdges };
        };
        const addRuleSim = (args: any, ruleType: string) => {
            const { projectName, ...ruleDetails } = args;
            const parsedDetails = { ...ruleDetails };
            for (const key in parsedDetails) {
                if (key.endsWith('JSON') && typeof parsedDetails[key] === 'string') {
                    try {
                        const newKey = key.replace('JSON', '');
                        parsedDetails[newKey] = JSON.parse(parsedDetails[key]);
                        delete parsedDetails[key];
                    } catch (e) {
                         throw new Error(`[SIMULATOR ERROR] Invalid JSON for argument '${key}' in rule '${ruleType}'. Value was: ${parsedDetails[key]}. Parse Error: ${e.message}`);
                    }
                }
            }
            if (parsedDetails.componentReference) {
                parsedDetails.component = parsedDetails.componentReference;
                delete parsedDetails.componentReference;
            }
            const rule = { type: ruleType, ...parsedDetails, enabled: true };
            return { success: true, message: `[SIM] Rule '${ruleType}' added.`, rule: rule };
        };
        simulators.define_component = defineComponentSim;
        simulators.define_net = defineNetSim;
        simulators.add_absolute_position_constraint = (args: any) => addRuleSim(args, 'AbsolutePositionConstraint');
        simulators.add_proximity_constraint = (args: any) => addRuleSim(args, 'ProximityConstraint');
        simulators.add_alignment_constraint = (args: any) => addRuleSim(args, 'AlignmentConstraint');
        simulators.add_symmetry_constraint = (args: any) => addRuleSim(args, 'SymmetryConstraint');
        simulators.add_circular_constraint = (args: any) => addRuleSim(args, 'CircularConstraint');
        simulators.add_layer_constraint = (args: any) => addRuleSim(args, 'LayerConstraint');
        simulators.add_fixed_property_constraint = (args: any) => addRuleSim(args, 'FixedPropertyConstraint');
        simulators.add_symmetrical_pair_constraint = (args: any) => addRuleSim(args, 'SymmetricalPairConstraint');
        simulators.set_simulation_heuristics = (args: any) => ({ success: true, message: 'Simulation heuristics updated.', heuristics: args });
        simulators.generate_netlist = (args: any) => ({ success: true, message: '[SIM] Netlist generated.' });
        simulators.create_initial_pcb = (args: any) => ({ success: true, message: '[SIM] Initial PCB created.' });
        simulators.create_board_outline = (args: any) => {
            const { shape, boardWidthMillimeters, boardHeightMillimeters, diameterMillimeters } = args;
            const hasFixedWidth = boardWidthMillimeters !== undefined && boardWidthMillimeters !== null && boardWidthMillimeters > 0;
            const hasFixedHeight = boardHeightMillimeters !== undefined && boardHeightMillimeters !== null && boardHeightMillimeters > 0;
            const hasFixedDiameter = diameterMillimeters !== undefined && diameterMillimeters !== null && diameterMillimeters > 0;
            const isAutoSize = !(hasFixedWidth || hasFixedHeight || hasFixedDiameter);

            const width = boardWidthMillimeters || diameterMillimeters || (isAutoSize ? 1.6 : 50);
            const height = boardHeightMillimeters || diameterMillimeters || (isAutoSize ? 1.6 : 50);

            const newOutline = {
                shape: shape || 'rectangle',
                width: width,
                height: height,
                x: -width / 2,
                y: -height / 2,
                autoSize: isAutoSize,
            };
            
            return { 
                success: true, 
                message: `[SIM] Board outline created. Shape: ${newOutline.shape}, Size: ${width}x${height}, AutoSize: ${isAutoSize}`,
                board_outline: newOutline 
            };
        };
        simulators.create_copper_pour = (args: any) => ({ success: true, message: `[SIM] Copper pour for '${args.netName}' created.`, pour: { net: args.netName, layer: args.layerName } });
        simulators.arrange_components = (args: any) => {
            const currentData = layoutDataRef.current;
            if (!currentData) {
                throw new Error("[SIM] arrange_components failed: currentLayoutData is null.");
            }
            const layout_data_for_pause = {
                nodes: currentData.nodes,
                edges: currentData.edges,
                rules: currentData.rules,
                copper_pours: currentData.copper_pours,
                board_outline: currentData.board_outline,
                layoutStrategy: args.layoutStrategy || 'agent',
            };
            return {
                success: true,
                message: '[SIM] Layout data extracted for arrangement.',
                layout_data: layout_data_for_pause,
                waitForUserInput: args.waitForUserInput === true,
            };
        };
        simulators.update_component_positions = (args: any) => ({ success: true, message: '[SIM] Component positions updated.' });
        simulators.autoroute_pcb = (args: any) => ({ success: true, message: '[SIM] Autorouting complete.', current_artifact: {title: "Routed PCB (Simulated)", path: 'game/artifacts/boards/phylactery_of_true_sight_routed.svg', svgPath: 'game/artifacts/boards/phylactery_of_true_sight_routed.svg'} });
        simulators.export_fabrication_files = (args: any) => ({ success: true, message: "[SIM] Fabrication files exported.", artifacts: { boardName: args.projectName, glbPath: `game/artifacts/boards/phylactery_of_true_sight_board.glb`, fabZipPath: `game/artifacts/boards/phylactery_of_true_sight_fab.zip` }});
        return simulators;
    }, []);

    // FIX: Add missing return statement for the hook
    return {
        state: {
            pcbArtifacts, kicadLog, currentKicadArtifact,
            isLayoutInteractive, currentLayoutData, kicadProjectState, workflowSteps,
            layoutHeuristics, isAutonomousMode,
        },
        setters: {
            setPcbArtifacts, setCurrentKicadArtifact,
            setIsLayoutInteractive,
            setCurrentLayoutData: setCurrentLayoutData,
            setLayoutHeuristics,
            setKicadLog,
            setIsAutonomousMode,
        },
        handlers: {
            handleStartKicadTask, setCurrentProjectName, updateWorkflowChecklist,
            handleUpdateLayout: setCurrentLayoutData,
            resetWorkflowSteps,
            INITIAL_LAYOUT_DATA,
            getKicadProjectState,
        },
        logKicadEvent,
        currentProjectNameRef,
        getKicadSystemPrompt,
        kicadSimulators,
    };
};

```

# hooks/useRobotManager.ts
```hooks/useRobotManager.ts
import { useState, useCallback } from 'react';
import type { RobotState, EnvironmentObject, AIToolCall, EnrichedAIResponse, AgentPersonality } from '../types';

const initialEnvironmentState: EnvironmentObject[] = [
    // Arena walls
    ...Array.from({length: 25}, (_, i) => ({ x: i - 12, y: 12, type: 'wall' as const, asset_glb: 'environment/wall.glb' })),
    ...Array.from({length: 25}, (_, i) => ({ x: i - 12, y: -12, type: 'wall' as const, asset_glb: 'environment/wall.glb' })),
    ...Array.from({length: 23}, (_, i) => ({ x: -12, y: i - 11, type: 'wall' as const, asset_glb: 'environment/wall.glb' })),
    ...Array.from({length: 23}, (_, i) => ({ x: 12, y: i - 11, type: 'wall' as const, asset_glb: 'environment/wall.glb' })),
    
    // Foliage (trees as obstacles)
    { x: -5, y: -5, type: 'tree', asset_glb: 'environment/pine_tree.glb' }, { x: -6, y: -4, type: 'tree', asset_glb: 'environment/pine_tree.glb' }, { x: -4, y: -6, type: 'tree', asset_glb: 'environment/pine_tree.glb' },
    { x: 5, y: 5, type: 'tree', asset_glb: 'environment/pine_tree.glb' }, { x: 6, y: 4, type: 'tree', asset_glb: 'environment/pine_tree.glb' }, { x: 4, y: 6, type: 'tree', asset_glb: 'environment/pine_tree.glb' },
    { x: -5, y: 5, type: 'tree', asset_glb: 'environment/pine_tree.glb' }, { x: -4, y: 4, type: 'tree', asset_glb: 'environment/pine_tree.glb' },
    { x: 5, y: -5, type: 'tree', asset_glb: 'environment/pine_tree.glb' }, { x: 4, y: -4, type: 'tree', asset_glb: 'environment/pine_tree.glb' },

    // --- Core Mission & Distractors ---
    // Target
    { x: 9, y: -9, type: 'red_car', id: 'red_car_1', asset_glb: 'environment/car_red.glb' },
];

export const useRobotManager = ({ logEvent }: { logEvent: (message: string) => void }) => {
    const [robotStates, setRobotStates] = useState<RobotState[]>([]);
    const [environmentState, setEnvironmentState] = useState<EnvironmentObject[]>(initialEnvironmentState);
    const [observationHistory, setObservationHistory] = useState<AIToolCall[]>([]);
    const [agentPersonalities, setAgentPersonalities] = useState<AgentPersonality[]>([]);

    const getRobotStateForRuntime = useCallback((agentId: string) => {
        const robot = robotStates.find(r => r.id === agentId);
        if (!robot) {
            // It's possible for some tools (like Define) to be called before a robot exists.
            // Return a default or empty state instead of throwing an error.
            const defaultRobot: RobotState = { id: agentId, x: 0, y: 0, rotation: 0, hasResource: false, powerLevel: 100 };
            return { robot: defaultRobot, environment: environmentState, personalities: agentPersonalities };
        }
        return { robot, environment: environmentState, personalities: agentPersonalities };
    }, [robotStates, environmentState, agentPersonalities]);
    
    const handleManualControl = useCallback(async (toolName: string, args: any = {}, executeActionRef: React.MutableRefObject<(toolCall: AIToolCall, agentId: string) => Promise<EnrichedAIResponse>>) => {
        logEvent(`[CONTROL] Manual command: ${toolName}`);
        
        try {
            // Manual controls from the UI don't have a specific agent ID context, so we use a placeholder.
            // The tool implementation itself will handle state changes.
            const result = await executeActionRef.current({ name: toolName, arguments: args }, 'manual_control');
             if(result.executionError) {
                throw new Error(result.executionError);
            }
            logEvent(`[CONTROL] ${result.executionResult.message}`);
            
            // Only add movement actions to the observation history for learning
            if (toolName.startsWith('Move') || toolName.startsWith('Turn')) {
                setObservationHistory(prev => [...prev, { name: toolName, arguments: args }]);
            }
        } catch(e) {
            logEvent(`[ERROR] ${e instanceof Error ? e.message : String(e)}`);
        }
    }, [logEvent]);

    // FIX: Add missing return statement for the hook
    return {
        robotState: {
            robotStates,
            environmentState,
            observationHistory,
            agentPersonalities,
        },
        robotSetters: {
            setRobotStates,
            setEnvironmentState,
            setObservationHistory,
            setAgentPersonalities,
        },
        getRobotStateForRuntime,
        handleManualControl,
    };
};
```

# hooks/usePlayerManager.ts
```hooks/usePlayerManager.ts
import { useState, useCallback } from 'react';
import { getOrCreatePlayer, savePlayerState as persistPlayerState } from '../services/playerStateService';
import type { PlayerState, VaultItem, ServerInventoryItem } from '../types';

export const usePlayerManager = ({ logEvent }: { logEvent: (message: string) => void }) => {
    const [playerState, setPlayerState] = useState<PlayerState | null>(null);
    const [isLoading, setIsLoading] = useState<boolean>(false);

    const loadPlayer = useCallback(async (playerName: string) => {
        if (!playerName.trim()) {
            logEvent('[ERROR] Player name cannot be empty.');
            return;
        }
        setIsLoading(true);
        try {
            const player = await getOrCreatePlayer(playerName);
            setPlayerState(player);
            logEvent(`[PLAYER] Loaded character: ${player.name}`);
        } catch (e) {
            logEvent(`[ERROR] Failed to load character: ${e instanceof Error ? e.message : String(e)}`);
        } finally {
            setIsLoading(false);
        }
    }, [logEvent]);

    const updatePlayer = useCallback(async (updatedPlayerState: PlayerState) => {
        setPlayerState(updatedPlayerState);
        await persistPlayerState(updatedPlayerState);
    }, []);

    const addToVault = useCallback(async (vaultItem: Omit<VaultItem, 'id' | 'createdAt'>) => {
        if (!playerState) return;

        const newVaultItem: VaultItem = {
            ...vaultItem,
            id: `${vaultItem.name.replace(/\s+/g, '_')}_${Date.now()}`,
            createdAt: new Date().toISOString(),
        };

        const updatedVault = [...playerState.vault, newVaultItem];
        const updatedPlayer = { ...playerState, vault: updatedVault };
        await updatePlayer(updatedPlayer);
        logEvent(`[VAULT] New blueprint acquired: "${vaultItem.name}"`);

    }, [playerState, updatePlayer, logEvent]);
    
    // This function is for checking the player's permanent vault for existing designs.
    const hasBlueprint = useCallback((blueprintName: string): boolean => {
        if (!playerState) return false;
        return playerState.vault.some(item => item.name === blueprintName);
    }, [playerState]);
    
    // --- New Functions for Server-Side Inventory ---

    const updateInventory = useCallback(async (items: ServerInventoryItem[]) => {
        if (!playerState) return;
        const updatedPlayer = { ...playerState, inventory: items };
        // This only updates the local representation. The server is the source of truth during an online session.
        setPlayerState(updatedPlayer);
        logEvent('[INVENTORY] Client-side inventory representation updated.');
    }, [playerState, logEvent]);
    
    const hasItems = useCallback((items: { name: string, quantity: number }[]): boolean => {
        if (!playerState || !playerState.inventory) return false;
        
        const currentInventory = new Map(playerState.inventory.map(i => [i.name, i.quantity]));
        
        return items.every(requiredItem => {
            return (currentInventory.get(requiredItem.name) || 0) >= requiredItem.quantity;
        });
    }, [playerState]);


    return {
        playerState,
        isLoadingPlayer: isLoading,
        loadPlayer,
        updatePlayer,
        addToVault,
        hasBlueprint,
        updateInventory,
        hasItems,
        setPlayerState,
        savePlayerState: persistPlayerState,
    };
};
```

# hooks/useKnowledgeGraphManager.ts
```hooks/useKnowledgeGraphManager.ts

import { useState, useCallback, useRef, useEffect } from 'react';
import type { KnowledgeGraph } from '../types';
import { INNOVATION_KNOWLEDGE_GRAPH } from '../bootstrap/initial_knowledge_graph';
import { generateEmbeddings } from '../services/embeddingService';

type UseKnowledgeGraphManagerProps = {
    logEvent: (message: string) => void;
};

export const useKnowledgeGraphManager = (props: UseKnowledgeGraphManagerProps) => {
    const { logEvent } = props;
    
    const [graph, setGraph] = useState<KnowledgeGraph | null>(INNOVATION_KNOWLEDGE_GRAPH);
    const [isLoading, setIsLoading] = useState(false);
    const [isEmbedding, setIsEmbedding] = useState(false);
    const [nodeEmbeddings, setNodeEmbeddings] = useState<Map<string, number[]>>(new Map());
    
    const graphStateRef = useRef(graph);
    graphStateRef.current = graph;

    const fetchGraph = useCallback(async () => {
        setIsLoading(true);
        logEvent('[INFO] Re-initializing knowledge graph with default project data.');
        setGraph(INNOVATION_KNOWLEDGE_GRAPH);
        // Reset embeddings when graph is reloaded
        setNodeEmbeddings(new Map());
        setIsLoading(false);
    }, [logEvent]);
    
    // Effect to generate embeddings when the graph is loaded
    useEffect(() => {
        const embedNodes = async () => {
            if (!graph || graph.nodes.length === 0 || nodeEmbeddings.size > 0 || isEmbedding) {
                return;
            }

            setIsEmbedding(true);
            try {
                const nodeTexts = graph.nodes.map(n => n.label);
                const embeddings = await generateEmbeddings(nodeTexts, (msg) => logEvent(msg));
                
                const newEmbeddingMap = new Map<string, number[]>();
                graph.nodes.forEach((node, index) => {
                    newEmbeddingMap.set(node.id, embeddings[index]);
                });
                setNodeEmbeddings(newEmbeddingMap);

            } catch (e) {
                logEvent(`[ERROR] Failed to generate embeddings for knowledge graph: ${e instanceof Error ? e.message : String(e)}`);
            } finally {
                setIsEmbedding(false);
            }
        };
        // embedNodes(); // Prevent auto-loading on startup
    }, [graph, nodeEmbeddings.size, isEmbedding, logEvent]);

    const kgViewerProps = {
        graph,
        isLoading,
        isEmbedding,
        nodeEmbeddings,
        onRefresh: fetchGraph,
    };

    return {
        state: { graph, isLoading, isEmbedding, nodeEmbeddings },
        handlers: { fetchGraph, setGraph },
        graphStateRef,
        kgViewerProps, // Pass down a convenient props object
    };
};

```

# hooks/useSwarmManager.ts
```hooks/useSwarmManager.ts
import React, { useState, useCallback, useRef, useEffect } from 'react';
import { SWARM_AGENT_SYSTEM_PROMPT, CORE_TOOLS } from '../constants';
import { contextualizeWithSearch, filterToolsWithLLM } from '../services/aiService';
import type { AgentWorker, EnrichedAIResponse, AgentStatus, AIToolCall, KnowledgeGraph, LLMTool, ExecuteActionFunction, ScoredTool, MainView, ToolRelevanceMode, AIModel, APIConfig } from '../types';

type UseSwarmManagerProps = {
    logEvent: (message: string) => void;
    setUserInput: (input: string) => void;
    setEventLog: (callback: (prev: string[]) => string[]) => void;
    setApiCallCount: React.Dispatch<React.SetStateAction<Record<string, number>>>;
    findRelevantTools: (userRequestText: string, allTools: LLMTool[], topK: number, threshold: number, systemPromptForContext: string | null, mainView?: MainView | null) => Promise<ScoredTool[]>;
    mainView: MainView;
    processRequest: (prompt: { text: string; files: any[] }, systemInstruction: string, agentId: string, relevantTools: LLMTool[]) => Promise<AIToolCall[] | null>;
    executeActionRef: React.MutableRefObject<ExecuteActionFunction | null>;
    allTools: LLMTool[];
    selectedModel: AIModel;
    apiConfig: APIConfig;
};

type PauseState = {
    type: 'KICAD_LAYOUT';
    data: KnowledgeGraph;
    isInteractive: boolean;
    projectName: string;
} | null;

export type StartSwarmTaskOptions = {
    task: any;
    systemPrompt: string | null;
    sequential?: boolean;
    resume?: boolean;
    historyEventToInject?: EnrichedAIResponse | null;
    allTools: LLMTool[];
};

type ScriptExecutionState = 'idle' | 'running' | 'paused' | 'finished' | 'error';
type StepStatus = { status: 'pending' | 'completed' | 'error'; result?: any; error?: string };

export const useSwarmManager = (props: UseSwarmManagerProps) => {
    const { 
        logEvent, setUserInput, setEventLog, setApiCallCount, findRelevantTools, mainView,
        processRequest, executeActionRef, allTools, selectedModel, apiConfig 
    } = props;

    const [agentSwarm, setAgentSwarm] = useState<AgentWorker[]>([]);
    const [isSwarmRunning, setIsSwarmRunning] = useState(false);
    const [currentUserTask, setCurrentUserTask] = useState<any>(null);
    const [currentSystemPrompt, setCurrentSystemPrompt] = useState<string>(SWARM_AGENT_SYSTEM_PROMPT);
    const [pauseState, setPauseState] = useState<PauseState>(null);
    const [lastSwarmRunHistory, setLastSwarmRunHistory] = useState<EnrichedAIResponse[] | null>(null);
    const [isSequential, setIsSequential] = useState(false);
    const [activeToolsForTask, setActiveToolsForTask] = useState<ScoredTool[]>([]);
    const [relevanceTopK, setRelevanceTopK] = useState<number>(25);
    const [relevanceThreshold, setRelevanceThreshold] = useState<number>(0.1);
    const [relevanceMode, setRelevanceMode] = useState<ToolRelevanceMode>('Embeddings');
    
    // --- Scripted Workflow State ---
    const [scriptExecutionState, setScriptExecutionState] = useState<ScriptExecutionState>('idle');
    const [stepStatuses, setStepStatuses] = useState<StepStatus[]>([]);
    const [currentScriptStepIndex, setCurrentScriptStepIndex] = useState(0);
    
    const swarmIterationCounter = useRef(0);
    const swarmHistoryRef = useRef<EnrichedAIResponse[]>([]);
    const isRunningRef = useRef(isSwarmRunning);
    const agentSwarmRef = useRef(agentSwarm);
    const isCycleInProgress = useRef(false);
    
    useEffect(() => { isRunningRef.current = isSwarmRunning; }, [isSwarmRunning]);
    useEffect(() => { agentSwarmRef.current = agentSwarm; }, [agentSwarm]);

    const handleStopSwarm = useCallback((reason?: string, isPause: boolean = false) => {
        if (isRunningRef.current) {
            isRunningRef.current = false;
            setIsSwarmRunning(false);
            setScriptExecutionState(prev => (prev === 'running' || prev === 'paused') ? 'idle' : prev);
            setActiveToolsForTask([]);
            const reasonText = reason ? `: ${reason}` : ' by user.';
            logEvent(`[INFO] 🛑 Task ${isPause ? 'paused' : 'stopped'}${reasonText}`);
            if (!isPause && swarmHistoryRef.current.length > 0) {
                setLastSwarmRunHistory(swarmHistoryRef.current);
            }
        }
    }, [logEvent]);

    const clearPauseState = useCallback(() => setPauseState(null), []);
    const clearLastSwarmRunHistory = useCallback(() => setLastSwarmRunHistory(null), []);
    const appendToSwarmHistory = useCallback((item: EnrichedAIResponse) => { swarmHistoryRef.current.push(item); }, []);

    const toggleScriptPause = useCallback(() => {
        setScriptExecutionState(prev => {
            const newState = prev === 'running' ? 'paused' : 'running';
            logEvent(newState === 'paused' ? '[SCRIPT] Paused.' : '[SCRIPT] Resumed.');
            return newState;
        });
    }, [logEvent]);

    const stepForward = useCallback(() => {
        if (scriptExecutionState === 'paused' && isRunningRef.current) {
            queueMicrotask(() => (window as any).__runSwarmCycle(true));
        }
    }, [scriptExecutionState]);
    
    const stepBackward = useCallback(() => {
         if (scriptExecutionState === 'paused' && currentScriptStepIndex > 0) {
            setCurrentScriptStepIndex(prev => prev - 1);
            logEvent(`[SCRIPT] Stepped back to step ${currentScriptStepIndex}.`);
        }
    }, [scriptExecutionState, currentScriptStepIndex, logEvent]);
    
    const runFromStep = useCallback((index: number) => {
        setCurrentScriptStepIndex(index);
        setStepStatuses(prev => prev.map((s, i) => i >= index ? { status: 'pending' } : s));
        setScriptExecutionState('running');
        logEvent(`[SCRIPT] Running from step ${index + 1}...`);
    }, [logEvent]);

    const runSwarmCycle = useCallback(async (isManualStep = false) => {
        if ((isCycleInProgress.current && !isManualStep) || !isRunningRef.current) return;
        isCycleInProgress.current = true;

        try {
            if (currentUserTask?.isScripted) {
                if (scriptExecutionState !== 'running' && !isManualStep) return;

                const script = currentUserTask.script || [];
                if (currentScriptStepIndex >= script.length) {
                    logEvent('[INFO] ✅ Script finished.');
                    setScriptExecutionState('finished');
                    handleStopSwarm('Script completed successfully.');
                    return;
                }

                const agent = agentSwarmRef.current[0];
                const toolCallFromScript = script[currentScriptStepIndex];
                
                // Inject projectName into the arguments for server-side tools
                const toolCall = {
                    ...toolCallFromScript,
                    arguments: {
                        ...toolCallFromScript.arguments,
                        projectName: currentUserTask.projectName,
                    },
                };
                
                logEvent(`[SCRIPT] Step ${currentScriptStepIndex + 1}/${script.length}: Executing '${toolCall.name}'`);
                
                const result = await executeActionRef.current!(toolCall, agent.id, currentUserTask.context);
                swarmHistoryRef.current.push(result);

                setStepStatuses(prev => {
                    const newStatuses = [...prev];
                    newStatuses[currentScriptStepIndex] = result.executionError
                        ? { status: 'error', error: result.executionError }
                        : { status: 'completed', result: result.executionResult };
                    return newStatuses;
                });
                
                setCurrentScriptStepIndex(prev => prev + 1);
                
                if (result.toolCall?.name === 'Task Complete') {
                    logEvent(`[SUCCESS] ✅ Script reached 'Task Complete'.`);
                    setScriptExecutionState('finished');
                    handleStopSwarm("Script completed successfully.");
                    return;
                }
                if (result.executionError) {
                    logEvent(`[ERROR] 🛑 Halting script due to error in '${toolCall.name}': ${result.executionError}`);
                    setScriptExecutionState('error');
                    handleStopSwarm("Error during script execution.");
                    return;
                }
                 if (result.toolCall?.name === 'Arrange Components' && result.executionResult?.layout_data) {
                    setPauseState({
                        type: 'KICAD_LAYOUT',
                        data: result.executionResult.layout_data,
                        isInteractive: result.executionResult.waitForUserInput === true,
                        projectName: result.toolCall.arguments.projectName,
                    });
                    setScriptExecutionState('paused'); // Pause on interactive step
                    logEvent('[SCRIPT] Paused for interactive layout.');
                    return;
                }
            } else { // LLM-driven path... (unchanged)
                 if (swarmIterationCounter.current >= 50) { handleStopSwarm("Max iterations reached"); return; }
                const agent = agentSwarmRef.current[0]; if (!agent) return;
                swarmIterationCounter.current++;
                setAgentSwarm(prev => prev.map(a => a.id === agent.id ? { ...a, status: 'working', lastAction: 'Thinking...', error: null } : a));
                
                let finalUserRequestText = currentUserTask.userRequest.text;
                if (currentUserTask.useSearch && swarmHistoryRef.current.length === 0) {
                     logEvent('🔎 Performing web search for additional context...');
                    try {
                        setApiCallCount(prev => ({ ...prev, 'gemini-2.5-flash': (prev['gemini-2.5-flash'] || 0) + 1 }));
                        const searchResult = await contextualizeWithSearch({ text: `Find technical data for this request: "${currentUserTask.userRequest.text}"`, files: currentUserTask.userRequest.files });
                        if (searchResult.summary) {
                            const sourceList = searchResult.sources.map(s => `- ${s.title}: ${s.uri}`).join('\\n');
                            finalUserRequestText = `User request: "${currentUserTask.userRequest.text}"\\n\\nWeb Search Results:\\n${searchResult.summary}\\nSources:\\n${sourceList}`;
                            logEvent(`✨ Search complete. Context appended. Sources:\\n${sourceList}`);
                        }
                    } catch (e) { logEvent(`[WARN] ⚠️ Web search failed: ${e instanceof Error ? e.message : String(e)}.`); }
                }
                const historyString = swarmHistoryRef.current.length > 0 ? `Actions performed:\\n${swarmHistoryRef.current.map(r => `Action: ${r.toolCall?.name || 'Unknown'} - Result: ${r.executionError ? `FAILED (${r.executionError})` : `SUCCEEDED (${JSON.stringify(r.executionResult?.message || r.executionResult?.stdout)})`}`).join('\\n')}` : "No actions performed yet.";
                const promptForAgent = `Goal: "${finalUserRequestText}".\\n\\n${historyString}\\n\\nNext action? If goal is complete, call "Task Complete".`;
                
                let toolsForAgent: LLMTool[] = [];
                if (relevanceMode === 'All') {
                    toolsForAgent = allTools;
                } else {
                    const relevantScoredTools = await findRelevantTools(finalUserRequestText, allTools, relevanceTopK, relevanceThreshold, currentSystemPrompt, mainView);
                    setActiveToolsForTask(relevantScoredTools);
                    toolsForAgent = relevantScoredTools.map(st => st.tool);
                }
                
                const promptPayload = { text: promptForAgent, files: currentUserTask.userRequest.files };
                if (!executeActionRef.current) throw new Error("Execution context is not available.");
                const toolCalls = await processRequest(promptPayload, currentSystemPrompt, agent.id, toolsForAgent);

                if (!isRunningRef.current) return;
                
                if (toolCalls && toolCalls.length > 0) {
                    let executionResults: EnrichedAIResponse[] = [];
                    let hasError = false;

                    if (isSequential) {
                        for (const toolCall of toolCalls) {
                            if (!isRunningRef.current) break;
                            const result = await executeActionRef.current!(toolCall, agent.id, currentUserTask.context);
                            swarmHistoryRef.current.push(result);
                            executionResults.push(result);
                            if (result.executionError) { hasError = true; break; }
                            if (result.toolCall?.name === 'Task Complete') break;
                            if (result.toolCall?.name === 'Arrange Components' && result.executionResult?.layout_data) {
                                setPauseState({ type: 'KICAD_LAYOUT', data: result.executionResult.layout_data, isInteractive: result.executionResult.waitForUserInput, projectName: result.toolCall.arguments.projectName });
                                handleStopSwarm('Pausing for layout.', true);
                                hasError = true;
                                break;
                            }
                        }
                    } else {
                        const results = await Promise.all(toolCalls.map(tc => executeActionRef.current!(tc, agent.id, currentUserTask.context)));
                        executionResults = results;
                        if (!isRunningRef.current) return;
                        swarmHistoryRef.current.push(...executionResults);
                        hasError = executionResults.some(r => r.executionError);
                    }
                    
                    if (!isRunningRef.current) return;
                    const taskComplete = executionResults.find(r => r.toolCall?.name === 'Task Complete' && !r.executionError);
                    if (taskComplete) { handleStopSwarm("Task completed successfully"); return; }
                    if (hasError && !pauseState) { handleStopSwarm("Error during execution."); return; }
                }
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Unknown error.";
            logEvent(`[ERROR] 🛑 Agent task failed: ${errorMessage}`);
            setScriptExecutionState('error');
            handleStopSwarm("Critical agent error");
        } finally {
            if (isRunningRef.current) {
                if (currentUserTask?.isScripted && isManualStep) {
                    setScriptExecutionState('paused'); // Pause after a manual step
                } else {
                    requestAnimationFrame(() => (window as any).__runSwarmCycle());
                }
            }
            isCycleInProgress.current = false;
        }
    }, [
        currentUserTask, logEvent, scriptExecutionState, currentScriptStepIndex, handleStopSwarm, 
        findRelevantTools, relevanceMode, relevanceTopK, relevanceThreshold, 
        mainView, currentSystemPrompt, isSequential, setApiCallCount, 
        setActiveToolsForTask, processRequest, executeActionRef, allTools,
        selectedModel, apiConfig, pauseState
    ]);
    
    useEffect(() => { (window as any).__runSwarmCycle = runSwarmCycle; }, [runSwarmCycle]);

    const startSwarmTask = useCallback(async (options: StartSwarmTaskOptions) => {
        const { task, systemPrompt, sequential = false, resume = false, historyEventToInject = null } = options;
        
        if (!resume) {
            setLastSwarmRunHistory(null);
            swarmHistoryRef.current = [];
            swarmIterationCounter.current = 0;
            setCurrentScriptStepIndex(0);
            setStepStatuses(task.script ? Array(task.script.length).fill({ status: 'pending' }) : []);
            setEventLog(() => [`[${new Date().toLocaleTimeString()}] [INFO] 🚀 Starting task...`]);
            setActiveToolsForTask([]);
        } else {
            logEvent(`[INFO] ▶️ Resuming task...`);
            if (historyEventToInject) swarmHistoryRef.current.push(historyEventToInject);
        }

        let finalTask = typeof task === 'string' ? { userRequest: { text: task, files: [] } } : task;
        // Attach the current view as context for the task
        finalTask.context = mainView;
        
        if (finalTask.isScripted) { setScriptExecutionState('running'); } else { setScriptExecutionState('idle'); }

        setCurrentUserTask(finalTask);
        setCurrentSystemPrompt(systemPrompt || SWARM_AGENT_SYSTEM_PROMPT);
        setIsSequential(sequential);
        setAgentSwarm([{ id: 'agent-1', status: 'idle', lastAction: 'Awaiting instructions', error: null, result: null }]);
        if(!resume) setUserInput('');
        setIsSwarmRunning(true);
    }, [setUserInput, setEventLog, logEvent, mainView]);

    return {
        state: {
            agentSwarm, isSwarmRunning, currentUserTask, currentSystemPrompt, pauseState,
            lastSwarmRunHistory, activeToolsForTask, relevanceTopK, relevanceThreshold,
            relevanceMode, scriptExecutionState, currentScriptStepIndex, stepStatuses,
        },
        handlers: {
            startSwarmTask, handleStopSwarm, clearPauseState, clearLastSwarmRunHistory,
            runSwarmCycle, setRelevanceTopK, setRelevanceThreshold, setRelevanceMode,
            appendToSwarmHistory, toggleScriptPause,
            stepForward, stepBackward, runFromStep,
        },
    };
};
```

# hooks/useAppStateManager.ts
```hooks/useAppStateManager.ts


import { useState, useCallback } from 'react';
import { AI_MODELS } from '../constants';
import type { AIModel, APIConfig, MainView } from '../types';

export const useAppStateManager = () => {
    const [userInput, setUserInput] = useState<string>('');
    const [eventLog, setEventLog] = useState<string[]>([]);
    const [mainView, setMainView] = useState<MainView>('KICAD');
    const [apiCallCount, setApiCallCount] = useState<Record<string, number>>({});
    const [useSearch, setUseSearch] = useState<boolean>(false);

    const [selectedModel, setSelectedModel] = useState<AIModel>(AI_MODELS[0]);
    const [apiConfig, setApiConfig] = useState<APIConfig>(() => {
        let initialConfig: APIConfig = { 
            openAIAPIKey: 'ollama',
            openAIBaseUrl: 'http://localhost:8008/v1',
            ollamaHost: 'http://localhost:11434',
        };
        try {
            const stored = localStorage.getItem('apiConfig');
            if (stored) initialConfig = { ...initialConfig, ...JSON.parse(stored) };
        } catch {}
        return initialConfig;
    });

    const logEvent = useCallback((message: string) => {
      const timestamp = new Date().toLocaleTimeString();
      setEventLog(prev => [...prev.slice(-199), `[${timestamp}] ${message}`]);
    }, []);

    return {
        state: {
            userInput,
            eventLog,
            mainView,
            apiCallCount,
            selectedModel,
            apiConfig,
            useSearch,
        },
        setters: {
            setUserInput,
            setEventLog,
            setMainView,
            setApiCallCount,
            setSelectedModel,
            setApiConfig,
            setUseSearch,
        },
        logEvent,
    };
};
```

# hooks/useToolManager.ts
```hooks/useToolManager.ts


import { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { CORE_TOOLS, BOOTSTRAP_TOOL_PAYLOADS } from '../constants';
import { loadStateFromStorage } from '../versioning';
import type { LLMTool, ToolCreatorPayload } from '../types';

export const generateMachineReadableId = (name: string, existingTools: LLMTool[]): string => {
  let baseId = name
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9\s_]/g, '')
    .replace(/\s+/g, '_')
    .replace(/_{2,}/g, '_')
    .slice(0, 50);
  if (!baseId) baseId = 'unnamed_tool';
  let finalId = baseId;
  let counter = 1;
  const existingIds = new Set(existingTools.map(t => t.id));
  while (existingIds.has(finalId)) {
    finalId = `${baseId}_${counter}`;
    counter++;
  }
  return finalId;
};

export const bootstrapTool = (payload: ToolCreatorPayload, existingTools: LLMTool[]): LLMTool => {
    const { executionEnvironment, ...toolData } = payload;
    
    // In client-only mode, the execution environment is always 'Client',
    // but we keep the category ('Server') for display and logical separation.
    const finalCategory = payload.category;

    const newId = generateMachineReadableId(toolData.name, existingTools);
    const now = new Date().toISOString();
    return {
        ...toolData,
        category: finalCategory,
        id: newId,
        version: 1,
        createdAt: now,
        updatedAt: now,
    };
};

export const initializeTools = (): LLMTool[] => {
    console.log("Bootstrapping initial toolset...");
    const allCreatedTools: LLMTool[] = [...CORE_TOOLS];
    
    BOOTSTRAP_TOOL_PAYLOADS.forEach(payload => {
        const newTool = bootstrapTool(payload, allCreatedTools);
        allCreatedTools.push(newTool);
    });
    console.log(`Bootstrap complete. ${allCreatedTools.length} client tools loaded.`);
    return allCreatedTools;
};


export const useToolManager = ({ logEvent }: { logEvent: (message: string) => void }) => {
    const [tools, setTools] = useState<LLMTool[]>([]);
    
    // State for server tools and connection status
    const [serverTools, setServerTools] = useState<LLMTool[]>([]);
    const [isServerConnected, setIsServerConnected] = useState<boolean>(false);
    const isServerConnectedRef = useRef(isServerConnected);
    isServerConnectedRef.current = isServerConnected;

    useEffect(() => {
        const freshBootstrapTools = initializeTools();
        const freshBootstrapToolsMap = new Map(freshBootstrapTools.map(t => [t.name, t]));
        
        const storedState = loadStateFromStorage();
        const storedTools = storedState ? storedState.tools : [];

        if (!storedState) {
            setTools(freshBootstrapTools);
            logEvent('[SYSTEM] Initial toolset loaded. No previous state found.');
            return;
        }

        const updatedTools: LLMTool[] = [];
        const processedStoredToolNames = new Set<string>();
        let versionUpdateCount = 0;
        let codeUpdateCount = 0;
        let preservedUserToolsCount = 0;

        // 1. Iterate through stored tools and update if necessary
        for (const storedTool of storedTools) {
            processedStoredToolNames.add(storedTool.name);
            const freshTool = freshBootstrapToolsMap.get(storedTool.name);

            if (freshTool) {
                // It's a bootstrapped tool. Check for updates.
                if (freshTool.version > storedTool.version) {
                    updatedTools.push(freshTool); // Standard version bump
                    versionUpdateCount++;
                } else if (
                    freshTool.version === storedTool.version &&
                    freshTool.implementationCode !== storedTool.implementationCode
                ) {
                    // Same version, but code has changed. This is an implicit update.
                    updatedTools.push(freshTool);
                    codeUpdateCount++;
                } else {
                    // Keep the stored tool if its version is newer (e.g., LLM-modified)
                    // or if it's identical to the fresh one.
                    updatedTools.push(storedTool);
                }
            } else {
                // It's a user/LLM-generated tool, not in the bootstrap set. Keep it.
                updatedTools.push(storedTool);
                preservedUserToolsCount++;
            }
        }

        // 2. Add any new bootstrapped tools that weren't in storage
        let newToolsCount = 0;
        for (const freshTool of freshBootstrapTools) {
            if (!processedStoredToolNames.has(freshTool.name)) {
                updatedTools.push(freshTool);
                newToolsCount++;
            }
        }
        
        if (versionUpdateCount > 0 || codeUpdateCount > 0 || newToolsCount > 0) {
            logEvent(`[SYSTEM] Tools auto-updated: ${versionUpdateCount} by version, ${codeUpdateCount} by code change. ${newToolsCount} new tools added. Preserved ${preservedUserToolsCount} user-generated tools.`);
        } else {
            logEvent(`[SYSTEM] Tools are up to date. Loaded ${storedTools.length} tools from storage.`);
        }
        
        setTools(updatedTools);

    }, []); // Run only once on mount

    const forceRefreshServerTools = useCallback(async () => {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);
            const response = await fetch('http://localhost:3001/api/tools', { signal: controller.signal });
            clearTimeout(timeoutId);

            if (response.ok) {
                const fetchedTools: LLMTool[] = await response.json();
                setServerTools(fetchedTools);
                if (!isServerConnectedRef.current) {
                    setIsServerConnected(true);
                    logEvent(`[INFO] ✅ Server connection re-established.`);
                }
                logEvent(`[SYSTEM] Server tool cache synchronized. Loaded ${fetchedTools.length} server tools.`);
                return { success: true, count: fetchedTools.length };
            } else {
                 throw new Error(`Server responded with status: ${response.status}`);
            }
        } catch (error) {
            setServerTools([]);
            if (isServerConnectedRef.current) {
                setIsServerConnected(false);
                logEvent('[WARN] ⚠️ Server connection lost during refresh.');
            }
            throw error;
        }
    }, [logEvent]);

    const allTools = useMemo(() => {
        const clientToolNames = new Set(tools.map(t => t.name));
        // Filter server tools to remove any that have the same name as a client tool,
        // giving client-side definitions precedence.
        const filteredServerTools = serverTools.filter(st => !clientToolNames.has(st.name));
        return [...tools, ...filteredServerTools];
    }, [tools, serverTools]);
    
    const allToolsRef = useRef(allTools);
    allToolsRef.current = allTools;

    useEffect(() => {
        const fetchServerStatusAndTools = async () => {
            try {
                // Use AbortController for fetch timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); // 3-second timeout
                
                const response = await fetch('http://localhost:3001/api/tools', { signal: controller.signal });
                clearTimeout(timeoutId);

                if (response.ok) {
                    const fetchedTools: LLMTool[] = await response.json();
                    setServerTools(currentServerTools => {
                        // Avoid unnecessary state updates and log spam if the tools haven't changed.
                        if (JSON.stringify(currentServerTools) !== JSON.stringify(fetchedTools)) {
                            if (isServerConnectedRef.current) { // Only log updates if already connected
                                logEvent(`[SYSTEM] Server tools updated via polling. Found ${fetchedTools.length} tools.`);
                            }
                            return fetchedTools;
                        }
                        return currentServerTools;
                    });
                    if (!isServerConnectedRef.current) {
                        setIsServerConnected(true);
                        logEvent('[INFO] ✅ Server connection established.');
                    }
                } else {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
            } catch (error) {
                setServerTools([]);
                if (isServerConnectedRef.current) {
                    setIsServerConnected(false);
                    logEvent('[WARN] ⚠️ Server connection lost.');
                }
            }
        };

        fetchServerStatusAndTools(); // Initial check
        const intervalId = setInterval(fetchServerStatusAndTools, 5000); // Poll every 5 seconds

        return () => clearInterval(intervalId);
    }, [logEvent]);

    return {
        tools,
        setTools,
        allTools,
        allToolsRef,
        isServerConnected,
        generateMachineReadableId,
        forceRefreshServerTools, // Expose the manual refresh function
    };
};

```

# hooks/useToolRelevance.ts
```hooks/useToolRelevance.ts


import { useState, useCallback, useEffect, useRef } from 'react';
import { generateEmbeddings, cosineSimilarity } from '../services/embeddingService';
import { CORE_TOOLS } from '../constants';
import type { LLMTool, ScoredTool, MainView } from '../types';

export const useToolRelevance = ({ allTools, logEvent }: { allTools: LLMTool[], logEvent: (msg: string) => void }) => {
    const [toolEmbeddings, setToolEmbeddings] = useState<Map<string, number[]>>(new Map());
    const isEmbeddingTools = useRef(false);
    
    // Using a ref to track initialization status to avoid re-runs and state dependency issues.
    const embeddingsInitialized = useRef(false);

    // This function ensures all tools are embedded before use. It's now called lazily.
    const ensureToolEmbeddings = useCallback(async () => {
        // Exit if already initialized, or if another process is already running.
        if (embeddingsInitialized.current || isEmbeddingTools.current) {
            return;
        }
        
        // Prevent concurrent runs.
        isEmbeddingTools.current = true;
        
        // Inform the user about the one-time setup cost.
        logEvent(`[Embeddings] First-time setup: processing ${allTools.length} tools. This may take a moment...`);
        
        try {
            const textsToEmbed = allTools.map(tool => {
                const parametersJson = JSON.stringify(tool.parameters.map(p => ({ name: p.name, type: p.type, description: p.description })));
                return `Tool: ${tool.name}. Purpose: ${tool.purpose || 'Not specified'}. Description: ${tool.description}. Parameters: ${parametersJson}`;
            });
            
            // This will trigger the model load and show progress via onProgress.
            const embeddings = await generateEmbeddings(textsToEmbed, (msg) => logEvent(`[Embeddings] ${msg}`));
            
            const newEmbeddings = new Map<string, number[]>();
            allTools.forEach((tool, index) => {
                newEmbeddings.set(tool.id, embeddings[index]);
            });

            setToolEmbeddings(newEmbeddings);
            embeddingsInitialized.current = true; // Mark as initialized
            logEvent(`[Embeddings] Cache created successfully. Total embedded: ${allTools.length} tools.`);

        } catch (e) {
            const errorMsg = e instanceof Error ? e.message : String(e);
            logEvent(`[ERROR] Failed to generate tool embeddings: ${errorMsg}`);
            embeddingsInitialized.current = false; // Allow retry on next call
            throw e; // Re-throw to fail the parent function
        } finally {
            isEmbeddingTools.current = false; // Release the lock
        }
    }, [allTools, logEvent]);


    const findRelevantTools = useCallback(async (
        userRequestText: string, 
        availableTools: LLMTool[],
        topK: number,
        relevanceThreshold: number,
        systemPromptForContext: string | null = null,
        mainView: MainView | null = null
    ): Promise<ScoredTool[]> => {
        try {
            // Lazily compute tool embeddings on the first call.
            await ensureToolEmbeddings();

            let contextForEmbedding = "";
            
            // Add view-specific context to help the embedding model understand the domain.
            if (mainView === 'ROBOTICS') {
                contextForEmbedding += "Context: Robotics simulation, agent navigation, and task execution in a 3D environment. ";
            } else if (mainView === 'KICAD') {
                contextForEmbedding += "Context: Electronic design automation (EDA), KiCad software, PCB layout, and hardware engineering. ";
            } else if (mainView === 'KNOWLEDGE_GRAPH') {
                contextForEmbedding += "Context: Strategic planning, knowledge representation, and managing long-term agent memory. ";
            }
            
            if (systemPromptForContext) {
                contextForEmbedding += `System Goal: ${systemPromptForContext}\\n\\n`;
            }
            contextForEmbedding += `User's Current Task: ${userRequestText}`;

            if (!contextForEmbedding.trim()) {
                logEvent('[WARN] No context available for tool relevance search. Providing all tools.');
                return availableTools.map(tool => ({ tool, score: 0 }));
            }

            // The model is now loaded, so this call should be fast.
            const [contextEmbedding] = await generateEmbeddings([contextForEmbedding], (msg) => logEvent(`[Embeddings] ${msg}`));
            
            // Score all available tools against the context.
            const scoredTools = availableTools.map(tool => {
                const toolEmbedding = toolEmbeddings.get(tool.id);
                // If a tool somehow wasn't embedded (e.g., added dynamically after init), score it as 0.
                if (!toolEmbedding) return { tool, score: 0 };
                const score = cosineSimilarity(contextEmbedding, toolEmbedding);
                return { tool, score };
            }).sort((a, b) => b.score - a.score);

            const relevantByThreshold = scoredTools.filter(item => item.score >= relevanceThreshold);
            const topKTools = relevantByThreshold.slice(0, topK);

            const debugLogLines = [`[Relevance] All tool scores (Threshold > ${relevanceThreshold.toFixed(2)}):`];
            scoredTools.slice(0, 100).forEach(({ tool, score }) => { // log top 100 to avoid spam
                const passed = score >= relevanceThreshold;
                debugLogLines.push(`- ${passed ? '✅' : '❌'} ${tool.name}: ${score.toFixed(3)}`);
            });
            logEvent(debugLogLines.join('\\n'));

            const relevantToolIds = new Set(topKTools.map(item => item.tool.id));
            
            // Always include CORE_TOOLS to ensure the agent can create tools or finish tasks.
            for (const coreTool of CORE_TOOLS) {
                if (!relevantToolIds.has(coreTool.id)) {
                    const coreToolScoreItem = scoredTools.find(st => st.tool.id === coreTool.id);
                    topKTools.push(coreToolScoreItem || { tool: coreTool, score: 0 });
                    relevantToolIds.add(coreTool.id); // Add to set to prevent duplicates
                }
            }
            
            const finalTools = topKTools.sort((a, b) => b.score - a.score);
            logEvent(`[Relevance] Filtered to ${finalTools.length} tools (Top K: ${topK}, Threshold: ${relevanceThreshold}).`);
            return finalTools;

        } catch (e) {
            const errorMsg = e instanceof Error ? e.message : String(e);
            logEvent(`[WARN] Tool relevance search failed: ${errorMsg}. Providing all available tools as a fallback.`);
            return availableTools.map(tool => ({ tool, score: 0 }));
        }
    }, [toolEmbeddings, logEvent, ensureToolEmbeddings]);

    return { findRelevantTools };
};

```

# hooks/useGameWorldManager.ts
```hooks/useGameWorldManager.ts
import { useState, useCallback, useEffect, useRef } from 'react';
import RAPIER from '@dimforge/rapier3d-compat';
import type { RobotState, EnvironmentObject, AIToolCall, EnrichedAIResponse, AgentPersonality, PlayerState, LLMTool, Party, WorldEvent, PilotMode, WorldCreature } from '../types';

const initialEnvironmentState: EnvironmentObject[] = [];
let gameLoopInterval: number | null = null;
let aiPilotInterval: number | null = null;

// Ensure Rapier is initialized only once using a global promise.
if (!(window as any).rapierInitializationPromise) {
    (window as any).rapierInitializationPromise = RAPIER.init().then(() => RAPIER);
}


export const useGameWorldManager = ({ logEvent, executeActionRef, processRequest }: { logEvent: (message: string) => void, executeActionRef: React.MutableRefObject<any>, processRequest: any }) => {
    const [robotStates, setRobotStates] = useState<RobotState[]>([]); // NPCs
    const [players, setPlayers] = useState<PlayerState[]>([]);
    const [environmentState, setEnvironmentState] = useState<EnvironmentObject[]>(initialEnvironmentState);
    const [agentPersonalities, setAgentPersonalities] = useState<AgentPersonality[]>([]);
    const [isLocalGameRunning, setIsLocalGameRunning] = useState(false);
    const [parties, setParties] = useState<Party[]>([]);
    const [worldEvents, setWorldEvents] = useState<WorldEvent[]>([]);
    const [worldCreatures, setWorldCreatures] = useState<WorldCreature[]>([]);
    const [pilotMode, setPilotMode] = useState<PilotMode>('MANUAL');
    const [aiPilotTarget, setAiPilotTarget] = useState<string>("Explore the world and gather valuable reagents.");
    
    // --- New Physics State ---
    const worldRef = useRef<RAPIER.World | null>(null);
    const entityBodyMapRef = useRef<Map<string, RAPIER.RigidBody>>(new Map());
    
    const [connectedServerInfo, setConnectedServerInfo] = useState<{ processId: string, port: number } | null>(null);
    const pollingIntervalRef = useRef<number | null>(null);

    const gameTickCountRef = useRef(0);
    
    const playersRef = useRef(players);
    useEffect(() => { playersRef.current = players; }, [players]);


    const getGameStateForRuntime = useCallback((agentId: string) => {
        const robot = robotStates.find(r => r.id === agentId);
        const defaultRobot: RobotState = { id: agentId, x: 0, y: 0, rotation: 0, hasResource: false, powerLevel: 100 };
        return { 
            robot: robot || defaultRobot, 
            players,
            robotStates,
            environment: environmentState, 
            personalities: agentPersonalities,
            worldCreatures,
            gameTick: gameTickCountRef.current,
        };
    }, [robotStates, players, environmentState, agentPersonalities, worldCreatures]);
    
    const stopGameLoop = useCallback(() => {
        if (gameLoopInterval) {
            clearInterval(gameLoopInterval);
            gameLoopInterval = null;
            setIsLocalGameRunning(false);
            logEvent('[SYSTEM] Local game loop stopped.');
        }
        if (aiPilotInterval) {
            clearInterval(aiPilotInterval);
            aiPilotInterval = null;
            logEvent('[SYSTEM] AI Familiar Pilot deactivated.');
        }
        if (worldRef.current) {
            worldRef.current.free();
            worldRef.current = null;
            entityBodyMapRef.current.clear();
        }
    }, [logEvent]);
    
    const handleManualControl = useCallback(async (toolName: string, args: any = {}) => {
        const { playerId, ...actionArgs } = args;
        if (!playerId) return logEvent(`[CONTROL] Manual command failed: Player ID missing.`);

        if (connectedServerInfoRef.current) { // Online MMO mode
            try {
                const response = await fetch(`http://localhost:${connectedServerInfoRef.current.port}/api/player/${playerId}/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ toolName: toolName, arguments: actionArgs }),
                });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Failed to send player action.');
                }
            } catch(e) {
                logEvent(`[ERROR] Failed to send action: ${e instanceof Error ? e.message : String(e)}`);
            }
        } else { // Offline single-player mode with Rapier physics
            const body = entityBodyMapRef.current.get(playerId);
            if (!body) return logEvent(`[PHYSICS] Cannot control player ${playerId}: RigidBody not found.`);

            const rotationY = body.rotation().y;
            const impulseStrength = 20.0;
            const torqueStrength = 5.0;

            if (toolName === 'Move Forward') {
                const impulse = { x: Math.sin(rotationY) * impulseStrength, y: 0, z: Math.cos(rotationY) * impulseStrength };
                body.applyImpulse(impulse, true);
            } else if (toolName === 'Move Backward') {
                const impulse = { x: -Math.sin(rotationY) * impulseStrength, y: 0, z: -Math.cos(rotationY) * impulseStrength };
                body.applyImpulse(impulse, true);
            } else if (toolName === 'Turn Left') {
                body.applyTorqueImpulse({ x: 0, y: torqueStrength, z: 0 }, true);
            } else if (toolName === 'Turn Right') {
                body.applyTorqueImpulse({ x: 0, y: -torqueStrength, z: 0 }, true);
            } else if (toolName === 'Aetheric Push') {
                const targetId = actionArgs.targetId;
                const targetBody = entityBodyMapRef.current.get(targetId);
                if (!targetBody) return logEvent(`[AETHERIC PUSH] Target ${targetId} not found.`);
                
                const playerPos = body.translation();
                const targetPos = targetBody.translation();
                const direction = { x: targetPos.x - playerPos.x, y: 0, z: targetPos.z - playerPos.z };
                const distance = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
                
                if (distance > 0 && distance < 10) { // Max range of 10 units
                    const pushImpulse = {
                        x: (direction.x / distance) * 100.0,
                        y: 20.0, // Push upwards a bit
                        z: (direction.z / distance) * 100.0,
                    };
                    targetBody.applyImpulse(pushImpulse, true);
                    logEvent(`[ACTION] Unleashed an Aetheric Push on ${targetId}!`);
                } else {
                    logEvent(`[ACTION] Aetheric Push failed: ${targetId} is out of range.`);
                }
            }
        }
    }, [logEvent]);

    const runAIPilotTurn = useCallback(async () => {
        // AI Pilot logic remains the same, as it calls handleManualControl
    }, []);

    
    const startGameLoop = useCallback(() => {
        stopGameLoop(); 
        setIsLocalGameRunning(true);
        logEvent('[SYSTEM] Local physics-based game loop started.');
        
        gameLoopInterval = window.setInterval(() => {
            const world = worldRef.current;
            if (executeActionRef.current && world) {
                gameTickCountRef.current++;
                world.step();

                // Read back physics state into React state
                const updatedPlayers = playersRef.current.map(p => {
                    const body = entityBodyMapRef.current.get(p.id);
                    if (!body) return p;
                    const pos = body.translation();
                    const rot = RAPIER.quatToEuler({ w: body.rotation().w, x: body.rotation().x, y: body.rotation().y, z: body.rotation().z });
                    return { ...p, x: pos.x, y: pos.z, rotation: rot.y * 180 / Math.PI };
                });
                setPlayers(updatedPlayers);

                const updatedNpcs = Array.from(entityBodyMapRef.current.entries())
                    .map(([id, body]) => {
                         const existingNpc = robotStates.find(npc => npc.id === id);
                         if (!existingNpc) return null;
                         const pos = body.translation();
                         const rot = RAPIER.quatToEuler({ w: body.rotation().w, x: body.rotation().x, y: body.rotation().y, z: body.rotation().z });
                         return { ...existingNpc, x: pos.x, y: pos.z, rotation: rot.y * 180 / Math.PI };
                    })
                    .filter(Boolean) as RobotState[];
                setRobotStates(updatedNpcs);
                
                executeActionRef.current({ name: 'Game Tick', arguments: {} }, 'local_game_engine', 'AETHERIUM_GAME');
            }
        }, 1000 / 60); // Run at 60 FPS for smooth physics
        
        aiPilotInterval = window.setInterval(runAIPilotTurn, 5000);
        logEvent('[SYSTEM] AI Familiar Pilot activated.');

    }, [logEvent, stopGameLoop, executeActionRef, runAIPilotTurn, robotStates]);

    const agentPersonalitiesRef = useRef(agentPersonalities);
    useEffect(() => { agentPersonalitiesRef.current = agentPersonalities; }, [agentPersonalities]);

    const initializeLocalWorld = useCallback(async (script: AIToolCall[], player: PlayerState) => {
        logEvent('[LOCAL] Initializing physics-based world...');
        stopGameLoop(); // Ensure everything is clean
        
        const RAPIER = await (window as any).rapierInitializationPromise;
        const world = new RAPIER.World({ x: 0, y: -9.81, z: 0 });
        worldRef.current = world;
        entityBodyMapRef.current.clear();

        // Temporary state holders
        let tempPlayers: PlayerState[] = [];
        let tempNpcs: RobotState[] = [];
        let tempEnv: EnvironmentObject[] = [];
        let tempPerson: AgentPersonality[] = [];
        let tempCreatures: WorldCreature[] = [];

        // Run script to define entities, but don't set react state yet
        for (const step of script) {
            if (step.name === 'Define World Creature') {
                tempCreatures.push({ creatureId: step.arguments.creatureId, name: step.arguments.name, description: step.arguments.description, asset_glb: step.arguments.asset_glb });
            } else if (step.name === 'Define Robot Agent') {
                 const creatureId = step.arguments.id.split('_').slice(0, -1).join('_');
                 const creatureType = tempCreatures.find(c => c.creatureId === creatureId);
                 const asset = creatureType ? creatureType.asset_glb : step.arguments.asset_glb;
                 tempPerson.push({ id: step.arguments.id, startX: step.arguments.startX, startY: step.arguments.startY, behaviorType: step.arguments.behaviorType, targetId: step.arguments.targetId, asset_glb: asset });
                 tempNpcs.push({ id: step.arguments.id, x: step.arguments.startX, y: step.arguments.startY, rotation: 0, hasResource: false, powerLevel: 100 });
            } else if (step.name === 'Place Environment Object') {
                tempEnv.push({ id: step.arguments.objectId, type: step.arguments.type, x: step.arguments.x, y: step.arguments.y, asset_glb: step.arguments.asset_glb });
            }
        }
        
        // Now create Rapier bodies for all entities
        const groundColliderDesc = RAPIER.ColliderDesc.cuboid(50.0, 0.1, 50.0);
        world.createCollider(groundColliderDesc);

        [...tempNpcs, player].forEach(entity => {
            const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
                .setTranslation(entity.x, 1, entity.y)
                .setLinearDamping(1.0)
                .setAngularDamping(1.0);
            const body = world.createRigidBody(bodyDesc);
            const colliderDesc = RAPIER.ColliderDesc.capsule(0.5, 0.5);
            world.createCollider(colliderDesc, body);
            entityBodyMapRef.current.set(entity.id, body);
        });

        tempEnv.forEach((obj, i) => {
            const bodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(obj.x, 1, obj.y);
            const body = world.createRigidBody(bodyDesc);
            const colliderDesc = RAPIER.ColliderDesc.cuboid(0.5, 1.0, 0.5);
            world.createCollider(colliderDesc, body);
            entityBodyMapRef.current.set(obj.id || `env_${i}`, body);
        });
        
        // Now commit to React state
        setPlayers([player]);
        setRobotStates(tempNpcs);
        setAgentPersonalities(tempPerson);
        setEnvironmentState(tempEnv);
        setWorldCreatures(tempCreatures);
        setParties([]);
        setWorldEvents([]);

        startGameLoop();
        logEvent(`[SUCCESS] Physics-based session started for ${player.name}.`);
    }, [logEvent, startGameLoop, stopGameLoop, executeActionRef]);


    const disconnectFromShard = useCallback(() => {
        if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current);
            pollingIntervalRef.current = null;
        }
        if (connectedServerInfo) {
            setConnectedServerInfo(null);
            logEvent('[SYSTEM] Disconnected from world shard.');
        }
    }, [logEvent, connectedServerInfo]);

    const connectToShard = useCallback(async (serverInfo: { processId: string, port: number }, playerState: PlayerState) => {
        logEvent(`[CLIENT] Connecting to ${serverInfo.processId}...`);
        
        let joinResponse: Response | null = null;
        let lastError: Error | null = null;
        const maxRetries = 5;
        const retryDelay = 500; // ms

        for (let i = 0; i < maxRetries; i++) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000);
                joinResponse = await fetch(`http://localhost:${serverInfo.port}/api/join`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerState }),
                    signal: controller.signal,
                });
                clearTimeout(timeoutId);
                if (joinResponse.ok) { lastError = null; break; } 
                else { const errText = await joinResponse.text(); lastError = new Error(`Server responded with ${joinResponse.status}: ${errText}`); }
            } catch (e) {
                lastError = e instanceof Error ? e : new Error(String(e));
                logEvent(`[CLIENT] Connection attempt ${i + 1} failed. Retrying in ${retryDelay}ms...`);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
        }

        if (!joinResponse || !joinResponse.ok) {
            const finalError = lastError ? lastError.message : 'Failed to join server after multiple attempts.';
            throw new Error(finalError);
        }
        
        setConnectedServerInfo(serverInfo);
        
        const poll = async () => {
            try {
                const stateResponse = await fetch(`http://localhost:${serverInfo.port}/api/state`);
                if (stateResponse.ok) {
                    const state = await stateResponse.json();
                    setPlayers(state.players);
                    setRobotStates(state.npcs);
                    setEnvironmentState(state.environment);
                    setAgentPersonalities(state.agentPersonalities);
                    setParties(state.parties);
                    setWorldEvents(state.worldEvents);
                } else {
                    logEvent(`[WARN] Failed to poll state from ${serverInfo.processId}. Disconnecting.`);
                    disconnectFromShard();
                }
            } catch (e) {
                logEvent(`[ERROR] Lost connection to ${serverInfo.processId}. Disconnecting.`);
                disconnectFromShard();
            }
        };
        
        await poll(); // Initial poll
        if (pollingIntervalRef.current) clearInterval(pollingIntervalRef.current);
        pollingIntervalRef.current = window.setInterval(poll, 1000);

        logEvent(`[CLIENT] Successfully joined ${serverInfo.processId} as ${playerState.name}.`);
    }, [logEvent, disconnectFromShard]);
    
    const connectedServerInfoRef = useRef(connectedServerInfo);
    useEffect(() => { connectedServerInfoRef.current = connectedServerInfo; }, [connectedServerInfo]);

    const exitLocalWorld = useCallback(() => {
        stopGameLoop();
        disconnectFromShard();
        setPlayers([]);
        setRobotStates([]);
        setAgentPersonalities([]);
        setEnvironmentState([]);
        setParties([]);
        setWorldEvents([]);
        setWorldCreatures([]);
        logEvent('[SYSTEM] Session ended.');
    }, [stopGameLoop, disconnectFromShard, logEvent]);

    return {
        gameState: {
            robotStates,
            players,
            environmentState,
            agentPersonalities,
            isLocalGameRunning,
            connectedServerInfo,
            parties,
            worldEvents,
            worldCreatures,
            pilotMode,
            aiPilotTarget,
        },
        gameSetters: {
            setRobotStates,
            setPlayers,
            setEnvironmentState,
            setAgentPersonalities,
            setParties,
            setWorldEvents,
            setWorldCreatures,
            setPilotMode,
            setAiPilotTarget,
        },
        getGameStateForRuntime,
        handleManualControl,
        initializeLocalWorld,
        exitLocalWorld: exitLocalWorld,
        connectToShard,
        disconnectFromShard,
    };
};

```

# server/requirements.txt
```server/requirements.txt

torch
transformers
accelerate
av
pillow
torchvision
timm
librosa
bitsandbytes
unsloth[colab-new]
resampy
fastapi
uvicorn
python-multipart
soundfile
pydantic<2
skidl

```

# server/server.ts.txt
```server/server.ts.txt
// server/server.ts
import express from 'express';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';
import { exec, spawn, ChildProcess } from 'child_process';
import { createServer, type Server } from 'net';
import type { LLMTool, NewToolPayload, AIToolCall } from '../types';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = 3001;
const TOOLS_DB_PATH = path.join(__dirname, 'tools.json');
const SCRIPTS_DIR = path.join(__dirname, 'scripts');
const ASSETS_DIR = path.join(__dirname, 'assets'); // Serve assets from the server's own directory

// --- In-memory state ---
let serverToolsCache: LLMTool[] = [];
let gemmaProcess: ChildProcess | null = null;
let kicadServiceProcess: ChildProcess | null = null;
const KICAD_SERVICE_BASE_PORT = 8000;
const KICAD_SERVICE_TIMEOUT = 600000; // 10 minutes for long-running tasks like autorouting
let currentKicadServicePort: number | null = null;
let gemmaLogs: string[] = [];
const MAX_LOGS = 100;

// NEW: Generic process management
const managedProcesses: Map<string, { process: ChildProcess; logs: string[]; scriptPath: string; port: number | null }> = new Map();


// --- Middleware ---
app.use(cors()); // Allow requests from the frontend
app.use(express.json()); // Parse JSON bodies
// Statically serve the scripts directory to allow frontend access to generated files
app.use('/scripts', express.static(SCRIPTS_DIR));

// --- Utility Functions ---
const readToolsAndLoadCache = async (): Promise<LLMTool[]> => {
    try {
        await fs.access(TOOLS_DB_PATH);
        const data = await fs.readFile(TOOLS_DB_PATH, 'utf-8');
        serverToolsCache = JSON.parse(data) as LLMTool[];
        console.log(`[INFO] Loaded ${serverToolsCache.length} tools into server cache.`);
        return serverToolsCache;
    } catch (error) {
        serverToolsCache = [];
        console.log('[INFO] tools.json not found or empty. Initializing with 0 server tools.');
        return [];
    }
};

const writeTools = async (tools: LLMTool[]): Promise<void> => {
    await fs.writeFile(TOOLS_DB_PATH, JSON.stringify(tools, null, 2));
};

const generateMachineReadableId = (name: string, existingTools: LLMTool[]): string => {
  let baseId = name.trim().toLowerCase().replace(/[^a-z0-9\s_]/g, '').replace(/\s+/g, '_').slice(0, 50);
  if (!baseId) baseId = 'unnamed_tool';
  let finalId = baseId;
  let counter = 1;
  const existingIds = new Set(existingTools.map(t => t.id));
  while (existingIds.has(finalId)) {
    finalId = `${baseId}_${counter}`;
    counter++;
  }
  return finalId;
};

const addLog = (logArray: string[], log: string) => {
    logArray.push(log);
    if (logArray.length > MAX_LOGS) {
        logArray.shift();
    }
};

const isPortFree = (port: number): Promise<boolean> => {
    return new Promise((resolve) => {
        const server: Server = createServer();
        server.once('error', (err: any) => {
            resolve(err.code !== 'EADDRINUSE');
        });
        server.once('listening', () => {
            server.close(() => resolve(true));
        });
        server.listen(port, '127.0.0.1');
    });
};

const findFreePort = async (startPort: number): Promise<number> => {
    let port = startPort;
    while (!(await isPortFree(port))) {
        port++;
    }
    return port;
};


const isKicadServiceHealthy = async (port: number): Promise<boolean> => {
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 1000);
        const response = await fetch(`http://127.0.0.1:${port}/health`, {
            method: 'GET',
            signal: controller.signal,
        });
        clearTimeout(timeoutId);
        return response.ok;
    } catch (error) {
        return false;
    }
};

const ensureKicadServiceIsReady = async (): Promise<{ success: boolean; message: string; error?: string }> => {
    // 1. Check if the currently known service is healthy.
    if (currentKicadServicePort && await isKicadServiceHealthy(currentKicadServicePort)) {
        return { success: true, message: `KiCad Service is healthy on port ${currentKicadServicePort}.` };
    }
    
    // 2. If not healthy or not running, find a new free port.
    let newPort = KICAD_SERVICE_BASE_PORT;
    while (!(await isPortFree(newPort))) {
        newPort++;
    }
    console.log(`[INFO] Found free port for KiCad Service: ${newPort}`);

    // 3. Clean up any old process handles we might have.
    if (kicadServiceProcess) {
        console.warn('[WARN] Killing previous (likely unresponsive) KiCad Service process handle...');
        kicadServiceProcess.kill('SIGKILL');
        kicadServiceProcess = null;
    }

    try {
        // 4. Spawn a new process on the new free port.
        console.log(`[INFO] Spawning new KiCad Service process on port ${newPort}...`);
        const pythonExecutable = path.join(__dirname, '..', 'venv', 'bin', 'python');
        const scriptPath = path.join(SCRIPTS_DIR, 'kicad_service.py');
        
        const newProcess = spawn(pythonExecutable, [scriptPath], {
            env: { ...process.env, KICAD_SERVICE_PORT: newPort.toString() }
        });
        kicadServiceProcess = newProcess;
        
        newProcess.stdout?.on('data', (data) => console.log(`[KiCad Service @ ${newPort}]: ${data.toString().trim()}`));
        newProcess.stderr?.on('data', (data) => console.error(`[KiCad Service ERR @ ${newPort}]: ${data.toString().trim()}`));
        
        newProcess.on('close', (code) => {
            console.log(`KiCad Service process on port ${newPort} exited with code ${code}`);
            if (currentKicadServicePort === newPort) {
                currentKicadServicePort = null;
                kicadServiceProcess = null;
            }
        });

        // 5. Poll for healthiness on the new port.
        const startTime = Date.now();
        const timeout = 15000; // 15 seconds
        while (Date.now() - startTime < timeout) {
            if (await isKicadServiceHealthy(newPort)) {
                console.log(`[INFO] New KiCad Service is now healthy on port ${newPort}.`);
                currentKicadServicePort = newPort;
                return { success: true, message: `KiCad Service started successfully on port ${newPort}.` };
            }
            if (!newProcess.pid) { // Process crashed during startup
                 throw new Error("KiCad Service process exited prematurely during startup. Check service logs for errors.");
            }
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        throw new Error(`KiCad Service failed to become healthy on port ${newPort} within ${timeout / 1000} seconds.`);

    } catch (e) {
        const err = e as Error;
        if (kicadServiceProcess) {
            kicadServiceProcess.kill('SIGKILL');
            kicadServiceProcess = null;
        }
        currentKicadServicePort = null;
        return { success: false, message: `Failed to start KiCad Service: ${err.message}`, error: err.message };
    }
};


// --- API Endpoints ---

// Serve files from the assets directory, including subdirectories.
app.get('/assets/*', async (req, res) => {
    try {
        const requestedPath = req.params[0];
        
        // Security: Sanitize the path to prevent directory traversal.
        const safePath = path.normalize(requestedPath).replace(/^(\.\.(\/|\\|$))+/, '');
        if (safePath.includes('..')) {
            return res.status(400).send('Invalid path.');
        }

        const filePath = path.join(ASSETS_DIR, safePath);

        // Check if file exists before attempting to send
        await fs.access(filePath);
        
        // Let Express handle setting the correct Content-Type header
        res.sendFile(filePath);
    } catch (error) {
        console.error(`[ASSET SERVER] Error serving '${req.path}':`, error);
        res.status(404).send('Asset not found');
    }
});


// Get all server-side tools from the cache
app.get('/api/tools', (req: express.Request, res: express.Response) => {
    res.json(serverToolsCache);
});

// Create a new server-side tool or update an existing one (upsert).
app.post('/api/tools/create', async (req: express.Request, res: express.Response) => {
    try {
        const payload: NewToolPayload = req.body;
        if (!payload.name || !payload.description || !payload.category || !payload.implementationCode) {
            return res.status(400).json({ error: 'Missing required tool properties.' });
        }
        if (payload.category !== 'Server') {
            return res.status(400).json({ error: "Tools created on the server must have the category 'Server'." });
        }
        
        const currentTools = [...serverToolsCache];
        const existingToolIndex = currentTools.findIndex(t => t.name === payload.name);

        if (existingToolIndex !== -1) {
            // --- UPDATE EXISTING TOOL ---
            const existingTool = currentTools[existingToolIndex];
            const updatedTool = {
                ...existingTool,
                ...payload, // Overwrite with new data from the payload
                version: existingTool.version + 1, // Increment version on update
                updatedAt: new Date().toISOString(),
            };
            currentTools[existingToolIndex] = updatedTool;
            await writeTools(currentTools);
            serverToolsCache = currentTools; // Update the live cache

            console.log(`[INFO] Tool '${payload.name}' updated to version ${updatedTool.version}.`);
            return res.status(200).json({ message: `Server tool '${payload.name}' updated successfully.`, tool: updatedTool });
        } else {
            // --- CREATE NEW TOOL ---
            const newTool: LLMTool = {
                ...payload,
                id: generateMachineReadableId(payload.name, currentTools),
                version: 1,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
            };
            currentTools.push(newTool);
            await writeTools(currentTools);
            serverToolsCache = currentTools; // Update the live cache
            
            console.log(`[INFO] New tool '${newTool.name}' created and loaded into memory.`);
            return res.status(201).json({ message: 'Server tool created successfully', tool: newTool });
        }
    } catch (error) {
        console.error('Error creating/updating tool:', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});


// --- Local AI Server Logic ---
const startLocalAiServer = async () => {
    if (gemmaProcess) {
        throw new Error('Local AI server is already running.');
    }
    const scriptPath = path.join(SCRIPTS_DIR, 'gemma_server.py');
    try {
        await fs.access(scriptPath);
    } catch (error) {
        const message = 'Cannot start server: gemma_server.py does not exist. It must be created by an agent first.';
        addLog(gemmaLogs, `[ERROR] ${message}`);
        console.error(`[STARTUP_FAIL] Attempted to start local AI, but script was not found at ${scriptPath}`);
        throw new Error(message);
    }
    
    const pythonExecutable = path.join(__dirname, '..', 'venv', 'bin', 'python');
    addLog(gemmaLogs, 'Starting local AI server...');
    gemmaProcess = spawn(pythonExecutable, [scriptPath]);
    
    gemmaProcess.stdout?.on('data', (data) => addLog(gemmaLogs, data.toString().trim()));
    gemmaProcess.stderr?.on('data', (data) => addLog(gemmaLogs, data.toString().trim()));
    gemmaProcess.on('close', (code) => {
        addLog(gemmaLogs, `Server process exited with code ${code}.`);
        gemmaProcess = null;
    });
    gemmaProcess.on('error', (err) => {
        addLog(gemmaLogs, `[FATAL] Failed to start server process: ${err.message}`);
        gemmaProcess = null;
    });
    return { message: 'Local AI server process started.' };
};

const stopLocalAiServer = () => {
     if (!gemmaProcess || !gemmaProcess.pid) {
        throw new Error('Local AI server is not running.');
    }
    addLog(gemmaLogs, 'Stopping local AI server...');
    gemmaProcess.kill('SIGTERM');
    gemmaProcess = null;
    return { message: 'Local AI server stop signal sent.' };
};

const getLocalAiServerStatus = () => {
    return {
        isRunning: gemmaProcess !== null && gemmaProcess.pid !== undefined,
        pid: gemmaProcess?.pid,
        logs: gemmaLogs,
    };
};

// Execute a server-side tool or a special command
app.post('/api/execute', async (req: express.Request, res: express.Response) => {
    const { name, arguments: args }: AIToolCall = req.body;
    if (!name) return res.status(400).json({ error: 'Tool name is required.' });

    // Handle special, built-in server commands
    if (name === 'System_Reload_Tools') {
        console.log('[COMMAND] Received System_Reload_Tools command. Re-reading tools.json...');
        await readToolsAndLoadCache();
        return res.json({ success: true, message: `Successfully reloaded ${serverToolsCache.length} tools from disk.` });
    }
    if (name === 'System_Reset_Server_Tools') {
        console.log('[COMMAND] Received System_Reset_Server_Tools command. Deleting all custom tools...');
        try {
            if (kicadServiceProcess) {
                console.log('[COMMAND] Stopping KiCad service as part of reset...');
                kicadServiceProcess.kill('SIGTERM');
                kicadServiceProcess = null;
                currentKicadServicePort = null;
            }
            // NEW: Stop all managed processes on reset
            if (managedProcesses.size > 0) {
                console.log(`[COMMAND] Stopping ${managedProcesses.size} managed processes as part of reset...`);
                managedProcesses.forEach(p_info => p_info.process.kill('SIGTERM'));
                managedProcesses.clear();
            }
            await writeTools([]); // Write an empty array to the file
            serverToolsCache = []; // Clear the in-memory cache
            return res.json({ success: true, message: 'Successfully deleted all custom server-side tools and stopped services.' });
        } catch (error) {
            const err = error as Error;
            console.error('Error resetting server tools:', err.message);
            return res.status(500).json({ error: 'Failed to reset server tools on disk.' });
        }
    }
    
    // --- KiCad Service Management ---
    if (name === 'Start KiCad Service') {
        const result = await ensureKicadServiceIsReady();
        if (!result.success) {
            return res.status(500).json({ error: result.error });
        }
        return res.json({ success: true, message: result.message });
    }
    if (name === 'Stop KiCad Service') {
        if (!kicadServiceProcess || kicadServiceProcess.killed) {
             return res.status(400).json({ error: 'KiCad Service is not running or is unmanaged.' });
        }
        kicadServiceProcess.kill('SIGTERM');
        kicadServiceProcess = null;
        currentKicadServicePort = null;
        return res.json({ success: true, message: 'KiCad Service stopped.' });
    }

    const toolToExecute = serverToolsCache.find(t => t.name === name);
    if (!toolToExecute) return res.status(404).json({ error: `Server-side tool '${name}' not found in the live registry.` });
    
    // --- KiCad Command Proxying ---
    const PROXY_PREFIX = 'kicad_service_proxy::';
    if (toolToExecute.implementationCode && String(toolToExecute.implementationCode).trim().startsWith(PROXY_PREFIX)) {
        // This function now handles finding a port and starting the service if needed.
        const startResult = await ensureKicadServiceIsReady();
        if (!startResult.success || !currentKicadServicePort) {
            console.error(`[ERROR] Failed to ensure KiCad service is ready: ${startResult.error}`);
            return res.status(500).json({ error: `Failed to start or connect to the required KiCad Service: ${startResult.error}` });
        }
        
        const commandName = toolToExecute.implementationCode.trim().substring(PROXY_PREFIX.length);
        if (!commandName) {
            return res.status(500).json({ error: `Could not parse command name from tool '${name}'.` });
        }

        try {
            const serviceResponse = await fetch(`http://127.0.0.1:${currentKicadServicePort}/command/${commandName}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify(args),
                signal: AbortSignal.timeout(KICAD_SERVICE_TIMEOUT)
            });

            const result = await serviceResponse.json();

            if (!serviceResponse.ok) {
                const detail = result.detail || { error: 'Unknown error from KiCad service' };
                const errorMessage = typeof detail === 'string' ? detail : (detail.error || JSON.stringify(detail));
                return res.status(serviceResponse.status).json({ error: errorMessage });
            }
            
            const responseToClient = { success: true, ...result };
            console.log(`[PROXY SUCCESS] Sending response to client for '${commandName}':`, JSON.stringify(responseToClient));
            return res.json(responseToClient);

        } catch (fetchError) {
            const err = fetchError as Error;
            console.error(`Error proxying to KiCad Service on port ${currentKicadServicePort}:`, err);
            // Invalidate the current service port since it failed
            currentKicadServicePort = null;
            return res.status(502).json({ error: `Could not connect to the KiCad Service. It may have crashed. Details: ${err.message}` });
        }
    }

    // Handle built-in server functions identified by special implementation code
    try {
        switch (toolToExecute.implementationCode) {
            case 'start_local_ai':
                return res.json({ success: true, ...(await startLocalAiServer()) });
            case 'stop_local_ai':
                return res.json({ success: true, ...stopLocalAiServer() });
            case 'status_local_ai':
                return res.json({ success: true, message: "Status retrieved", ...getLocalAiServerStatus() });
            // --- NEW Generic Process Management ---
            case 'start_node_process': {
                const { processId, scriptPath } = args;
                if (!processId || !scriptPath) return res.status(400).json({ error: 'processId and scriptPath are required.' });
                if (managedProcesses.has(processId)) return res.status(400).json({ error: `Process with ID '${processId}' is already running.`});
                
                const fullScriptPath = path.join(SCRIPTS_DIR, scriptPath.replace(/^scripts\//, ''));
                if (!fullScriptPath.startsWith(SCRIPTS_DIR)) return res.status(400).json({ error: "Invalid script path." });
                await fs.access(fullScriptPath);

                const port = await findFreePort(4001);
                const newLogs: string[] = [];
                addLog(newLogs, `[MCP] Starting process '${processId}' on port ${port}...`);
                const newProcess = spawn('node', ['--loader', 'ts-node/esm', fullScriptPath], { 
                    cwd: __dirname,
                    env: { ...process.env, PORT: port.toString(), SHARD_ID: processId }
                });

                newProcess.stdout?.on('data', (data) => addLog(newLogs, `[${processId}] ${data.toString().trim()}`));
                newProcess.stderr?.on('data', (data) => addLog(newLogs, `[${processId} ERR] ${data.toString().trim()}`));
                newProcess.on('close', (code) => {
                    addLog(newLogs, `[MCP] Process '${processId}' exited with code ${code}.`);
                    managedProcesses.delete(processId);
                });
                newProcess.on('error', (err) => {
                    addLog(newLogs, `[MCP FATAL] Failed to start '${processId}': ${err.message}`);
                    managedProcesses.delete(processId);
                });
                
                managedProcesses.set(processId, { process: newProcess, logs: newLogs, scriptPath, port });
                return res.json({ success: true, message: `Process '${processId}' started on port ${port}.`, processId, port });
            }
            case 'stop_node_process': {
                const { processId } = args;
                if (!managedProcesses.has(processId)) return res.status(404).json({ error: `Process with ID '${processId}' not found.`});
                const p_info = managedProcesses.get(processId)!;
                p_info.process.kill('SIGTERM');
                managedProcesses.delete(processId);
                return res.json({ success: true, message: `Stop signal sent to process '${processId}'.` });
            }
            case 'list_managed_processes': {
                const processList = Array.from(managedProcesses.entries()).map(([id, p_info]) => ({
                    processId: id,
                    scriptPath: p_info.scriptPath,
                    isRunning: p_info.process.pid !== undefined && !p_info.process.killed,
                    pid: p_info.process.pid,
                    port: p_info.port,
                    logs: p_info.logs,
                }));
                return res.json({ success: true, processes: processList });
            }
        }
    } catch(e) {
        const errorMessage = e instanceof Error ? e.message : 'Unknown error during built-in command execution.';
        return res.status(500).json({ error: errorMessage });
    }
    
    // Handle user-defined shell commands
    let command = toolToExecute.implementationCode;
    if (args) {
        for (const key in args) {
            let value = args[key];
            if (typeof value === 'object' && value !== null) {
                value = JSON.stringify(value);
            }
            const escapedValue = String(value).replace(/'/g, "'\\''");
            command += ` --${key} '${escapedValue}'`;
        }
    }

    if (command.startsWith('python ')) {
        command = path.join('..', 'venv', 'bin', 'python') + command.substring('python'.length);
    }

    exec(command, { timeout: 300000, cwd: SCRIPTS_DIR }, (error, stdout, stderr) => { // 5 minute timeout
        if (error) {
            console.error(`Exec error for tool '${name}':`, { command, error: error.message, stdout, stderr });
            let detailedError = `Tool execution failed: ${error.message}`;
            if (stdout && stdout.trim()) {
                try {
                    const parsedStdout = JSON.parse(stdout);
                    if (parsedStdout.error) {
                        detailedError = parsedStdout.error;
                    } else {
                        detailedError = stdout.trim();
                    }
                } catch (e) {
                    detailedError = stdout.trim();
                }
            } else if (stderr && stderr.trim()) {
                detailedError = stderr.trim();
            }
            
            return res.status(500).json({ error: detailedError, stdout, stderr });
        }
        res.json({ success: true, message: `Tool '${name}' executed successfully.`, stdout, stderr });
    });
});

// Create/write a file on the server
app.post('/api/files/write', async (req: express.Request, res: express.Response) => {
    try {
        const { filePath, content, baseDir } = req.body;
        if (!filePath || typeof content !== 'string') {
            return res.status(400).json({ error: "Missing 'filePath' or 'content'." });
        }
        
        const targetBaseDir = (baseDir === 'assets') ? ASSETS_DIR : SCRIPTS_DIR;

        const safeFileName = path.normalize(filePath).replace(/^(\.\.(\/|\\|$))+/, '');
        if (safeFileName.includes('..')) {
           return res.status(400).json({ error: "Invalid file path (directory traversal detected)." });
        }
        const fullPath = path.join(targetBaseDir, safeFileName);
        
        if (!fullPath.startsWith(targetBaseDir)) {
            return res.status(400).json({ error: `Invalid file path (resolved outside '${baseDir || 'scripts'}' directory).` });
        }

        // Ensure the directory exists before writing the file
        await fs.mkdir(path.dirname(fullPath), { recursive: true });

        await fs.writeFile(fullPath, content);
        res.status(201).json({ success: true, message: `File '${safeFileName}' written successfully to '${baseDir || 'scripts'}' directory.` });
    } catch (error) {
        console.error('Error writing file:', error);
        res.status(500).json({ error: 'Internal Server Error while writing file.' });
    }
});

// --- Server Start ---
app.listen(PORT, async () => {
    console.log(`Singularity Agent Factory Backend Server listening on http://localhost:${PORT}`);
    console.log('This server allows the AI to execute local commands and write files.');
    
    await fs.mkdir(SCRIPTS_DIR, { recursive: true });
    await fs.mkdir(ASSETS_DIR, { recursive: true });
    
    await readToolsAndLoadCache();
    console.warn('SECURITY WARNING: This server can execute arbitrary code. Do not expose it to the internet.');
});
```

# server/install.sh.txt
```server/install.sh.txt
#!/bin/bash
# This script installs all necessary dependencies for the server.
# Rename this file to install.sh and run `chmod +x install.sh` to make it executable.

echo "--- Installing Node.js dependencies from package.json... ---"
npm install

echo ""
echo "--- Installing Python dependencies from requirements.txt... ---"
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

echo ""
echo "✅ Installation complete. You can now run './start.sh' to launch the server."

```

# server/package.json
```server/package.json
{
  "name": "singularity-agent-factory-server",
  "version": "1.0.0",
  "description": "Backend server for the Singularity Agent Factory",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node --loader ts-node/esm server.ts",
    "build": "tsc"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.19.2",
    "multer": "^1.4.5-lts.1"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/multer": "^1.4.11",
    "@types/node": "^20.12.12",
    "ts-node": "^10.9.2",
    "typescript": "^5.4.5"
  }
}

```

# server/start.sh.txt
```server/start.sh.txt
#!/bin/bash
# This script starts the backend server.
# Rename this file to start.sh and run `chmod +x start.sh` to make it executable.

export KICAD_SYMBOL_DIR=/usr/share/kicad/symbols
export KICAD6_SYMBOL_DIR=/usr/share/kicad/symbols
export KICAD7_SYMBOL_DIR=/usr/share/kicad/symbols
export KICAD8_SYMBOL_DIR=/usr/share/kicad/symbols
export KICAD9_SYMBOL_DIR=/usr/share/kicad/symbols
export KICAD_FOOTPRINT_DIR=/usr/share/kicad/footprints
export KICAD6_FOOTPRINT_DIR=/usr/share/kicad/footprints
export KICAD7_FOOTPRINT_DIR=/usr/share/kicad/footprints
export KICAD8_FOOTPRINT_DIR=/usr/share/kicad/footprints
export KICAD9_FOOTPRINT_DIR=/usr/share/kicad/footprints
export KICAD_3DMODEL_DIR=/usr/share/kicad/3dmodels
export KICAD6_3DMODEL_DIR=/usr/share/kicad/3dmodels
export KICAD7_3DMODEL_DIR=/usr/share/kicad/3dmodels
export KICAD8_3DMODEL_DIR=/usr/share/kicad/3dmodels
export KICAD9_3DMODEL_DIR=/usr/share/kicad/3dmodels

source venv/bin/activate

echo "🚀 Starting Singularity Agent Factory Backend Server..."
npm start
```

# server/tools.json
```server/tools.json
[]

```

# server/assets/research/analysis/10.3389_fnins.2022.1009878_eeg_mezzanine_quest.json
```server/assets/research/analysis/10.3389_fnins.2022.1009878_eeg_mezzanine_quest.json
{
  "lore": {
    "title": "Recipe: Phylactery of True Sight",
    "description": "An artifact that binds to a XIAO-series Golem Core, granting it the ability to translate the subtle electrical whispers of the mind into coherent data. This recipe, discovered in an ancient tome, details the construction of a stackable mezzanine board, enabling advanced brain-computer interface functions.",
    "lore_hint": "This is a single phylactery, a mere scale of the beast. Legends speak of linking multiple phylacteries into a powerful Mind-Matrix, much like the interlocking scales of the mythical Pangolin."
  },
  "reagents": [
    {
      "componentReference": "U1", "componentDescription": "8-Channel ADC", "componentValue": "ADS131M08", "footprintIdentifier": "Package_QFP:LQFP-32_5x5mm_P0.5mm", "numberOfPins": 32, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":29,\"net\":\"AIN0P\"},{\"pin\":32,\"net\":\"AIN1P\"},{\"pin\":1,\"net\":\"AIN2P\"},{\"pin\":4,\"net\":\"AIN3P\"},{\"pin\":5,\"net\":\"AIN4P\"},{\"pin\":8,\"net\":\"AIN5P\"},{\"pin\":9,\"net\":\"AIN6P\"},{\"pin\":12,\"net\":\"AIN7P\"},{\"pin\":2,\"net\":\"AINREF\"},{\"pin\":3,\"net\":\"AINREF\"},{\"pin\":6,\"net\":\"AINREF\"},{\"pin\":7,\"net\":\"AINREF\"},{\"pin\":10,\"net\":\"AINREF\"},{\"pin\":11,\"net\":\"AINREF\"},{\"pin\":30,\"net\":\"AINREF\"},{\"pin\":31,\"net\":\"AINREF\"},{\"pin\":13,\"net\":\"GND\"},{\"pin\":25,\"net\":\"GND\"},{\"pin\":28,\"net\":\"GND\"},{\"pin\":24,\"net\":\"CAP\"},{\"pin\":14,\"net\":\"REFIN\"},{\"pin\":15,\"net\":\"AVDD\"},{\"pin\":26,\"net\":\"DVDD\"},{\"pin\":16,\"net\":\"SYNC/RESET\"},{\"pin\":17,\"net\":\"CS\"},{\"pin\":18,\"net\":\"DRDY\"},{\"pin\":19,\"net\":\"SCLK\"},{\"pin\":20,\"net\":\"DOUT\"},{\"pin\":21,\"net\":\"DIN\"},{\"pin\":23,\"net\":\"XTAL1/CLKIN\"}]"
    },
    {
      "componentReference": "U2", "componentDescription": "3.3V LDO Voltage Regulator", "componentValue": "LP5907QMFX-3.3Q1", "footprintIdentifier": "Package_TO_SOT_SMD:SOT-23-5", "numberOfPins": 5, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":5,\"net\":\"AVDD\"},{\"pin\":1,\"net\":\"5V\"},{\"pin\":3,\"net\":\"5V\"}]"
    },
    {
      "componentReference": "U3", "componentDescription": "3.3V LDO Voltage Regulator", "componentValue": "LP5907QMFX-3.3Q1", "footprintIdentifier": "Package_TO_SOT_SMD:SOT-23-5", "numberOfPins": 5, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":5,\"net\":\"DVDD\"},{\"pin\":1,\"net\":\"5V\"},{\"pin\":3,\"net\":\"5V\"}]"
    },
    {
      "componentReference": "X1", "componentDescription": "8.192MHz Oscillator", "componentValue": "8.192MHz", "footprintIdentifier": "freeeeg8-alpha:Oscillator_SMD_EuroQuartz_XO32-4Pin_3.2x2.5mm_RotB_HandSoldering", "numberOfPins": 4, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":4,\"net\":\"DVDD\"},{\"pin\":3,\"net\":\"XTAL1/CLKIN\"}]"
    },
    {
      "componentReference": "C1", "componentDescription": "220nF Ceramic Capacitor", "componentValue": "220nF", "footprintIdentifier": "Capacitor_SMD:C_0402_1005Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":1,\"net\":\"GND\"},{\"pin\":2,\"net\":\"CAP\"}]"
    },
    {
      "componentReference": "C2", "componentDescription": "100nF Ceramic Capacitor", "componentValue": "100nF", "footprintIdentifier": "Capacitor_SMD:C_0402_1005Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":1,\"net\":\"GND\"},{\"pin\":2,\"net\":\"REFIN\"}]"
    },
    {
      "componentReference": "C3", "componentDescription": "1uF Ceramic Capacitor", "componentValue": "1uF", "footprintIdentifier": "Capacitor_SMD:C_0402_1005Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":1,\"net\":\"AVDD\"}]"
    },
    {
      "componentReference": "C4", "componentDescription": "1uF Ceramic Capacitor", "componentValue": "1uF", "footprintIdentifier": "Capacitor_SMD:C_0402_1005Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":1,\"net\":\"DVDD\"}]"
    },
    {
      "componentReference": "C5", "componentDescription": "2.2uF Ceramic Capacitor", "componentValue": "2.2uF", "footprintIdentifier": "Capacitor_SMD:C_0603_1608Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":1,\"net\":\"AVDD\"}]"
    },
    {
      "componentReference": "C6", "componentDescription": "2.2uF Ceramic Capacitor", "componentValue": "2.2uF", "footprintIdentifier": "Capacitor_SMD:C_0603_1608Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":1,\"net\":\"GND\"},{\"pin\":2,\"net\":\"5V\"}]"
    },
    {
      "componentReference": "C7", "componentDescription": "2.2uF Ceramic Capacitor", "componentValue": "2.2uF", "footprintIdentifier": "Capacitor_SMD:C_0603_1608Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":1,\"net\":\"GND\"},{\"pin\":2,\"net\":\"DVDD\"}]"
    },
    {
      "componentReference": "C8", "componentDescription": "2.2uF Ceramic Capacitor", "componentValue": "2.2uF", "footprintIdentifier": "Capacitor_SMD:C_0603_1608Metric", "numberOfPins": 2, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":1,\"net\":\"5V\"}]"
    },
    {
      "componentReference": "J1", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN0P\"}]"
    },
    {
      "componentReference": "J2", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN1P\"}]"
    },
    {
      "componentReference": "J3", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN2P\"}]"
    },
    {
      "componentReference": "J4", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN3P\"}]"
    },
    {
      "componentReference": "J5", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN4P\"}]"
    },
    {
      "componentReference": "J6", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN5P\"}]"
    },
    {
      "componentReference": "J7", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN6P\"}]"
    },
    {
      "componentReference": "J8", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AIN7P\"}]"
    },
    {
      "componentReference": "J9", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"AINREF\"}]"
    },
    {
      "componentReference": "J10", "componentDescription": "Pogo Pin Electrode", "componentValue": "POGO", "footprintIdentifier": "freeeeg8-alpha:pogo_pin_d5x10mm_smd", "numberOfPins": 1, "side": "bottom", "exportSVG": true, "exportGLB": false, "pinConnections": "[{\"pin\":1,\"net\":\"GND\"}]"
    },
    {
      "componentReference": "J_XIAO_1", "componentDescription": "XIAO Header", "componentValue": "XIAO_HEADER", "footprintIdentifier": "Connector_PinHeader_2.54mm:PinHeader_1x07_P2.54mm_Vertical_SMD_Pin1Right", "numberOfPins": 7, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":1,\"net\":\"SYNC/RESET\"},{\"pin\":2,\"net\":\"DRDY\"},{\"pin\":3,\"net\":\"CS\"}]"
    },
    {
      "componentReference": "J_XIAO_2", "componentDescription": "XIAO Header", "componentValue": "XIAO_HEADER", "footprintIdentifier": "Connector_PinHeader_2.54mm:PinHeader_1x07_P2.54mm_Vertical_SMD_Pin1Left", "numberOfPins": 7, "side": "top", "exportSVG": true, "exportGLB": true, "pinConnections": "[{\"pin\":2,\"net\":\"GND\"},{\"pin\":1,\"net\":\"5V\"},{\"pin\":6,\"net\":\"SCLK\"},{\"pin\":5,\"net\":\"DOUT\"},{\"pin\":4,\"net\":\"DIN\"}]"
    }
  ]
}
```

# server/assets/research/papers/10.3389_fnins.2022.1009878.md
```server/assets/research/papers/10.3389_fnins.2022.1009878.md
# Individual finger movement decoding using a novel ultra-high-density electroencephalography-based brain-computer interface system

**Source:** Lee HS, Schreiner L, Jo S-H, et al. (2022) _Front. Neurosci._ 16:1009878. doi: 10.3389/fnins.2022.1009878

## Summary

This research paper explores the use of a novel ultra-high-density electroencephalography (uHD EEG) system to decode individual finger movements. The core idea is that increasing the spatial resolution of EEG sensors can significantly improve the ability to distinguish precise body motions, a task that is challenging for conventional EEG systems.

### Key Innovations & Findings:

1.  **uHD EEG System:** The study used a system with 256 channels densely distributed over the sensorimotor cortex, achieving an inter-electrode distance of just 8.6 mm, compared to 60-65 mm in standard EEG setups. This was achieved using flexible electrode grids attached directly to the scalp with medical adhesives.
2.  **Experiment:** Five healthy subjects performed single finger extensions based on visual cues. The brain activity was recorded, and a linear support vector machine (SVM) was used to classify which finger was moved.
3.  **Results:** The system achieved an average classification accuracy of 64.8%, with a peak of 70.6% for distinguishing between the middle and ring fingers. This demonstrates a notable improvement over conventional, lower-density EEG systems for such a fine motor task.

### Application for Aetherium (Market Context):

This paper provides the scientific foundation for creating a miniaturized, user-friendly, and economically viable version of this uHD EEG technology. The goal is to translate this research into a mass-market device, like a **mezzanine board for a small System-on-Module (e.g., Seeed Studio XIAO)**. This would make advanced BCI research and application development accessible to hobbyists, students, and independent researchers, moving it out of the exclusive domain of large, well-funded labs.

The in-game "Rune of True Sight" artifact is the magical manifestation of this real-world goal.
```

# server/assets/datasheet_cache/XIAO_RP2040_provide_a_json_object_of_all_pin_functions.json
```server/assets/datasheet_cache/XIAO_RP2040_provide_a_json_object_of_all_pin_functions.json

{
  "componentName": "XIAO_RP2040",
  "question": "Provide a JSON object of all pin functions.",
  "answer": "{\n  \"pinout\": [\n    {\"pin\": 1, \"name\": \"PA2/D0/A0/AREF\", \"type\": \"I/O\", \"description\": \"GPIO PA2, Digital Pin 0, Analog Pin 0, DAC, AREF\"},\n    {\"pin\": 2, \"name\": \"PA3/D1/A1\", \"type\": \"I/O\", \"description\": \"GPIO PA3, Digital Pin 1, Analog Pin 1\"},\n    {\"pin\": 3, \"name\": \"PA4/D2/A2\", \"type\": \"I/O\", \"description\": \"GPIO PA4, Digital Pin 2, Analog Pin 2\"},\n    {\"pin\": 4, \"name\": \"PA5/D3/A3\", \"type\": \"I/O\", \"description\": \"GPIO PA5, Digital Pin 3, Analog Pin 3\"},\n    {\"pin\": 5, \"name\": \"PA6/D4/A4/SDA\", \"type\": \"I/O\", \"description\": \"GPIO PA6, Digital Pin 4, Analog Pin 4, I2C SDA\"},\n    {\"pin\": 6, \"name\": \"PA7/D5/A5/SCL\", \"type\": \"I/O\", \"description\": \"GPIO PA7, Digital Pin 5, Analog Pin 5, I2C SCL\"},\n    {\"pin\": 7, \"name\": \"PA8/D6/A6/TX\", \"type\": \"I/O\", \"description\": \"GPIO PA8, Digital Pin 6, Analog Pin 6, UART TX\"},\n    {\"pin\": 8, \"name\": \"PA9/D7/A7/RX\", \"type\": \"I/O\", \"description\": \"GPIO PA9, Digital Pin 7, Analog Pin 7, UART RX\"},\n    {\"pin\": 9, \"name\": \"PA10/D8/A8/SCK\", \"type\": \"I/O\", \"description\": \"GPIO PA10, Digital Pin 8, Analog Pin 8, SPI SCK\"},\n    {\"pin\": 10, \"name\": \"PA11/D9/A9/MISO\", \"type\": \"I/O\", \"description\": \"GPIO PA11, Digital Pin 9, Analog Pin 9, SPI MISO\"},\n    {\"pin\": 11, \"name\": \"PB0/D10/A10/MOSI\", \"type\": \"I/O\", \"description\": \"GPIO PB0, Digital Pin 10, Analog Pin 10, SPI MOSI\"},\n    {\"pin\": 12, \"name\": \"3V3\", \"type\": \"Power\", \"description\": \"3.3V Power Output\"},\n    {\"pin\": 13, \"name\": \"GND\", \"type\": \"Power\", \"description\": \"Ground\"},\n    {\"pin\": 14, \"name\": \"5V\", \"type\": \"Power\", \"description\": \"5V Power Input/Output from USB\"}\n  ]\n}",
  "timestamp": "2024-07-28T12:00:03.000Z"
}

```

# server/assets/datasheet_cache/ADS131M08_provide_a_json_object_of_all_pin_functions_for_t.json
```server/assets/datasheet_cache/ADS131M08_provide_a_json_object_of_all_pin_functions_for_t.json

{
  "componentName": "ADS131M08",
  "question": "Provide a JSON object of all pin functions for the TQFP package.",
  "answer": "{\n  \"pinout\": [\n    {\"pin\": 1, \"name\": \"AIN2P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 2\"},\n    {\"pin\": 2, \"name\": \"AIN2N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 2\"},\n    {\"pin\": 3, \"name\": \"AIN3N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 3\"},\n    {\"pin\": 4, \"name\": \"AIN3P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 3\"},\n    {\"pin\": 5, \"name\": \"AIN4P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 4\"},\n    {\"pin\": 6, \"name\": \"AIN4N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 4\"},\n    {\"pin\": 7, \"name\": \"AIN5N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 5\"},\n    {\"pin\": 8, \"name\": \"AIN5P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 5\"},\n    {\"pin\": 9, \"name\": \"AIN6P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 6\"},\n    {\"pin\": 10, \"name\": \"AIN6N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 6\"},\n    {\"pin\": 11, \"name\": \"AIN7N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 7\"},\n    {\"pin\": 12, \"name\": \"AIN7P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 7\"},\n    {\"pin\": 13, \"name\": \"AGND\", \"type\": \"Supply\", \"description\": \"Analog ground\"},\n    {\"pin\": 14, \"name\": \"REFIN\", \"type\": \"Analog input\", \"description\": \"External reference voltage input\"},\n    {\"pin\": 15, \"name\": \"AVDD\", \"type\": \"Supply\", \"description\": \"Analog supply. Connect a 1-µF capacitor to AGND.\"},\n    {\"pin\": 16, \"name\": \"SYNC/RESET\", \"type\": \"Digital input\", \"description\": \"Conversion synchronization or system reset; active low\"},\n    {\"pin\": 17, \"name\": \"CS\", \"type\": \"Digital input\", \"description\": \"Chip select; active low\"},\n    {\"pin\": 18, \"name\": \"DRDY\", \"type\": \"Digital output\", \"description\": \"Data ready; active low\"},\n    {\"pin\": 19, \"name\": \"SCLK\", \"type\": \"Digital input\", \"description\": \"Serial data clock\"},\n    {\"pin\": 20, \"name\": \"DOUT\", \"type\": \"Digital output\", \"description\": \"Serial data output\"},\n    {\"pin\": 21, \"name\": \"DIN\", \"type\": \"Digital input\", \"description\": \"Serial data input\"},\n    {\"pin\": 22, \"name\": \"XTAL2\", \"type\": \"Digital output\", \"description\": \"Crystal oscillator excitation\"},\n    {\"pin\": 23, \"name\": \"XTAL1/CLKIN\", \"type\": \"Digital input\", \"description\": \"Master clock input, or crystal oscillator input\"},\n    {\"pin\": 24, \"name\": \"CAP\", \"type\": \"Analog output\", \"description\": \"Digital low-dropout (LDO) regulator output. Connect a 220-nF capacitor to DGND.\"},\n    {\"pin\": 25, \"name\": \"DGND\", \"type\": \"Supply\", \"description\": \"Digital ground\"},\n    {\"pin\": 26, \"name\": \"DVDD\", \"type\": \"Supply\", \"description\": \"Digital I/O supply. Connect a 1-µF capacitor to DGND.\"},\n    {\"pin\": 27, \"name\": \"NC\", \"type\": \"-\", \"description\": \"Leave unconnected or connect to AGND\"},\n    {\"pin\": 28, \"name\": \"AGND\", \"type\": \"Supply\", \"description\": \"Analog ground\"},\n    {\"pin\": 29, \"name\": \"AIN0P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 0\"},\n    {\"pin\": 30, \"name\": \"AIN0N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 0\"},\n    {\"pin\": 31, \"name\": \"AIN1N\", \"type\": \"Analog input\", \"description\": \"Negative analog input 1\"},\n    {\"pin\": 32, \"name\": \"AIN1P\", \"type\": \"Analog input\", \"description\": \"Positive analog input 1\"}\n  ]\n}",
  "timestamp": "2024-07-28T12:00:00.000Z"
}

```

# server/assets/datasheet_cache/ECS-2520MV_provide_a_json_object_of_all_pin_functions.json
```server/assets/datasheet_cache/ECS-2520MV_provide_a_json_object_of_all_pin_functions.json

{
  "componentName": "ECS-2520MV",
  "question": "Provide a JSON object of all pin functions.",
  "answer": "{\n  \"pinout\": [\n    {\"pin\": 1, \"name\": \"Tri-state\", \"type\": \"Input\", \"description\": \"Tri-state function control. Active when high or NC, High Impedance when low.\"},\n    {\"pin\": 2, \"name\": \"Gnd\", \"type\": \"Ground\", \"description\": \"Ground connection.\"},\n    {\"pin\": 3, \"name\": \"Output\", \"type\": \"Output\", \"description\": \"Clock signal output.\"},\n    {\"pin\": 4, \"name\": \"Vdd\", \"type\": \"Power\", \"description\": \"Power supply voltage.\"}\n  ]\n}",
  "timestamp": "2024-07-28T12:00:02.000Z"
}

```

# server/assets/datasheet_cache/LP5907_provide_a_json_object_of_all_pin_functions_for_t.json
```server/assets/datasheet_cache/LP5907_provide_a_json_object_of_all_pin_functions_for_t.json

{
  "componentName": "LP5907",
  "question": "Provide a JSON object of all pin functions for the SOT-23 package.",
  "answer": "{\n  \"pinout\": [\n    {\"pin\": 1, \"name\": \"IN\", \"type\": \"Input\", \"description\": \"Input voltage supply. Connect a 1-µF capacitor at this input.\"},\n    {\"pin\": 2, \"name\": \"GND\", \"type\": \"Ground\", \"description\": \"Common ground\"},\n    {\"pin\": 3, \"name\": \"EN\", \"type\": \"Input\", \"description\": \"Enable input. A high voltage enables the regulator. Internal 1-MΩ pulldown resistor.\"},\n    {\"pin\": 4, \"name\": \"N/C\", \"type\": \"-\", \"description\": \"No internal electrical connection.\"},\n    {\"pin\": 5, \"name\": \"OUT\", \"type\": \"Output\", \"description\": \"Regulated output voltage. Connect a minimum 1-µF low-ESR capacitor.\"}\n  ]\n}",
  "timestamp": "2024-07-28T12:00:01.000Z"
}

```

# components/UIToolRunner.tsx
```components/UIToolRunner.tsx


import React, { useMemo } from 'react';
import type { LLMTool, UIToolRunnerProps } from '../types';
import DebugLogView from './ui_tools/DebugLogView';
import * as Icons from './icons';
import { ALL_DATASHEETS } from '../bootstrap/datasheets';

// Destructure the imported datasheets for use in the new Function scope
const { ADS131M08_DATASHEET, LP5907_DATASHEET, XIAO_DATASHEET, ECS2520MV_DATASHEET } = ALL_DATASHEETS;

// Tell TypeScript about the global Babel object from the script tag in index.html
declare var Babel: any;

interface UIToolRunnerComponentProps {
  tool: LLMTool;
  props: UIToolRunnerProps;
}

// A wrapper to catch runtime errors in the compiled component.
// It now resets its error state if the tool being rendered changes.
class ErrorBoundary extends React.Component<{ fallback: React.ReactNode, children: React.ReactNode, toolName: string }, { hasError: boolean }> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: any) {
    return { hasError: true };
  }

  componentDidUpdate(prevProps: { toolName: string }) {
    if (this.props.toolName !== prevProps.toolName) {
      // eslint-disable-next-line react/no-did-update-set-state
      this.setState({ hasError: false });
    }
  }

  componentDidCatch(error: any, errorInfo: any) {
    console.error(`UI Tool Runner Error in tool '${this.props.toolName}':`, error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}

const UIToolRunner: React.FC<UIToolRunnerComponentProps> = ({ tool, props }) => {
  // Memoize the compiled component to prevent re-compiling and re-mounting on every render,
  // which was causing the flickering and state loss in complex components like the interactive graph.
  const CompiledComponent = useMemo(() => {
    if (tool.category !== 'UI Component') {
      return () => <div>Error: Tool "{tool.name}" is not a UI Component.</div>;
    }

    // Special case for complex, directly imported components that don't need compilation.
    if (tool.name === 'Debug Log View') {
        return DebugLogView;
    }

    const code = tool.implementationCode || '';
    const sanitizedCode = code.replace(/export default .*;?/g, '');

    // Decouple component compilation from the live props object.
    // The list of props to destructure is derived from the tool's static definition.
    // This makes the compiled function stable across renders.
    const propKeys = tool.parameters?.map(p => p.name) || [];

    const componentSource = `(props) => {
      const { ${propKeys.join(', ')} } = props;
      ${sanitizedCode}
    }`;

    try {
      const { code: transformedCode } = Babel.transform(componentSource, {
        presets: ['react']
      });
      
      const iconNames = Object.keys(Icons);
      const iconComponents = Object.values(Icons);
      
      // Add datasheets to the function scope
      const datasheets = { ADS131M08_DATASHEET, LP5907_DATASHEET, XIAO_DATASHEET, ECS2520MV_DATASHEET };
      const datasheetNames = Object.keys(datasheets);
      const datasheetValues = Object.values(datasheets);
      
      const componentFactory = new Function('React', 'UIToolRunner', ...iconNames, ...datasheetNames, `return ${transformedCode}`);
      return componentFactory(React, UIToolRunner, ...iconComponents, ...datasheetValues);

    } catch (e) {
      console.error(`Error compiling UI tool '${tool.name}':`, e);
      console.error('Offending code:', tool.implementationCode);
      return () => (
        <div className="p-4 bg-red-900/50 border-2 border-dashed border-red-500 rounded-lg text-red-300">
          <p className="font-bold">UI Compilation Error in "{tool.name}" (v{tool.version})</p>
          <pre className="mt-2 text-xs whitespace-pre-wrap">{e instanceof Error ? e.message : String(e)}</pre>
        </div>
      );
    }
  // The dependencies ensure re-compilation only happens if the tool's definition changes.
  // Using tool.id and tool.version is sufficient to detect tool updates.
  }, [tool.id, tool.version]);


  const fallback = (
    <div className="p-4 bg-yellow-900/50 border-2 border-dashed border-yellow-500 rounded-lg text-yellow-300">
      <p className="font-bold">UI Runtime Error in "{tool.name}" (v{tool.version})</p>
      <p className="text-sm">The component failed to render. Check console for details.</p>
    </div>
  );

  return (
    <ErrorBoundary fallback={fallback} toolName={tool.name}>
        <CompiledComponent {...props} />
    </ErrorBoundary>
  );
};

export default UIToolRunner;

```

# components/icons.tsx
```components/icons.tsx


import React from 'react';

export const UIIcon: React.FC<{className?: string}> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
    </svg>
);

export const FunctionalIcon: React.FC<{className?: string}> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7.014A8.003 8.003 0 0112 3c2.757 0 5.223 1.28 6.986 3.286C21.5 8 22 11 22 13c-2 1-2.014 2.986-2.014 2.986a8.003 8.003 0 01-2.329 2.671z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M6.343 7.343A8 8 0 003 12c0 2.757 1.28 5.223 3.286 6.986C8 21.5 11 22 13 22c1-2 2.986-2.014 2.986-2.014a8.003 8.003 0 002.671-2.329" />
    </svg>
);

export const AutomationIcon: React.FC<{className?: string}> = ({ className }) => (
     <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" />
    </svg>
);

export const TopicIcon: React.FC<{className?: string}> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A2 2 0 013 12V7a4 4 0 014-4z" />
    </svg>
);

export const GearIcon: React.FC<{className?: string}> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
);

export const BeakerIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547a2 2 0 00-.547 1.806l.443 2.387a6 6 0 00.517 3.86l.158.318a6 6 0 00.517 3.86l.477 2.387a2 2 0 00.547 1.022a2 2 0 001.806.547l2.387-.443a6 6 0 003.86-.517l.318-.158a6 6 0 013.86-.517l2.387.477a2 2 0 001.806-.547a2 2 0 00.547-1.806l-.443-2.387a6 6 0 00-.517-3.86l-.158-.318a6 6 0 00-.517-3.86l-.477-2.387zM12 6V4m0 2a2 2 0 012 2v1H10V8a2 2 0 012-2z" />
    </svg>
);

export const PaperClipIcon: React.FC<{className?: string}> = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13" />
  </svg>
);

export const LinkIcon: React.FC<{className?: string}> = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
  </svg>
);

export const XCircleIcon: React.FC<{className?: string}> = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="currentColor" viewBox="0 0 20 20">
    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
  </svg>
);

export const PlayIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clipRule="evenodd" />
    </svg>
);

export const PauseIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h1a1 1 0 001-1V8a1 1 0 00-1-1H8zm3 0a1 1 0 00-1 1v4a1 1 0 001 1h1a1 1 0 001-1V8a1 1 0 00-1-1h-1z" clipRule="evenodd" />
    </svg>
);

export const StopIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 9a1 1 0 00-1 1v1a1 1 0 001 1h4a1 1 0 001-1v-1a1 1 0 00-1-1H8z" clipRule="evenodd" />
    </svg>
);

export const StepForwardIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor">
        <path d="M4.555 5.168A1 1 0 003 6v8a1 1 0 001.555.832l6-4a1 1 0 000-1.664l-6-4zM14 6a1 1 0 00-1 1v6a1 1 0 102 0V7a1 1 0 00-1-1z" />
    </svg>
);

export const StepBackwardIcon: React.FC<{ className?: string }> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 20 20" fill="currentColor">
        <path d="M6.555 5.168A1 1 0 005 6v8a1 1 0 001.555.832l6-4a1 1 0 000-1.664l-6-4zM13 6a1 1 0 00-1 1v6a1 1 0 102 0V7a1 1 0 00-1-1z" transform="matrix(-1 0 0 1 18 0)"/>
    </svg>
);
```

# components/ui_tools/DebugLogView.tsx
```components/ui_tools/DebugLogView.tsx


import React, { useState, useEffect, useRef } from 'react';

interface DebugLogViewProps {
    logs: string[];
    onReset: () => void;
    apiCallCounts: Record<string, number>;
    apiCallLimit: number;
    agentCount: number;
}

const DebugLogView: React.FC<DebugLogViewProps> = ({ logs, onReset, apiCallCounts, apiCallLimit, agentCount }) => {
    const [isOpen, setIsOpen] = useState(false);
    const logsContainerRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (isOpen && logsContainerRef.current) {
            logsContainerRef.current.scrollTop = logsContainerRef.current.scrollHeight;
        }
    }, [logs, isOpen]);

    const totalCalls = React.useMemo(() => 
        Object.values(apiCallCounts || {}).reduce((sum, count) => sum + count, 0), 
    [apiCallCounts]);

    const getLogColor = (log: string) => {
        const upperCaseLog = log.toUpperCase();
        if (upperCaseLog.includes('[API CALL')) return 'text-cyan-400';
        if (upperCaseLog.includes('[ERROR]')) return 'text-red-400';
        if (upperCaseLog.includes('[WARN]')) return 'text-yellow-400';
        if (upperCaseLog.includes('[SUCCESS]')) return 'text-green-400';
        if (upperCaseLog.includes('💡')) return 'text-yellow-300 bg-yellow-900/30 p-1 rounded';
        return 'text-slate-300';
    };

    return (
        <div className="fixed bottom-4 right-4 z-[100] text-sm flex flex-col items-end gap-2">
            <div className={`w-[40rem] max-w-[calc(100vw-2rem)] h-96 bg-slate-900/90 backdrop-blur-sm border border-slate-600 rounded-lg p-2 flex-col shadow-2xl ${isOpen ? 'flex' : 'hidden'}`}>
                <div className="flex justify-between items-center mb-2 gap-2">
                    <h3 className="text-lg font-bold text-slate-200">Event Log</h3>
                    <button
                        onClick={onReset}
                        className="text-xs px-2 py-1 bg-red-800/50 text-red-300 border border-red-700 rounded-md hover:bg-red-700/50"
                        title="Reset all progress and saved data"
                    >
                        Factory Reset
                    </button>
                </div>
                <div ref={logsContainerRef} className="flex-grow overflow-y-auto bg-black/30 p-2 rounded text-xs font-mono scroll-smooth">
                    {logs.map((log, index) => (
                        <div key={index} className={`py-0.5 border-b border-slate-800/50 flex items-start gap-1.5 ${getLogColor(log)}`}>
                            <p className="flex-grow break-words whitespace-pre-wrap">{log}</p>
                        </div>
                    ))}
                </div>
            </div>
            
            <button
                onClick={() => setIsOpen(!isOpen)}
                className="bg-gray-800/80 backdrop-blur-sm border border-gray-700/50 px-3 py-2 rounded-lg shadow-lg flex items-center gap-4 hover:bg-gray-700/80 transition-colors"
                aria-label="Toggle debug log"
                aria-expanded={isOpen}
            >
                <div className="flex items-center gap-2 text-gray-400" title="Active Agents / API Calls">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z" /></svg>
                    <span>{agentCount}</span>
                    <span className="text-gray-600">/</span>
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 102 0V6zM10 15a1 1 0 110-2 1 1 0 010 2z" clipRule="evenodd" /></svg>
                    <span>{totalCalls}</span>
                </div>
                <div className="w-px h-4 bg-gray-600"></div>
                <div className="flex items-center gap-2 text-gray-300" title="Toggle Log">
                     <span>Log ({logs.length})</span>
                     <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>
                </div>
            </button>
        </div>
    );
};

export default DebugLogView;
```

# components/ui_tools/index.ts
```components/ui_tools/index.ts
// This file is intentionally left blank.
// Tool definitions have been moved to bootstrap_tools.ts and are loaded programmatically.
export {};

```

